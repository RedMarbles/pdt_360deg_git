#@gmic
#
#  File        : gmic_def.raw
#                ( G'MIC default macro file )
#
#  Description : Define additional commands for G'MIC (GREYC's Magic Image Converter).
#                ( http://gmic.sourceforge.net )
#                This file is also a part of the CImg Library project.
#                ( http://cimg.sourceforge.net )
#
#  Usage       : gmic [-m gmic_def.raw] (...)
#
#  Note        : This file is here for illustration purposes, since commands defined in
#                the default macro file are already present by default in G'MIC.
#                Then, explicit inclusion of this file (using the '-m' option) if
#                useless.
#
#  Copyright   : David Tschumperle
#                ( http://www.greyc.ensicaen.fr/~dtschump/ )
#
#  License     : CeCILL v2.0
#                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://www.cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#


#--- General syntax rules for a G'MIC macro file : ---------------------------------------------------------------------
#
# - Each line starting with '#' is a comment line.
#
# - Each line starting with 'command_name : ' defines the beginning of a new G'MIC macro command.
#
# - Any other line is considered as the continuation of the previous started G'MIC macro command.
#
# - A comment line as '#@gmic command_name : arguments : description' will be used in the command line
#   version of G'MIC as the helper for this command (displayed when invoking 'gmic -help').
#
# - A comment line starting with '#@gimp' will be used to in the GIMP plug-in version of G'MIC to define
#   a new filter entry.
#
# - Same rules apply for comment line starting with '#@gimp_xx' to define filters translated in language
#   'xx' (e.g. 'en','fr'...).
#
#   More precisely, the syntax of a '#@gimp' comment line can be :
#
#   '#@gimp Group name'
#
# or
#
#   '#@gimp Command name : command, preview_command, parameter = typedef, parameter2 = typedef'
#   '#@gimp : parameter3 = typedef, parameter4 = typedef ...., parameterN = typedef'
#
#   where :
#      'command' is the G'MIC command name called to process the image.
#      'preview_command' is the G'MIC command name called to process the preview.
#      'parameter = typedef' tells about the names, types and default values of the filter parameters.
#
#   'typedef' can be :
#
#      - 'float(default_value,min_value,max_value)'     : Add a float-valued parameter (as a GUI float slider).
#      - 'int(default_value,min_value,max_value)'       : Add a integer parameter (as a GUI integer slider).
#      - 'bool(default_value={0,1,false,true})'         : Add a boolean parameter (0 or 1) (as a GUI checkbutton).
#      - 'choice([deft_indice],"Choice0",..,"ChoiceN")' : Add a integer parameter (as a GUI combobox).
#      - 'text("default text")'                         : Add a text parameter (as a GUI text entry).
#      - 'file("default_filename")'                     : Add a filename parameter (as a GUI filechooser).
#      - 'color(defaultR,defaultG,defaultB[,defaultA])' : Add R,G,B[,A] parameters (as a GUI colorchooser).
#      - 'note("Comment")'                              : Display a label, but do not add a new parameter.
#      - 'link("Comment","URL")'                        : Display a label that link to a specified URL.
#      - 'value(value)'                                 : Do not display a GUI widget, but set a parameter value.
#
#   Type separators '()' can be replaced by '[]' and '{}' if necessary (for instance if parentheses are required in
#   an argument of the typedef, e.g in a text).
#
#-----------------------------------------------------------------------------------------------------------------------

#----------------------------------------
#
# Get and display image characteristics
#
#----------------------------------------

#@gmic gradient_norm : (no args) : Compute gradient norm of image(s).
gradient_norm :
  -e "Compute gradient norm of image$?."
  -v- -t float -repeat @#
    -gradient[-1] xyz -a[-3--1] v -norm[-1] -sqrt[-1]
  -mv[-1] 0 -done -v+

#@gmic gradient_orientation : '_dimension={1,2,3}' : Compute N-D gradient orientation of image(s).
gradient_orientation : -int ${1=3}
  -if "$1<1 || $1>3" -error "Invalid argument '$*' (should be 'dimension={1,2,3}')." -endif
  -e "Compute $1-D gradient orientation of image$?."
  -v- -t float -repeat @#
    -if $1==1 -gradient[-1] x --abs[-1] -+[-1] 1e-8 -/[-2,-1] -else
    -if $1==2 -gradient[-1] xy --sqr[-2--1] -+[-2,-1] -+[-1] 1e-8 -sqrt[-1] -/[-3] [-1] -/[-2,-1] -else
    -gradient[-1] xyz --sqr[-3--1] -+[-3--1] -+[-1] 1e-8 -sqrt[-1] -/[-4,-3] [-1] -/[-2,-1]
    -endif -endif
  -mv[-$1--1] 0 -done -v+

#@gmic gradient2rgb : '_orientation={0,1}' : Compute RGB representation of 2D gradient of image(s).
gradient2rgb : -int ${1=0}
  -if $1 -e "Compute RGB representation of 2D gradient of image$?."
  -else -e "Compute RGB representation of 2D gradient orientation of image$?." -endif
  -v- -t float -repeat @#
    -norm[-1] -if $1 -gradient_orientation[-1] 2 -else -gradient[-1] xy -endif
    -a[-2,-1] v -direction2rgb[-1]
  -mv[-1] 0 -done -v+

#@gmic laplacian : (no args) : Compute Laplacian of image(s).
laplacian :
  -e "Compute Laplacian of image $?."
  -v- -t float -repeat @#
    -hessian[-1] xxyyzz -+[-3--1]
  -mv[-1] 0 -done -v+

#@gmic gradient_2derivative : (no args) : Compute gradient-directed 2nd derivative of image(s).
gradient_2derivative :
  -e "Compute gradient-directed 2nd derivative of image$?."
  -v- -t float -repeat @#
    --gradient[-1] xyz -hessian[-4] xxxyxzyyyzzz
    --sqr[-3] -*[-10,-1] --sqr[-2] -*[-7,-1] --sqr[-1] -*[-5,-1]
    -*[-8,-7,-5] 2 -*[-8] [-3] -*[-8] [-2] -*[-7] [-3] -*[-7] [-1] -*[-5] [-2] -*[-5] [-1]
    -+[-9--4] -sqr[-3--1] -+[-3--1] -+[-1] 1e-8 -/[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic dog : '_sigma1>=0[%],_sigma2>=0[%]' : Compute difference of gaussian-filtered image(s).
dog : -skip ${1=2%},${2=3%}
  -e "Compute difference of gaussians-filtered image$?, with standard deviations $1 and $2."
  -v- -t float -repeat @#
    --blur[-1] $1 -blur[-2] $2 --[-2,-1] -norm[-1]
  -mv[-1] 0 -done -v+

#@gmic curvature : (no args) : Compute isophotes curvature of image(s).
curvature :
  -e "Compute isophotes curvature of image$?."
  -v- -t float -repeat @#
    [-1],2 -laplacian[-3] -gradient_2derivative[-2] --[-3,-2] -gradient_norm[-1] -+[-1] 1e-8 -/[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic sum : (no args) : Compute value sum of image(s).
sum :
  -e "Compute value sum of image$?."
  -v- -t float -repeat @#
    -l[-1] -s v -+ -s z -+ -s y -+ -s x -+ -endl
  -mv[-1] 0 -done -v+

#@gmic histogram_cumul : '_nb_levels>0' : Compute cumulative histogram of image(s).
histogram_cumul :
  -e "Compute cumulative histogram of image$?, using $1 levels."
  -v- -t float -histogram $1 -repeat @#
    -i[-2] [-1],1,1,1,0 -repeat @{-1,w} -+[-2] [-1] -translate[-1] 1 -done -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic transfer_histogram : (no args) : Transfer histogram of the last image to the other ones.
transfer_histogram :
  -e "Transfert histogram of last image to image$?."
  -v- -t float -to_rgb -equalize[0--2] 256 --histogram_cumul[-1] 256 -/[-1] @{-1,#} -*[-1] 255
  -repeat @#-2
    -s[-3] v -index[-5--3] [-1] -a[-5--3] v
  -mv[-3] 0 -done -rm[-1] -v+

#@gmic complex2polar : (no args) : Compute complex to polar transform for image(s).
complex2polar :
  -e "Compute complex to polar transform for image$?."
  -v- -t float -repeat @#/2
    -r[-1] [-2],3 --atan2[-1] [-2] -sqr[-3,-2] -+[-3,-2] -sqrt[-2]
  -mv[-2,-1] 0 -done -v+

#@gmic polar2complex : (no args) : Compute polar to complex transform(s) for image(s).
polar2complex :
  -e "Compute polar to complex transform for image$?."
  -v- -t float -repeat @#/2
    -r[-1] [-2],3 --sin[-1] -cos[-2] -*[-1] [-3] -*[-3,-2]
  -mv[-2,-1] 0 -done -v+

#@gmic direction2rgb : (no args) : Compute RGB representation of 2D direction field(s).
direction2rgb :
  -e "Compute RGB-colored representation of 2D direction field$?."
  -v- -t float -repeat @#
    -channels[-1] 0,1 -s[-1] v -complex2polar[-2,-1]
    -*[-1] 128 -/[-1] 3.14159265359 -+[-1] 256 -mod[-1] 256 -map[-1] 1
    -to_rgb[-2] -n[-2] 0,1 -*[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic normalize_sum : (no args) : Normalize image(s) with a unitary sum.
normalize_sum :
  -e "Normalize image$? with a unitary sum."
  -v- -t float -repeat @#
    --sum[-1] -if @-1>0 -/[-2] @-1 -endif -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic convolve_fft : (no args) : Convolve image(s) through Fourier transforms.
convolve_fft :
  -e "Convolve image$? through Fourier transforms."
  -v- -t float -repeat @#/2
    -r[-1] 100%,100%,100%,[-2],1 -r[-1] [-2],0,0,1 -translate[-1] -50%,-50%,-50%,0,2
    -fft[-2] -fft[-1] -translate[-1] -50%,-50%,-50%,0,2
    --*[-4] [-1] --*[-4] [-3] -+[-2,-1]
    -*[-5,-3] -*[-3,-2] --[-3,-2]
    -ifft[-2,-1] -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic deconvolve_fft : (no args) : Deconvolve image(s) through Fourier transforms.
deconvolve_fft :
  -e "Deconvolve image$? through Fourier transforms."
  -v- -t float -repeat @#/2
    -r[-1] 100%,100%,100%,[-2],1 -r[-1] [-2],0,0,1 -translate[-1] -50%,-50%,-50%,0,2
    -fft[-2] -fft[-1] -translate[-1] -50%,-50%,-50%,0,2
    --sqr[-2] --sqr[-2] -+[-2,-1] -+[-1] 0.0001 -/[-5--2] [-1] -rm[-1]
    --*[-3] [-2] --*[-5] [-2] --[-2,-1]
    -*[-5,-3] -*[-3,-2] -+[-3,-2]
    -ifft[-2,-1] -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic to_tensors : (no args) : Convert vector field(s) to diffusion tensor field(s).
to_tensors :
  -e "Convert vector field$? to diffusion tensor field$?."
  -v- -t float -repeat @# -l[-1]
    -s v
    -if @#==2 --sqr[-1] -*[-2] [-3] -sqr[-3] -else
    -if @#==3 --sqr[-2] --*[-3] [-2] --sqr[-3] -*[-5,-4] [-6] -sqr[-6] -else
    -error "Invalid image : Dimensions @{-1,w},@{-1,h},@{-1,d},@{-1,c} does not represent a field of 2D or 3D vectors."
    -endif -endif
    -a v
  -endl -mv[-1] 0 -done -v+

#@gmic display_fft : (no args) : Display Fourier transform of image(s) with centered log-module and argument (eq. to '-dfft').
display_fft :
  -e "Display Fourier transform of image$? with centered log-module and argument."
  -v- -t float -repeat @#
    -fft[-1] -complex2polar[-2,-1] -translate[-2,-1] 50%,50%,50%,0,2 -+[-2] 1 -log[-2] -n[-2,-1] 0,255 -a[-2,-1] x
  -mv[-1] 0 -done -s x,2 -v+

dfft :
  -display_fft

#@gmic display_rgba : (no args) : Render RGBA image(s) over checkerboard background (eq. to '-drgba').
display_rgba :
  -e "Render RGBA image$? over checkerboard background."
  -v- -repeat @#
    -i[-2] (160,128;128,160) -r[-2] 16,16 -r[-2] [-1],[-1],1,3,0,2 -compose_rgba[-2,-1]
  -mv[-1] 0 -done -v+

drgba :
  -display_rgba


#-----------------------------
#
# Geometric filters
#
#-----------------------------

#@gmic resize2dx : 'width>0,_interpolation_type={0,1,2,3,4,5}' : Resize image(s) along the X-axis, preserving 2D ratio (eq. to '-r2dx').
resize2dx : -int $1,${2=2}
  -if "$1<=0 || $2<0 || $2>5" -error "Invalid argument '$*' (should be 'width>0,_interpolation_type={0,1,2,3,4,5}')." -endif
  -e "Resize 2D image$? to $1 pixels along the X-axis, preserving 2D ratio."
  -v- -t float -repeat @#
    (@{-1,h}) -*[-1] $1 -/[-1] @{-2,w} -cut[-1] 1,100%
    -r[-2] $1,@-1,[-2],[-2],$2 -rm[-1]
  -mv[-1] 0 -done -v+

r2dx :
  -resize2dx $*

#@gmic resize3dx : 'width>0,_interpolation_type={0,1,2,3,4,5}' : Resize image(s) along the X-axis, preserving 3D ratio (eq. to '-r3dx').
resize3dx : -int $1,${2=2}
  -if "$1<=0 || $2<0 || $2>5" -error "Invalid argument '$*' (should be 'width>0,_interpolation_type={0,1,2,3,4,5}')." -endif
  -e "Resize 3D image$? to $1 pixels along the X-axis, preserving 3D ratio."
  -v- -t float -repeat @#
    (@{-1,h},@{-1,d}) -*[-1] $1 -/[-1] @{-2,w} -cut[-1] 1,100%
    -r[-2] $1,@-1,[-2],$2 -rm[-1]
  -mv[-1] 0 -done -v+

r3dx :
  -resize3dx $*

#@gmic resize2dy : 'height>0,_interpolation_type={0,1,2,3,4,5}' : Resize image(s) along the Y-axis, preserving 2D ratio (eq. to '-r2dy').
resize2dy : -int $1,${2=2}
  -if "$1<=0 || $2<0 || $2>5" -error "Invalid argument '$*' (should be 'height>0,_interpolation_type={0,1,2,3,4,5}')." -endif
  -e "Resize 2D image$? to $1 pixels along the Y-axis, preserving 2D ratio."
  -v- -t float -repeat @#
    (@{-1,w}) -*[-1] $1 -/[-1] @{-2,h} -cut[-1] 1,100%
    -r[-2] @-1,$1,[-2],[-2],$2 -rm[-1]
  -mv[-1] 0 -done -v+

r2dy :
  -resize2dy $*

#@gmic resize3dy : 'height>0,_interpolation_type={0,1,2,3,4,5}' : Resize image(s) along the Y-axis, preserving 3D ratio (eq. to '-r3dy').
resize3dy : -int $1,${2=2}
  -if "$1<=0 || $2<0 || $2>5" -error "Invalid argument '$*' (should be 'height>0,_interpolation_type={0,1,2,3,4,5}')." -endif
  -e "Resize 3D image$? to $1 pixels along the Y-axis, preserving 3D ratio."
  -v- -t float -repeat @#
    (@{-1,w},@{-1,h}) -*[-1] $1 -/[-1] @{-2,h} -cut[-1] 1,100%
    -r[-2] @{-1,0},$1,@{-1,1},[-2],$2 -rm[-1]
  -mv[-1] 0 -done -v+

r3dy :
  -resize3dy $*

#@gmic resize3dz : 'depth>0,_interpolation_type={0,1,2,3,4,5}' : Resize image(s) along the Z-axis, preserving 3D ratio (eq. to '-r3dz').
resize3dz : -int $1,${2=2}
  -if "$1<=0 || $2<0 || $2>5" -error "Invalid argument '$*' (should be 'depth>0,_interpolation_type={0,1,2,3,4,5}')." -endif
  -e "Resize 3D image$? to $1 pixels along the Z-axis, preserving 3D ratio."
  -v- -t float -repeat @#
    (@{-1,w},@{-1,h}) -*[-1] $1 -/[-1] @{-2,d} -cut[-1] 1,100%
    -r[-2] @-1,$1,[-2],$2 -rm[-1]
  -mv[-1] 0 -done -v+

r3dz :
  -resize3dz $*

#@gmic expand_x : 'size_x>=0,_borders={0,1,2}' : Expand image(s) along the X-axis.
expand_x : -int $1,${2=1}
  -if $1<0 -error "Invalid argument '$*' (should be 'size_x>=0,_borders={0,1,2}')." -endif
  -e "Expand image$? along the X-axis with size $1 and border conditions $2."
  -v- -t float -repeat @#
    -if $2==0 $1,100%,100%,100% -i[-3] [-1] -a[-3--1] x -else
    -if $2==1 --columns[-1] 0 --columns[-2] 100% -r[-2,-1] $1 -mv[-2] -3 -a[-3--1] x
    -else (@{-1,w}) -+[-1] $1 -+[-1] $1 -r[-2] @-1,[-2],[-2],[-2],0,2,1 -rm[-1]
    -endif -endif -endif
  -mv[-1] 0 -done -v+

#@gmic expand_y : 'size_y>=0,borders={0,1,2}' : Expand image(s) along the Y-axis.
expand_y : -int $1,${2=1}
  -if $1<0 -error "Invalid argument '$*' (should be 'size_y>=0,_borders={0,1,2}')." -endif
  -e "Expand image$? along the Y-axis with size $1 and border conditions $2."
  -v- -t float -repeat @#
    -if $2==0 100%,$1,100%,100% -i[-3] [-1] -a[-3--1] y -else
    -if $2==1 --lines[-1] 0 --lines[-2] 100% -r[-2,-1] 100%,$1 -mv[-2] -3 -a[-3--1] y
    -else (@{-1,h}) -+[-1] $1 -+[-1] $1 -r[-2] [-2],@-1,[-2],[-2],0,2,1 -rm[-1]
    -endif -endif -endif
  -mv[-1] 0 -done -v+

#@gmic expand_z : 'size_z>=0,borders={0,1,2}' : Expand image(s) along the Z-axis.
expand_z : -int $1,${2=1}
  -if $1<0 -error "Invalid argument '$*' (should be 'size_z'>=0,_borders={0,1,2}')." -endif
  -e "Expand image$? along the Z-axis with size $1 and border conditions $2."
  -v- -t float -repeat @#
    -if $2==0 100%,100%,$1,100% -i[-3] [-1] -a[-3--1] z -else
    -if $2==1 --slices[-1] 0 --slices[-2] 100% -r[-2,-1] 100%,100%,$1 -mv[-2] -3 -a[-3--1] z
    -else (@{-1,d}) -+[-1] $1 -+[-1] $1 -r[-2] [-2],[-2],@-1,[-2],0,2,1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic shrink_x : 'size_x>=0' : Shrink image(s) along the X-axis.
shrink_x : -int $1
  -if $1<0 -error "Invalid argument '$*' (should be 'size_x>=0')." -endif
  -e "Shrink image$? along the X-axis with size $1."
  -v- -t float -repeat @#
    (@{-1,w}) --[-1] $1 --[-1] 1 -crop[-2] $1,@-1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic shrink_y : 'size_y>=0' : Shrink image(s) along the Y-axis.
shrink_y : -int $1
  -if $1<0 -error "Invalid argument '$*' (should be 'size_y>=0')." -endif
  -e "Shrink image$? along the Y-axis with size $1."
  -v- -t float -repeat @#
    (@{-1,h}) --[-1] $1 --[-1] 1 -crop[-2] 0,$1,100%,@-1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic shrink_z : 'size_z>=0' : Shrink image(s) along the Z-axis.
shrink_z : -int $1
  -if $1<0 -error "Invalid argument '$*' (should be 'size_z>=0')." -endif
  -e "Shrink image$? along the Z-axis with size $1."
  -v- -t float -repeat @#
    (@{-1,d}) --[-1] $1 --[-1] 1 -crop[-2] 0,0,$1,100%,100%,@-1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic array : '_M>0,_N>0,_expand_type={0,1,2}' : Create MxN array from image(s).
array : -int ${1=3},${2=$1},${3=0}
  -if "$1<=0 || $2<=0 || $3<0 || $3>2" -error "Invalid argument '$*' (should be '_M>0,_N>0,_expand_type={0,1,2}')." -endif
  -e "Create $1x$2 array from image$?, with expand type $3."
  -v- -repeat @#
    -array_expand$3 $1,$2 [-1],$1 -rm[-1] -a[-$1--1] x [-1],$2 -rm[-1] -a[-$2--1] y
  -mv[-1] 0 -done -v+
array_expand0 :
  (100) ($1,$2) -/[-2] @{-1,M} -rm[-1] -r[-2] @-1%,@-1%,1,100%,2 -rm[-1]
array_expand1 :
  (100) ($1,$2) -/[-2] @{-1,m} -rm[-1] -r[-2] @-1%,@-1%,1,100%,2 -rm[-1]
array_expand2 :
  -skip $*

#@gmic array_fade : '_M>0,_N>0,0<=_fade_start<=100,0<=_fade_end<=100,_expand_type={0,1,2}' : Create MxN array from image(s).
array_fade : -int ${1=3},${2=$1},${5=1} -float ${3=60},${4=90}
  -if "$1<=0 || $2<=0 || $4<0 || $4>100 || $5<0 || $5>2"
    -error "Invalid argument '$*' (should be '_M>0,_N>0,0<=_fade_start<=100,0<=_fade_end<=100,_expand_type={0,1,2}')." -endif
  -e "Create $1x$2 array of ($3%,$4%) faded tiles from image$?, with expand type $5."
  -v- -repeat @#
    --translate[-1] 50%,50%,1,1,2 -mv[-1] -2 -fade_diamond[-2,-1] $3,$4 -array[-1] $1,$2,$5
  -mv[-1] 0 -done -v+

#@gmic array_mirror : '_N>=0,_dir={0,1,2},_expand_type={0,1}' : Create 2^Nx2^N array from image(s).
array_mirror : -int ${1=2},${2=2},${3=0}
  -if "$1<0 || $2<0 || $2>2" -error "Invalid argument '$*' (should be '_N>=0,_dir={0,1,2},_expand_type={0,1}')." -endif
  -e "Create a 2^$1x2^$1 mirrored-array from image$?, with expand type $2."
  -v- -repeat $1
    -if $3==0 -r 50%,50%,100%,100%,2 -endif
    -repeat @#
      -if $2==0 --mirror[-1] x -a[-2,-1] x -else
      -if $2==1 --mirror[-1] y -a[-2,-1] y -else
                --mirror[-1] x -a[-2,-1] x --mirror[-1] y -a[-2,-1] y
      -endif -endif
    -mv[-1] 0 -done
  -done -v+

#@gmic array_random : '_Ms>0,_Ns>0,_Md>0,_Nd>0' : Create MdxNd array of tiles from MsxNs source array(s).
array_random : -int ${1=5},${2=$1},${3=$1},${4=$2}
  -if "$1<=0 || $2<=0 || $3<=0 || $4<=0" -error "Invalid argument '$*' (should be '_Ms>0,_Ns>0,_Md>0,_Nd>0')." -endif
  -e "Create $3x$4 array of tiles from $1x$2 array$?."
  -v- -repeat @#
    -l[-1] -split_tiles $1,$2 ($1) -*[-1] $2
    -repeat $3 -repeat $4 (@?) -*[-1] @-2 -round[-1] 1 -i[-3] [@-1] -rm[-1] -done -done
    --[-1] 1 -rm[0-@-1] -rm[-1] -append_tiles $3,$4
  -endl -mv[-1] 0 -done -v+

#@gmic taquin : '_M>0,_N>0' : Create MxN taquin puzzle from image(s).
taquin : -int ${1=4},${2=$1}
 -if "$1<=0 || $2<=0" -error "Invalid argument '$*' (should be '_M>0,_N>0')." -endif
 -e "Create $1x$2 taquin puzzle from image $?."
 -v- -repeat @# -l[-1]
   -split_tiles $1,$2,1 -repeat $1*$2 -mv[@{>,-1}] @{?,0,@#} -done -append_tiles $1,$2
 -endl -mv[-1] 0 -done -v+

#@gmic grid : '_M>0,_N>0' : Create MxN image grid from image(s).
grid : -int ${1=10},${2=$1}
  -if "$1<=0 || $2<=0" -error "Invalid argument '$*' (should be '_M>0,_N>0')." -endif
  -e "Create $1x$2 image grid from image$?."
  -v- -repeat @#
    (@{-1,w},@{-1,h}) ($1,$2) -/[-2,-1] -r[-2] @-1,[-2],[-2],2 -rm[-1]
    (@{-1,w},@{-1,h}) ($1,$2) -*[-2,-1] -r[-2] @-1,[-2],[-2],2 -rm[-1]
    $1,$2,1,[-1],1 -translate[-1] 1,1 -r[-1] [-2],0,2 -*[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic frame : '_size_x>=0,_size_y>=0,_R,_G,_B,_A' : Insert RGBA-colored frame in image(s).
frame : -int ${1=20},${2=$1} -float ${3=255},${4=$3},${5=$4},${6=255}
  -if "$1<0 || $2<0" -error "Invalid argument '$*' (should be '_size_x>=0,_size_y>=0,_R,_G,_B,_A')." -endif
  -e "Insert $1x$2 frame with RGBA color ($3,$4,$5,$6) in image$?."
  -v- -to_rgba -repeat @#
    ($3^$4^$5^$6) -r[-1] $1,[-2],[-2],[-2],1 -i[-3] [-1] -a[-3--1] x
    ($3^$4^$5^$6) -r[-1] [-2],$2,[-2],[-2],1 -i[-3] [-1] -a[-3--1] y
  -mv[-1] 0 -done -v+

#@gmic frame_fuzzy : '_size_x>=0,_size_y>=0,_fuzzyness>=0,_smoothness>=0,_R,_G,_B,_A' : Draw RGBA-colored fuzzy frame in image(s).
frame_fuzzy : -int ${1=20},${2=$1} -float ${3=5},${4=1},${5=255},${6=$5},${7=$6},${8=255}
  -if "$1<0 || $2<0 || $3<0 || $4<0" -error "Invalid argument '$*' (should be '_size_x>=0,_size_y>=0,_fuzzyness>=0,_smoothness>=0,_R,_G,_B,_A')." -endif
  -e "Draw $1x$2 fuzzy frame on image$?, with fuzzyness $3, smoothness $4 and RGBA color ($5,$6,$7,$8)."
  -v- -to_rgba -repeat @#
    -i[0] ($1;$2) -*[0] 2 ($5^$6^$7^$8) -r[-1] [-2] 100%,100%
    -polygon[-1] 4,0,0,100%,0,100%,@{0,1},0,@{0,1},1,1
    -polygon[-1] 4,0,0,@{0,0},0,@{0,0},100%,0,100%,1,1
    -rm[0] -translate[-1] -$1,-$2,0,0,2 -spread[-1] $3 -blur[-1] $4 -_fade 50,80
  -mv[-1] 0 -done -v+

#@gmic frame_round : '_roundness>0,_size>=0,_smoothness,_R,_G,_B,_A' : Draw RGBA-colored round frame in image(s).
frame_round : -float ${1=3},${2=50},${3=0},${4=255},${5=$4},${6=$5},${7=255}
  -if "$1<=0 || $2<0" -error "Invalid argument '$*' (should be '_roundness>0,_size>=0,_smoothness,_R,_G,_B,_A')." -endif
  -e "Draw round frame on image$?, with roundness $1, size $2, smoothness $3 and RGBA color ($4,$5,$6,$7)."
  -v- -to_rgba -repeat @#
    100%,100%,1,1,"-(abs(x/w-0.5)^$1+abs(y/h-0.5)^$1)" -threshold[-1] $2%
    -blur[-1] $3 -r[-1] [-2] -*[-2] [-1] -channels[-1] 0 -*[-1] -1 -+[-1] 1
    --*[-1] $5 --*[-2] $6 --*[-3] $7 -*[-4] $4 -a[-4--1] v -+
  -mv[-1] 0 -done -v+

#@gmic polaroid : '_W1>=0,_W2>=0,_W3>=0' : Create polaroid effect in image(s).
polaroid : -int ${1=30},${2=120},${3=40}
  -if "$1<0 || $2<0 || $3<0" -error "Invalid argument '$*' (should be '_W1>=0,_W2>=0,_W3>=0')." -endif
  -e "Create polaroid effect in image$?, with borders sizes $1, $2 and $3."
  -v- -repeat @#
    -frame[-1] $1,$1,255,255,255 [-1],$2,1,3,255 -a[-2,-1] y
    (@{-1,w},@{-1,h}) -+[-1] $3 -+[-1] $3 --f[-2] -1 -r[-1] @-2,1,3,0,0,1 -rm[-2]
    -blur[-1] 5 -r[-2] [-1],0,0,1 -n[-1] 0,180 -or[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic drop_shadow : '_offset_x,_offset_y,_smoothness,_expansion>=100' : Drop shadow behind image(s).
drop_shadow : -int ${1=-10},${2=$1} -float ${3=10},${4=120}
  -if $4<100 -error "Invalid argument '$*' (should be '_offset_x,_offset_y,_smoothness>=0,_expansion>=100')." -endif
  -e "Drop shadow behind image$?, with offsets ($1,$2), smoothness $3 and expansion $4."
  -v- -repeat @#
    --f[-1] -255 -r[-2,-1] $4%,$4%,1,100%,0,0,1 -+[-1] 255 --blur[-1] $3 -translate[-3,-2] $1,$2,0,0,1
    -*[-2,-1] -n[-1] 0,255 -+[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic split_tiles : 'M!=0,_N!=0,_homogeneous_size={0,1}' : Split image(s) as a MxN array of (homogeneous or not) tiles.
split_tiles : -int $1,${2=$1},${3=0}
  -if "$1==0 || $2==0" -error "Invalid argument '$*' (should be 'M!=0,_N!=0,_homogeneous_size={0,1}')." -endif
  -if $3 -e "Split image$? as a array of homogeneous tiles, with (M,N) = ($1,$2)."
  -else -e "Split image$? as a array of tiles, with (M,N) = ($1,$2)." -endif -v-
  -repeat @#
    -l[-1] -s y,$2 -s x,$1 -if $3 -r [0],[0],100%,100%,0 -endif -endl
  -mv[{-$1*$2}--1] 0 -done -v+

#@gmic append_tiles : 'M>0,_N>0' : Append MxN tiles as new image(s).
append_tiles : -int $1,${2=$1}
  -if "$1<=0 || $2<=0" -error "Invalid argument '$*' (should be 'M>0,_N>0')." -endif
  -e "Append $1x$2 tile$? as new image(s)."
  -v- -repeat @#/($1*$2) -l[{-$1*$2}--1]
    -repeat $2 -a[-$1--1] x -mv[-1] 0 -done -a y
  -endl -mv[-1] 0 -done -v+

#@gmic rotate_tiles : '_angle,_M>0,N>0' : Apply MxN tiled-rotation effect on image(s).
rotate_tiles : -float ${1=5} -int ${2=8},${3=$2}
  -if "$2<=0 || $3<=0" -error "Invalid argument '$*' (should be '_angle,_M>0,_N>0')." -endif
  -e "Apply $2x$3 tiled-rotation effect on image$?, with angle $1."
  -v- -split_tiles $2,$3,1 -rotate $1 -append_tiles $2,$3 -v+

#@gmic shift_tiles : '_M>0,_N>0,_amplitude' : Apply MxN tiled-shift effect on image(s).
shift_tiles : -int ${1=8},${2=8} -float ${3=20}
  -if "$1<=0 || $2<=0" -error "Invalid argument '$*' (should be '_M>0,_N>0,_amplitude')." -endif
  -e "Apply $1x$2 tiled-shift effect on image$?, with amplitude $3."
  -v- -t float -repeat @#
    $1,$2,1,2 -noise[-1] $3 -r[-1] [-2],[-2],1,2 -warp[-2] [-1],1,1,0 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic rgb2bayer : '_start_pattern=0,_color=0' : Transform color image(s) to RGB-Bayer sampling grid.
rgb2bayer : -skip ${1=0},${2=0}
  -if $2 -e "Transform image$? to a RGB-Bayer color grid, starting from pattern '$1'."
  -else -e "Transform image$? to a RGB-Bayer monochrome grid, starting from pattern '$1'." -endif
  -v- -to_rgb -repeat @#
    -rgb2bayer_$1 -r[-1] [-2],0,2 -*[-2,-1]
    -if $2 -else -s[-1] v -+[-3--1] -endif
  -mv[-1] 0 -done -v+

rgb2bayer_0 : (1,0;0,0^0,1;1,0^0,0;0,1)
rgb2bayer_1 : (0,0;0,1^0,1;1,0^1,0;0,0)
rgb2bayer_2 : (0,0;1,0^1,0;0,1^0,1;0,0)
rgb2bayer_3 : (0,1;0,0^1,0;0,1^0,0;1,0)

#@gmic warp_perspective : '_x-angle,_y-angle,_zoom>0,_x-center,_y-center,_borders={0,1,2}' : Warp image(s) with perspective deformation.
warp_perspective : -float ${1=1.5},${2=0},${3=1},${4=50},${5=50},${6=2}
  -if "$3<=0 || $6<0 || $6>2" -error "Invalid argument '$*' (should be '_x-angle,_y-angle,_zoom>0,_x-offset,_y-offset,_borders={0,1,2}')." -endif
  -e "Apply perspective warp on image$?, with angles ($1,$2), zoom $3 and offsets ($4,$5)."
  -v- -t float -repeat @#
    (0,100) --[-1] $4 -/[-1] 100 (0;100) --[-1] $5 -/[-1] 100 -r[-2,-1] [-3],[-3],[-3],1,3
    --*[-2] $2 --*[-2] $1 -+[-2,-1] -+[-1] $3 -/[-3] [-1] -/[-2,-1]
    -*[-2] 100 -+[-2] $4 -/[-2] 100 -*[-2] @{-3,w}
    -*[-1] 100 -+[-1] $5 -/[-1] 100 -*[-1] @{-3,h}
    -a[-2,-1] v -warp[-2] [-1],0,1,$6 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic array_pattern : '_M>0,_N>0,_density>=0,_angle>=0,_zoom>=0,_opacity,_expand_type={0,1,2}' : Create random MxN array from image(s).
array_pattern : -int ${1=10},${2=10},${7=0} -float ${3=80},${4=180},${5=30},${6=1}
  -if "$1<=0 || $2<=0 || $3<0 || $4<0 || $5<0 || $7<0 || $7>2"
    -error "Invalid argument '$*' (should be '_size_x>0,_size_y>0,_density>=0,_angle>=0,_zoom>=0')." -endif
  -e "Create $1x$2 pattern array from image$?, with density $3, angle $4, zoom $5, opacity $6 and expand type $7."
  -v- -repeat @#
    -array_expand$7 $1,$2 -set[-1] 0,0,0,0,3
    --crop[-1] 0,0,0,0,0,0,0,100% ($1,$2) (@{-3,w},@{-3,h}) -*[-2,-1] -r[-2] @-1,1,100% -rm[-1]
    $1,$2,1,1,-1 -noise[-1] $3,2 -threshold[-1] 0 -unroll[-1] y
    -repeat $1 -repeat $2
      -if @{-1,0}
        (@{?,-$5,$5}) -+[-1] 100 --r[-4] @-1%,@-1%,1,100%,3 -rm[-2] --f[-1] 1
        (@{>,-2--1}) (@{-6,w},@{-6,h}) -*[-2,-1]
        (@{?,-$4,$4}) -rotate[-4] @-1,1,2 -rotate[-3] @-1,0,0 -rm[-1]
        -image[-5] [-3],@{-1},0,$6,[-2] -rm[-3--1]
      -endif
    -translate[-1] 0,-1 -done -done -rm[-3,-1]
  -mv[-1] 0 -done -v+

#------------------------------------
#
# Deformation and smoothing filters
#
#------------------------------------

#@gmic spread : '_dx>=0,_dy>=0,_dz>=0' : Spread pixel values of image(s) randomly along x,y and z.
spread : -float ${1=3},${2=$1},${3=0}
  -if "$1<0 || $2<0 || $3<0" -error "Invalid argument '$*' (should be '_dx>=0,_dy>=0,_dz>=0')." -endif
  -e "Spread pixel of image$? randomly, with amplitudes ($1,$2,$3)."
  -v- -t float -repeat @#
    100%,100%,100%,1 [-1],2 -noise[-3] $1,0 -noise[-2] $2,0 -noise[-1] $3,0 -a[-3--1] v -warp[-2] [-1],1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic euclidean2polar : '_cx,_cx,_n>0,_borders={0,1,2}' : Apply euclidean to polar transform on image(s).
euclidean2polar : -float ${1=0.5},${2=0.5},${3=1} -int ${4=1}
  -if "$3<=0 || $4<0 || $4>2" -error "Invalid argument '$*' (should be '_cx,_cy,_n>0,_borders={0,1,2}')." -endif
  -e "Apply euclidean to polar transform on image$?."
  -v- -t float -repeat @#
    (@{-1,w},@{-1,h}) ($1,$2) -*[-2,-1] ({sqrt(max(@{-1,0},@{-2,w}-@{-1,0})^2+max(@{-1,1},@{-2,h}-@{-1,1})^2)})
    -a[-2,-1] x
    [-2],[-2],1,1,'@{-1,2}*(x/w)^$3*cos(y*2*pi/h)' -+[-1] @{-2,0}
    [-1],[-1],1,1,'@{-2,2}*(x/w)^$3*sin(y*2*pi/h)' -+[-1] @{-3,1}
    -rm[-3] -a[-2,-1] v -warp[-2] [-1],0,1,$4 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic polar2euclidean : '_cx,_cy,_n>0,_borders={0,1,2}' : Apply polar to euclidean transform on image(s).
polar2euclidean : -float ${1=0.5},${2=0.5},${3=1} -int ${4=1}
  -if "$3<=0 || $4<0 || $4>2" -error "Invalid argument '$*' (should be '_cx,_cy,_n>0,_borders={0,1,2}')." -endif
  -e "Apply polar to euclidean transform on image$?."
  -v- -t float -repeat @#
    (@{-1,w},@{-1,h}) ($1,$2) -*[-2,-1] ({sqrt(max(@{-1,0},@{-2,w}-@{-1,0})^2+max(@{-1,1},@{-2,h}-@{-1,1})^2)})
    -a[-2,-1] x
    [-2],[-2],1,1,'w*(sqrt((x-@{-1,0})^2+(y-@{-1,1})^2)/@{-1,2})^(1/$3)'
    [-1],[-1],1,1,'(atan2(y-@{-2,1},x-@{-2,0})*h/(2*pi)+h)%h'
    -rm[-3] -a[-2,-1] v -warp[-2] [-1],0,1,$4 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic water : '_amplitude>=0,_smoothness>=0' : Apply water deformation on image(s).
water : -float ${1=30},${2=1.5}
  -if "$1<0 || $2<0" -error "Invalid argument '$*' (should be '_amplitude>=0,_smoothness>=0')." -endif
  -e "Apply water deformation on image$?, with amplitude $1 and smoothness $2."
  -v- -t float -repeat @#
    25%,25%,25%,1 -noise[-1] $1 -gradient[-1] xyz -+[-1,-2,-3] -blur[-1] $2 -*[-1] 2 -r[-1] [-2],[-2],1,2,3 -warp[-2] [-1],1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic wave : '_amplitude>=0,_frequency>=0,_center_x,_center_y' : Apply wave deformation on image(s).
wave : -float ${1=4},${2=0.4},${3=50},${4=50}
  -if "$1<0 || $2<0" -error "Invalid argument '$*' (should be '_amplitude>=0,_frequency>=0,_center_x,_center_y')." -endif
  -e "Apply wave deformation on image$?, with amplitude $1, frequency $2 and center at ($3%,$4%)."
  -v- -t float -repeat @#
    100%,100% -=[-1] 1,$3%,$4% -distance[-1] 1
    -*[-1] $2 --sin[-1] -cos[-2] -a[-2,-1] v -*[-1] $1
    -warp[-2] [-1],1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic : twirl : '_amplitude,_cx,_cy,_borders={0,1,2}' : Apply twirl deformation on image(s).
twirl : -float ${1=1},${2=0.5},${3=0.5} -int ${4=1}
  -if "$4<0 || $4>2" -error "Invalid argument '$*' (should be '_amplitude,_cx,_cy,_borders={0,1,2}')." -endif
  -e "Apply twirl deformation on image$?, with amplitude $1 and center at ($2%,$3%)."
  -v- -t float -repeat @#
    -euclidean2polar[-1] $2,$3,1,$4 100%,100%,1,1,{$1*x} -channels[-1] -1,0
    -warp[-2] [-1],1,1,2 -rm[-1] -polar2euclidean[-1] $2,$3,1,1
  -mv[-1] 0 -done -v+

#@gmic : flower : '_amplitude,_frequency,_offset_r[%],_angle,_cx,_cy,_borders={0,1,2}' : Apply flower deformation on image(s).
flower : -float ${1=30},${2=6},${4=0},${5=0.5},${6=0.5} -skip ${3=0} -int ${7=2}
  -if "$7<0 || $7>2" -error "Invalid argument '$*' (should be '_amplitude,_frequency,_offset_r,_offset_a,_cx,_cy,_borders={0,1,2}')." -endif
  -e "Apply flower deformation on image$?, with amplitude $1, frequency $2, offset $3, angle $4 and center ($1,$2)."
  -v- -t float -repeat @#
    -euclidean2polar[-1] $5,$6,1,$7 -translate[-1] $3,0,0,0,2
    100%,100%,1,1,{y} -/[-1] @{-1,h} -*[-1] $2 ({$4/360}) -+[-2] @-1 -rm[-1] -*[-1] 6.2831853 -sin[-1]
    -*[-1] $1 -*[-1] @{-1,w} -/[-1] 100
    -channels[-1] 0,1 -warp[-2] [-1],1,1,$7 -rm[-1]
    -polar2euclidean[-1] $5,$6,1,1
  -mv[-1] 0 -done -v+

#@gmic blur_x : '_amplitude,_borders={0,1}' : Blur image(s) along the X-axis.
blur_x : -float ${1=10} -int ${2=1}
  -_blur_n $1,$2,X,y,z

#@gmic blur_y : '_amplitude,_borders={0,1}' : Blur image(s) along the Y-axis.
blur_y : -float ${1=10} -int ${2=1}
  -_blur_n $1,$2,Y,x,z

#@gmic blur_z : '_amplitude,_borders={0,1}' : Blur image(s) along the Z-axis.
blur_z : -float ${1=10} -int ${2=1}
  -_blur_n $1,$2,Z,x,y

_blur_n :
  -e "Blur image$? along the $3-axis, with amplitude $1 and border conditions $2."
  -v- -repeat @#
    -l[-1] -s $5 -repeat @#
      -l[-1] -s $4 -blur $1,$2 -a $4 -endl
    -mv[-1] 0 -done -a $5 -endl
  -mv[-1] 0 -done -v+

#@gmic blur_angular : '_amplitude,_cx,_cy' : Apply angular blur on image(s).
blur_angular : -float ${1=10},${2=0.5},${3=0.5}
  -e "Apply angular blur on image$?, with amplitude $1 and center ($2,$3)."
  -v- -t float -euclidean2polar $2,$3,1.3,1 -expand_y 16,2 -blur_y $1 -shrink_y 16 -polar2euclidean $2,$3,1.3,1 -v+

#@gmic blur_radial : '_amplitude,_cx,_cy' : Apply radial blur on image(s).
blur_radial : -float ${1=0.1},${2=0.5},${3=0.5}
  -e "Apply radial blur on image$?, with amplitude $1 and center ($2,$3)."
  -v- -t float -euclidean2polar $2,$3,5,1 -blur_x $1 -polar2euclidean $2,$3,5,1 -v+

#@gmic blur_linear : '_amplitude1,_amplitude2,_angle=0,_borders={0,1}' : Apply linear blur on image(s), with specified angle and amplitudes.
blur_linear : -float ${1=0.2},${2=0.02},${3=0} -int ${4=1}
  -e "Apply linear blur on image$?, with angle $3 and amplitudes ($1,$2)."
  -v- -t float -repeat @#
    -if $4==1 -expand_x[-1] 16 -expand_y[-1] 16 -else -frame 16,16,0 -endif
    ($3,$3) -+[-1] 90 -=[-1] $3,1 -/[-1] 180 -*[-1] 3.14159265359 -sin[-1]
    (-1,1) (-1;1) -r[-2,-1] [-4],[-4],[-4],1,3
    --*[-1] @{-3,0} --*[-3] @{-4,1} --[-2,-1] -/[-1] $2 -sqr[-1]
    -*[-3] @{-4,0} -*[-2] @{-4,1} -+[-3,-2] -/[-2] $1 -sqr[-2]
    -+[-2,-1] -*[-1] -1 -exp[-1] -normalize_sum[-1] -rm[-2]
    -convolve_fft[-2,-1] -shrink_x[-1] 16 -shrink_y[-1] 16
  -mv[-1] 0 -done -v+

#@gmic pde_flow : '_nb_iter>=0,_dt,_velocity_macro,_sequence_flag={0,1}' : Apply iterations of a generic PDE flow on image(s).
pde_flow : -int ${1=10},${4=0} -float ${2=30} -skip ${3=laplacian}
  -if $1<0 -error "Invalid argument '$*' (should be '_nb_iter>=0,_dt,_velocity_macro,_sequence_flag={0,1}')." -endif
  -e "Apply $1 iterations of the velocity flow '$3' on image$?, with time step $2."
  -v- -t float -repeat @# -l[-1] -repeat $1
    --$3[-1] (@{-1,m},@{-1,M}) -abs[-1] -+[-1] 0.01 -/[-2] @{-1,M} -rm[-1] -*[-1] $2
    -if $4 -+[-1] [-2] -else -+[-2,-1] -endif
  -done -if $4 -rm[0] -endif -a x -endl
  -mv[-1] 0 -done -if $4 -s x,$1 -endif -v+

#@gmic heat_flow : '_nb_iter>=0,_dt,_sequence_flag={0,1}' : Apply iterations of the heat flow on image(s).
heat_flow : -int ${1=10},${3=0} -float ${2=30}
  -if $1<0 -error "Invalid argument '$*' (should be '_nb_iter>=0,_dt,_sequence_flag={0,1}')." -endif
  -e "Apply $1 iterations of the heat flow on image$?, with time step $2."
  -v- -pde_flow $1,$2,laplacian,$3 -v+

#@gmic meancurvature_flow : '_nb_iter>=0,_dt,_sequence_flag={0,1}' : Apply iterations of the mean curvature flow on image(s).
meancurvature_flow : -int ${1=5},${3=0} -float ${2=30}
  -if $1<0 -error "Invalid argument '$*' (should be '_nb_iter>=0,_dt,_sequence_flag={0,1}')." -endif
  -e "Apply $1 iterations of the mean curvature flow on image$?, with time step $2."
  -v- -pde_flow $1,$2,meancurvature_flow_velocity,$3 -v+
meancurvature_flow_velocity :
  --gradient_2derivative[-1] -laplacian[-2] --[-2,-1]

#@gmic tv_flow : '_nb_iter>=0,_dt,_sequence_flag={0,1}' : Apply iterations of the total variation flow on image(s).
tv_flow : -int ${1=5},${3=0} -float ${2=30}
  -if $1<0 -error "Invalid argument '$*' (should be '_nb_iter>=0,_dt,_sequence_flag={0,1}')." -endif
  -e "Apply $1 iterations of the total variation flow on image$?, with time step $2."
  -v- -pde_flow $1,$2,tv_flow_velocity,$3 -v+
tv_flow_velocity :
  --gradient[-1] xyz -sqr[-3--1] -+[-3--1] -sqrt[-1] -+[-1] 0.1 -meancurvature_flow_velocity[-2] -/[-2,-1]

#@gmic inpaint_flow : '_nb_iter1>=0,_nb_iter2>=0,_dt>=0,_alpha,_sigma' : Apply iteration of the inpainting flow on image(s).
inpaint_flow : -int ${1=4},${2=15} -float ${3=15},${4=1},${5=3}
  -if "$1<0 || $2<0 || $3<0" -error "Invalid argument '$*' (should be '_nb_iter1>=0,_nb_iter2>=0,_dt>=0,_alpha,_sigma')." -endif
  -e "Apply $1 iteration of the inpainting flow on image$?."
  -v- -norm[0] -quantize[0] 2 -n[0] 0,1 -repeat @# -if @{>,-1} -l[0,@{>,-1}]
  -r[0] [1] -inpaint[1] [0]
  -repeat $1
     --edgetensors[1] 0,1,$4,$5,0 -*[2] [0] -smooth[1] [2],$2,$3,0 -rm[2]
  -done
  -endl -endif -done -v+

#@gmic noise_hurl : '_amplitude>=0' : Add hurl noise to image(s).
noise_hurl : -float ${1=10}
  -if $1<0 -error "Invalid argument '$*' (should be '_amplitude>=0')." -endif
  -e "Add hurl noise to image$?, with amplitude $1%."
  -v- -t float -repeat @#
    --f[-1] 0 -noise[-1] 10 -n[-1] @{-2,m,M} 100%,100%,1,1,-2
    -noise[-1] $1,2 -threshold[-1] 0 -r[-1] [-2]
    -*[-2] [-1] -*[-1] -1 -+[-1] 1 -*[-3,-1] -+[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic pixelize : '_scale_x>0,_scale_y>0,_scale_z>0' : Pixelize image(s) with specified scales.
pixelize : -float ${1=20},${2=$1},${3=$1}
  -if "$1<=0 || $2<=0 || $3<=0" -error "Invalid argument '$*' (should be '_scale_x>0,_scale_y>0,_scale_z>0')." -endif
  -e "Pixelize image$? with scales ($1%,$2%,$3%)."
  -v- -repeat @#
    (@{-1,w},@{-1,h},@{-1,d}) -r[-2] $1%,$2%,$3%,[-2],2 -r[-2] @-1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic deform : '_amplitude>=0' : Apply random smooth deformation on image(s).
deform : -float ${1=10}
  -if $1<0 -error "Invalid argument '$*' (should be '_amplitude>=0')." -endif
  -e "Apply random smooth deformation on image$?, with amplitude $1."
  -v- -t float -repeat @#
    2%,2%,1,2 -noise[-1] $1 -r[-1] [-2],[-2],1,2,5 -warp[-2] [-1],1,1,1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic puzzle : '_scale>=0' : Apply puzzle effect on image(s).
puzzle : -float ${1=5}
  -if $1<0 -error "Invalid argument '$*' (should be '_scale>=0')." -endif
  -e "Apply puzzle effect on image$?, with scale $1%."
  -v- -t float -repeat @#
    [-1] -r[-1] $1%,$1%,100%,100%,2 -noise[-1] 0.1 -r[-1] [-2] -rm[-2]
    [-1],2 -translate[-1] -1,-1 --[-2,-1] -norm[-1] -threshold[-1] 0.01 -*[-1] -1
    -+[-1] 1 -r[-1] [-2] -*[-1,-2] 10%,10%,10%,2 -noise[-1] 5,1
    -r[-1] [-2],[-2],1,2,5 -warp[-2] [-1],1,1,1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic fish_eye : '_amplitude>=0' : Apply Fish-eye effect on image(s).
fish_eye : -float ${1=70}
  -if $1<0 -error "Invalid argument '$*' (should be '_amplitude>=0')." -endif
  -e "Apply Fish-eye effect on image$?, with amplitude $1."
  -v- -t float -repeat @#
    (-1,1;-1,1^-1,-1;1,1) -r[-1] [-2],[-2],1,2,3 [-1]
    -norm[-2] -n[-2] 0,1 -cut[-2] 0,0.7 --[-2] 0.7 -*[-2] -$1 (@{-3,w}) -+[-1] @{-4,h} -/[-1] 2 -*[-2] @-1 -rm[-1] -/[-1] 100
    -r[-2] [-1]
    -*[-2,-1] -warp[-2] [-1],1,1,1 -rm[-1]
  -mv[-1] 0 -done -v+

#-----------------------------
#
# Artistic filters
#
#-----------------------------

#@gmic shade_stripes : '_frequency>=0,_direction={0,1},_darkness>=0,_lightness>=0' : Add shade stripes to image(s).
shade_stripes : -float ${1=5},${3=0.8},${4=2} -int ${2=1}
  -if "$1<0 || $3<0 || $4<0" -error "Invalid argument '$*' (should be '_frequency>=0,_direction={0,1},_darkness>=0,_lightness>=0')." -endif
  -v- -t float -repeat @#
    -n[-1] 0,255
    -if $2 -v+ -e "Add vertical shaded stripes to image$?, with frequency $1, darkness $3 and lightness $4." -v- 100%
    -else -v+ -e "Add horizontal shaded stripes to image$?, with frequency $1, darkness $3 and lightness $4." -v- 1,100%
    -endif
    -noise[-1] $1,2 -distance[-1] 1
    -r[-1] [-2] -n[-1] $3,$4 -*[-1,-2] -cut[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic stripes_y : '_frequency>=0' : Add vertical stripes to image(s).
stripes_y : -float ${1=10}
  -if $1<0 -error "Invalid argument '$*' (should be '_frequency>=0')." -endif
  -e "Add vertical stripes to image$?, with frequency $1."
  -v- -t float -repeat @#
    -n[-1] 0,255 100% -noise[-1] $1,2 -*[-1] 255 -r[-1] [-2]
    -*[-1] 0.15 -+[-1,-2] -cut[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic tetris : '_scale>0' : Apply tetris effect(s) on image(s).
tetris : -float ${1=10}
  -if $1<=0 -error "Invalid argument '$*' (should be '_scale>0')." -endif
  -e "Apply tetris effect on image$?, with scale $1."
  -v- -t float -repeat @#
    --r[-1] $1%,$1%,$1%,3,2 -n[-1] 0,255 -quantize[-1] 10
    -r[-1] [-2] -rm[-2] -blur[-1] 2 -sharpen[-1] 300,1
  -mv[-1] 0 -done -v+

#@gmic damp_patch : '_opacity>=0' : Add damp patches to image(s).
damp_patch : -float ${1=0.7}
  -if $1<0 -error "Invalid argument '$*' (should be '_opacity>=0')." -endif
  -e "Apply damp patches to image$?, with opacity $1."
  -v- -t float -repeat @#
    100%,100%,1,1 -translate[-1] -2,-2 -translate[-1] 1,1
    -plasma[-1] 3,0.3 -abs[-1] -blur[-1] 1 -cut[-1] 3%,15% -r[-1] [-2]
    -n[-1] $1,1 -*[-1,-2]
  -mv[-1] 0 -done -v+

#@gmic light_patch : '_density>0,_darkness>=0,_lightness>=0' : Add light patches to image(s).
light_patch : -int ${1=10} -float ${2=0.9},${3=1.7}
  -if "$1<=0 || $2<0 || $3<0" -error "Invalid argument '$*' (should be '_density>0,_darkness>=0,_lightness>=0')." -endif
  -e "Apply light patches to image$?, with density $1, darkness $2 and lightness $3."
  -v- -t float -repeat @#
    -n[-1] 0,255 $1,$1 -noise[-1] 40 -r[-1] [-2],5 -cut[-1] 0,255
    -n[-1] $2,$3 -*[-2,-1] -cut[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic kaleidoscope : '_cx,_cy,_radius,_angle,_borders={0,1,2}' : Create kaleidoscope effect from image(s).
kaleidoscope : -float ${1=0.5},${2=0.5},${3=100},${4=30} -int ${5=1}
  -e "Create kaleidoscope effect from image$?, with center ($1,$2) radius $3, angle $4."
  -v- -euclidean2polar $1,$2,1,$5 -repeat @#
    --columns[-1] 0,$3% -lines[-1] 0,$4% -r[-1] [-2],0,2 -rm[-2]
  -mv[-1] 0 -done -polar2euclidean $1,$2,1,$5 -v+

#@gmic mosaic : '_density>=0' : Add random mosaic pattern to image(s).
mosaic : -float ${1=0.2}
  -if $1<0 -error "Invalid argument '$*' (should be '_density>=0')." -endif
  -e "Add random mosaic pattern to image$?, with density $1."
  -v- -t float -repeat @#
    100%,100%,1,1 -noise[-1] $1,2 -distance[-1] 1
    -sharpen[-1] 10000 -*[-1] -1 -blur[-1] 0.5 -n[-1] 0.3,1 -r[-1] [-2] -*[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic sponge : '_size>0' : Apply sponge effect on image(s).
sponge : -int ${1=13}
  -if $1<=0 -error "Invalid argument '$*' (should be '_size>0')." -endif
  -e "Apply sponge filter on image$?, with brush size $1."
  -v- -repeat @#
    100%,100%,1,1 -noise[-1] 20,2 -r[-1] [-2] -n[-1] 0,1 -*[-1,-2]
    -_circle $1 -dilate[-2] [-1] -rm[-1]
  -mv[-1] 0 -done -v+
_circle :
  -i 1 -+[-1] 1 -r[-1] $1,$1,1,1,0,0,1 -distance[-1] 1 -n[-1] 0,1 -sqrt[-1] -cut[-1] 0.85,0.86 -*[-1] -1 -n[-1] 0,1

#@gmic hearts : '_density>=0' : Apply heart effect on image(s).
hearts : -float ${1=10}
  -if $1<0 -error "Invalid argument '$*' (should be '_density>=0')." -endif
  -e "Apply heart filter on image$?, with density $1."
  -v- -repeat @#
    100%,100%,1 -noise[-1] $1,2 -r[-1] [-2] -n[-1] 0,1 -*[-1,-2] -_heart9x7
    -mirror[-1] y -dilate[-2] [-1] -rm[-1]
  -mv[-1] 0 -done -v+
_heart9x7 :
  (0,1,1,0,0,0,1,1,0;1,1,1,1,0,1,1,1,1;1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,0;0,0,1,1,1,1,1,0,0;0,0,0,1,1,1,0,0,0;0,0,0,0,1,0,0,0,0)
_heart80x73 :
  40,73,1,1,0 -ellipse 22,22,20,20,0,1,1 -polygon 3,7,37,42,72,42,27,1,1 --mirror x -a x

#@gmic color_ellipses : '_count>0,_radius>=0,_opacity>=0' : Add random color ellipses to image(s).
color_ellipses : -int ${1=1400} -float ${2=10},${3=0.1}
  -if "$1<0 || $2<0 || $3<0" -error "Invalid argument '$*' (should be '_count>0,_radius>=0,_opacity>=0')." -endif
  -e "Add $1 random color ellipses to image$?, with maximum radius $2 and opacity $1."
  -v- -repeat @#
    -repeat $1 -ellipse[-1] @{?,0,100}%,@{?,0,100}%,@{?,0,$2}%,@{?,0,$2}%,@{?,0,360},$3,@{?,60,255,3,1} -done
  -mv[-1] 0 -done -v+

#@gmic whirls : '_texture>=0,_smoothness>=0,_darkness>=0,_lightness>=0' : Add random whirl texture to image(s).
whirls : -int ${1=3} -float ${2=6},${3=0.5},${4=1.8}
  -if "$1<0 || $2<0 || $3<0 || $4<0" -error "Invalid argument '$*' (should be '_texture>=0,_smoothness>=0,_darkness>=0,_lightness>=0')." -endif
  -e "Add random whirl texture to image$?, with texture $1, smoothness $2, darkness $3 and lightness $4."
  -v- -t float -repeat @#
    100%,100% -noise[-1] 0.3,2 -repeat $1 -blur[-1] $2 -gradient_norm[-1] -done
    -n[-1] $3,$4 -r[-1] [-2] -*[-2,-1] -cut[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic reflect : (no args) : Add water reflection to image(s).
reflect :
  -e "Add water reflection to image$?."
  -v- -t float -repeat @#
    --mirror[-1] y -r[-1] 100%,100%,100%,3 -s[-1] v -*[-3] 0.8 -*[-2] 0.9 -a[-3--1] v
    -water[-1] 30,1.5 (1;0) -r[-1] [-2],3 -*[-2,-1] -a[-2,-1] y
  -mv[-1] 0 -done -v+

#@gmic edges : '_threshold>=0' : Estimate contours of image(s).
edges : -float ${1=30}
  -if $1<0 -error "Invalid argument '$*' (should be '_threshold>=0')." -endif
  -e "Estimate image contours of image$?, with threshold $1."
  -v- -t float -repeat @#
    -gradient_norm[-1] -blur[-1] 0.5 -threshold[-1] $1% -distance[-1] 0 -equalize[-1] 256
    -negative[-1] -cut[-1] 30%,70% -n[-1] 0,1
  -mv[-1] 0 -done -v+

#@gmic cartoon : '_threshold>=0,_smoothness>=0' : Apply cartoon effect on image(s).
cartoon : -float ${1=30},${2=1}
  -if "$1<0 || $2<0" -error "Invalid argument '$*' (should be '_threshold>=0,_smoothness>=0')." -endif
  -e "Apply cartoon effect on image$?, with threshold $1 and smoothness $2."
  -v- -t float -repeat @#
    -to_rgb[-1] --edges[-1] $1 -repeat 2 -bilateral[-2] 13,20 -done
    --r[-2] 10,10,1,3,2 -index[-3] [-1],0,1 -rm[-1] -blur[-2] $2
    -r[-1] [-2] -*[-2--1]
  -mv[-1] 0 -done -v+

#@gmic drawing : '_amplitude>=0' : Apply drawing effect on image(s).
drawing : -float ${1=200}
  -if $1<0 -error "Invalid argument '$*' (should be '_amplitude>=0')." -endif
  -e "Apply drawing effect on image$? with amplitude $1."
  -v- -t float -repeat @#
    -smooth[-1] $1,0.2,1,3,3 -blur[-1] 2 -sharpen[-1] 1000 [-1]
    -r[-2] 20,20,1,3,2 -equalize[-2] 256 -index[-1] [-2],1,1 -rm[-2]
  -mv[-1] 0 -done -v+

#@gmic draw_whirl : '_amplitude>=0' : Apply whirl drawing effect on image(s).
draw_whirl : -float ${1=100}
  -if $1<0 -error "Invalid argument '$*' (should be '_amplitude>=0')." -endif
  -e "Apply whirl drawing effect on image$? with amplitude $1."
  -v- -t float -repeat @#
    100%,100% -noise[-1] 70,2 -*[-1] 255 -r[-1] [-2] -and[-1,-2] -smooth[-1] $1,0,1,2,2
    -sqrt[-1] -n[-1] 0,255 -equalize[-1] 256
  -mv[-1] 0 -done -v+

#@gmic paper_texture : (no args) : Add paper texture to image(s).
paper_texture :
  -e "Add paper texture to image$?."
  -v- -t float -repeat @#
    [-1] 30%,30% -noise[-1] 1,2 -r[-1] [-2],[-2],[-2],1,0 -ifft[-1]
    -rm[-1] -translate[-1] 50%,50%,50%,0,2 -sharpen[-1] 1 -n[-1] 1,1.2 -r[-1] [-2]
    -*[-2,-1] -cut[-1] [-2],[-2] -rm[-2]
  -mv[-1] 0 -done -v+

#@gmic stencilbw : '_edges>=0,_smoothness>=0' : Apply B&W stencil effect on image(s).
stencilbw : -float ${1=30},${2=10}
  -if "$1<0 || $2<0" -error "Invalid argument '$*' (should be '_edges>=0,_smoothness>=0')." -endif
  -e "Apply B&W stencil effect on image$?, with edges $1 and smoothness $2."
  -v- -t float -repeat @#
    -r[-1] 100%,100%,1,100% --edges[-1] $1 -quantize[-2] 3 -blur[-2] $2
    -sharpen[-2] 1000000 -norm[-2] -n[-2] 0,1 -*[-1,-2] -n[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic pencilbw : '_size>=0,_amplitude>=0' : Apply B&W pencil effect on image(s).
pencilbw : -float ${1=0.3},${2=60}
  -if "$1<0 || $2<0" -error "Invalid argument '$*' (should be '_size>=0,_amplitude>=0')." -endif
  -e "Apply B&W pencil effect on image$?, with size $1 and amplitude $2."
  -v- -t float -repeat @#
    -norm[-1] -blur[-1] $1 -sharpen[-1] 4000 -smooth[-1] $2,0,1 -equalize[-1] 256 -sqrt[-1] -n[-1] 0,255 -to_rgb[-1]
  -mv[-1] 0 -done -v+

#@gmic ditheredbw : (no args) : Create dithered B&W version of image(s).
ditheredbw :
  -e "Create dithered B&W version of image$?."
  -v- -t float -repeat @#
    -n[-1] 0,255 -r[-1] 100%,100%,100%,3 2,1,1,3,0,255 -index[-2] [-1],1,1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic dotsbw : (no args) : Apply B&W dots effect on image(s).
dotsbw :
  -e "Apply B&W dots effect on image$?."
  -v- -t float -repeat @#
    -norm[-1] --r[-1] 10%,10%,1,1,2 [-1],4 -threshold[-5] 10%
    -threshold[-4] 30% -threshold[-3] 50% -threshold[-2] 70% -threshold[-1] 90%
    -r[-5--1] [-6],4 -translate[-5--1] 5,5 -rm[-6] -_circle 3 -dilate[-6] [-1]
    -rm[-1] -_circle 5 -dilate[-5] [-1] -rm[-1] -_circle 7 -dilate[-4] [-1]
    -rm[-1] -_circle 9 -dilate[-3] [-1] -rm[-1] -_circle 11 -dilate[-2] [-1]
    -rm[-1] -or[-5--1] -n[-1] 0,255 -r[-1] 100%,100%,1,3
  -mv[-1] 0 -done -v+

#@gmic warhol : '_M>0,_N>0,_smoothness>=0,_color>=0' : Create MxN Andy Warhol-like artwork from image(s).
warhol : -int ${1=3},${2=$1} -float ${3=2},${4=20}
  -if "$1<=0 || $2<=0 || $3<0 || $4<0" -error "Invalid argument '$*' (should be '_M>0,_N>0,_smoothness>=0,_color>=0')." -endif
  -e "Create $1x$2 Andy Warhol-like artwork from image$?."
  -v- -t float -repeat @#
    -norm[-1] -blur[-1] $3 -array_expand0 $1,$2 -quantize[-1] 6 -n[-1] 0,5 -round[-1] 1
    -l[-1] -repeat $1 -repeat $2
      (0,1,2,3,4,5) -n[-1] 32,224 6,1,1,2,128 -noise[-1] $4,0 -cut[-1] 0,255 -a[-2,-1] v -ycbcr2rgb[-1] --map[0] [-1] -rm[-2]
    -done -done -append_tiles[1--1] $1,$2 -rm[0] -endl
  -mv[-1] 0 -done -v+

#@gmic cubism : '_nb_iter>=0,_bloc_size>0,_max_angle,_opacity,_smoothness>=0' : Apply cubism effect on image(s).
cubism : -int ${1=160},${2=30} -float ${3=75},${4=0.7},${5=0}
  -if "$1<0 || $2<=0 || $5<0" -error "Invalid argument '$*' (should be '_nb_iter>=0,_bloc_size>0,_angle,_opacity,smoothness>=0')." -endif
  -e "Apply cubism effect on image$?, with $1 iterations, bloc size $2, maximum angle $3, opacity $4 and smoothness $5."
  -v- -t float -repeat @#
    -repeat $1
      (@?^@?) (@{-2,w},@{-2,h}) -*[-2,-1] --+[-1] $2 --[-2] $2 --crop[-3] @-2,@-1,1 -rm[-2]
      -blur[-1] $5 --f[-1] 1 -rotate[-2,-1] @{?,-$3,$3},0,0 -image[-4] [-2],@-3,0,$4,[-1] -rm[-3--1]
    -done
  -mv[-1] 0 -done -v+

#@gmic glow : '_amplitude>=0' : Add soft glow on image(s).
glow : -float ${1=-1}
  -e "Add soft glow on image$?, with amplitude $1."
  -v- -t float -repeat @#
    --blur[-1] $1 -n[-1] [-2] -compose_edges[-2,-1] 1
  -mv[-1] 0 -done -v+

#@gmic old_photo : (no args) : Apply old photo effect on image(s).
old_photo :
  -e "Apply old photo effect on image$?."
  -v- -noise 20 -bilateral 30,60 -blur 2 -sharpen 100 -frame_fuzzy 20,20,6,3 -damp_patch 0.75 -n 0,255 -sepia -v+

#-------------------------
#
# Color filters
#
#-------------------------

#@gmic to_gray : (no args) : Force image(s) to be in GRAY mode.
to_gray :
  -e "Force image$? to be in GRAY mode."
  -v- -repeat @#
    -if @{-1,c}>=3 -channels[-1] 0,2 -luminance[-1] -else
    -if @{-1,c}==2 -r[-1] 100%,100%,100%,1,0
    -endif -endif
  -mv[-1] 0 -done -v+

#@gmic to_graya : (no args) : Force image(s) to be in GRAYA mode.
to_graya :
  -e "Force image$? to be in GRAYA mode."
  -v- -repeat @#
    -if @{-1,c}>=4 --channels[-1] 3 -r[-2] 100%,100%,100%,3,0 -luminance[-2] -a[-2,-1] v -else
    -if @{-1,c}==3 -luminance[-1] 100%,100%,100%,1,255 -a[-2,-1] v -else
    -if @{-1,c}==1 100%,100%,100%,1,255 -a[-2,-1] v
    -endif -endif -endif
  -mv[-1] 0 -done -v+

#@gmic to_rgb : (no args) : Force image(s) to be in RGB mode.
to_rgb :
  -e "Force image$? to be in RGB mode."
  -v- -repeat @#
    -if @{-1,c}>3 -channels[-1] 0,2 -else
    -if @{-1,c}==2 -r[-1] 100%,100%,100%,1,0 -r[-1] 100%,100%,100%,3 -else
    -if @{-1,c}==1 -r[-1] 100%,100%,1,3
    -endif -endif -endif
  -mv[-1] 0 -done -v+

#@gmic to_rgba : (no args) : Force image(s) to be in RGBA mode.
to_rgba :
  -e "Force image$? to be in RGBA mode."
  -v- -repeat @#
    -if @{-1,c}>4 -channels[-1] 0,3 -else
    -if @{-1,c}==3 100%,100%,1,1,255 -a[-2,-1] v -else
    -if @{-1,c}==2 -s[-1] v -r[-2] 100%,100%,100%,3 -a[-2,-1] v -else
    -if @{-1,c}==1 -r[-1] 100%,100%,1,3 100%,100%,1,1,255 -a[-2,-1] v
    -endif -endif -endif -endif
  -mv[-1] 0 -done -v+

#@gmic to_colormode : (no args) : Force image(s) to be in color mode of the first image.
to_colormode :
  -e "Force image$? to be in the same color mode."
  -v- -repeat @# -if @{>,-1}
    -if @{0,c}==1 -to_gray[1--1] -else
    -if @{0,c}==2 -to_graya[1--1] -else
    -if @{0,c}==3 -to_rgb[1--1] -else -to_rgba[1--1]
    -endif -endif -endif
  -endif -done -v+

#@gmic remove_opacity : (no args) : Remove opacity channel of image(s).
remove_opacity :
  -e "Remove opacity channel of image$?."
  -v- -repeat @#
    -if @{-1,c}==2 -r[-1] 100%,100%,100%,1,0 -else
    -if @{-1,c}==4 -r[-1] 100%,100%,100%,3,0
    -endif -endif
  -mv[-1] 0 -done -v+

#@gmic select_color : '_tolerance[%]>=0,col1,...,colN' : Select pixels with specified color in image(s).
select_color : -skip ${1=0}
  -e "Select color (${2*}) in image$?, with tolerance $1."
  -v- -t float -repeat @#
    (${2*}) -unroll[-1] v -to_colormode[-2,-1]
    -r[-1] [-2] --[-2,-1] -norm[-1] -threshold[-1] $1 -*[-1] -1 -+[-1] 1
  -mv[-1] 0 -done -v+

#@gmic replace_color : '_tolerance[%]>=0,_smoothness[%]>=0,src1,...,srcN,dest1,...,destN' : Replace pixels from/to specified colors in image(s).
replace_color : -skip ${1=0},${2=0}
  -e "Replace colors in image$?, with tolerance $1 and smoothness $2."
  -v- -t float -repeat @#
    (${3*}) -unroll[-1] v -s[-1] v,2 -to_colormode[-3--1] --[-1] [-2]
    -r[-2] [-3] --[-2] [-3] -norm[-2] -threshold[-2] $1 -blur[-2] $2 -*[-2] -1 -+[-2] 1
    -r[-2] [-3] -r[-1] [-2] -*[-2,-1] -+[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic fill_color : 'col1,...,colN' : Fill image(s) with specified color.
fill_color :
  -e "Fill image$? with color ($*)."
  -v- -repeat @#
    ($*) -unroll[-1] v -to_colormode[-2,-1]
    (@{-2,w},@{-2,h},@{-2,d}) -rm[-3] -r[-2] @-1 -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic luminance : (no args) : Compute luminance of image(s).
luminance :
  -e "Compute luminance of image$?."
  -v- -to_rgb -rgb2ycbcr -channels 0 -v+

#@gmic mix_rgb : a11,a12,a13,a21,a22,a23,a31,a32,a33 : Apply 3x3 specified matrix to RGB colors of image(s).
mix_rgb : -float ${1=1},${2=0},${3=0},${4=0},${5=1},${6=0},${7=0},${8=0},${9=1}
  -e "Apply matrix [ $1 $2 $3 ; $4 $5 $6 ; $7 $8 $9 ] to RGB colors of image$?."
  -v- -t float -repeat @#
    -r[-1] 100%,100%,1,3,0,2 -s[-1] v
    --*[-3] $4 --*[-3] $5 -+[-1,-2] --*[-2] $6 -+[-1,-2]
    --*[-4] $7 --*[-4] $8 -+[-1,-2] --*[-3] $9 -+[-1,-2]
    -*[-5] $1 -*[-4] $2 -*[-3] $3 -+[-5--3] -a[-3--1] v
  -mv[-1] 0 -done -v+

#@gmic solarize : (no args) : Solarize image(s).
solarize :
  -e "Solarize image$?."
  -v- -luminance -n 0,128 -map 1 -v+

#@gmic sepia : (no args) : Apply sepia tones effect on image(s).
sepia :
  -e "Apply sepia tones effect on image$?."
  -v- -luminance (0,44,115,143,196,244^0,20,84,119,184,235^0,5,44,73,144,200)
  -r[-1] 256,1,1,3,3 -map[0--2] [-1] -rm[-1] -v+

#@gmic negative : (no args) : Compute negative of image(s).
negative :
  -e "Compute negative of image$?."
  -v- -repeat @#
    --[-1] @{-1,M} -*[-1] -1
  -mv[-1] 0 -done -v+

#@gmic split_tones : 'N>0' : Split image(s) into N tones.
split_tones : -int ${1=3}
  -if $1<=0 -error "Invalid argument '$*' (should be 'N>0')." -endif
  -e "Split image$? into $1 tones."
  -v- -quantize $1 -n 1,$1 -round 1 --[-1] 1
  -repeat @#
    -l[-1] -repeat $1
      ---[0] @{>,-1} -abs[-1] -threshold[-1] 0.1 -negative[-1]
    -done -rm[0] -endl
  -mv[-$1--1] 0 -done -v+

#@gmic red_eye : '0<=_threshold<=100,_smoothness>=0,0<=attenuation<=1' : Attenuate red-eye effect in image(s).
red_eye : -float ${1=75},${2=3.5},${3=0.1}
  -if "$1<0 || $1>100 || $2<0 || $3<0 || $3>1"
    -error "Invalid argument '$*' (should be '0<=_threshold<=100,_smoothness>=0,0<=attenuation<=1')." -endif
  -e "Attenuate red-eye effect in image$?, with threshold $1, smoothness $2 and attenuation $3."
  -v- -t float -to_rgb -rgb2ycbcr -repeat @#
    -s[-1] v --[-1] 128 --threshold[-1] $1% -blur[-1] $2 -sqrt[-1] -*[-1] -1 -+[-1] 1
    -n[-1] $3,1 -*[-2,-1] -+[-1] 128 -a[-3--1] v -ycbcr2rgb[-1]
  -mv[-1] 0 -done -v+

#@gmic split_opacity : 'order=0' : Split color and opacity parts of image(s).
split_opacity : -int ${1=0}
  -e "Split color and opacity parts of image$?."
  -v- -repeat @#
    -if "@{-1,c}!=2 && @{-1,c}!=4" -mv[-1] 0 -else
      (@{-1,c}) --[-1] 2 --channels[-2] 100% -channels[-3] 0,@-2 -rm[-2] -if $1 -mv[-1] -2 -endif -mv[-2,-1] 0
    -endif
  -done -v+

#-------------------------
#
# Image fading
#
#-------------------------

#@gmic fade_x : '0<=_start<=100,0<=_end<=100' : Create horizontal fading from image(s).
fade_x : -float ${1=30},${2=70}
  -if "$1<0 || $1>100 || $2<0 || $2>100" -error "Invalid argument '$*' (should be '0<=_start<=100,0<=_end<=100')." -endif
  -e "Create ($1%,$2%) horizontal fading from image$?."
  -v- -repeat @#/2
    (0,1) -_fade $1,$2
  -mv[-1] 0 -done -v+

#@gmic fade_y : '0<=_start<=100,0<=_end<=100' : Create vertical fading from image(s).
fade_y : -float ${1=30},${2=70}
  -if "$1<0 || $1>100 || $2<0 || $2>100" -error "Invalid argument '$*' (should be '0<=_start<=100,0<=_end<=100')." -endif
  -e "Create ($1%,$2%) vertical fading from image$?."
  -v- -repeat @#/2
    (0;1) -_fade $1,$2
  -mv[-1] 0 -done -v+

#@gmic fade_z : '0<=_start<=100,0<=_end<=100' : Create transversal fading from image(s).
fade_z : -float ${1=30},${2=70}
  -if "$1<0 || $1>100 || $2<0 || $2>100" -error "Invalid argument '$*' (should be '0<=_start<=100,0<=_end<=100')." -endif
  -e "Create ($1%,$2%) transversal fading from image$?."
  -v- -repeat @#/2
    (0/1) -_fade $1,$2
  -mv[-1] 0 -done -v+

#@gmic fade_radial : '0<=_start<=100,0<=_end<=100' : Create radial fading from image(s).
fade_radial : -float ${1=30},${2=70}
  -if "$1<0 || $1>100 || $2<0 || $2>100" -error "Invalid argument '$*' (should be '0<=_start<=100,0<=_end<=100')." -endif
  -e "Create ($1%,$2%) radial fading from image$?."
  -v- -repeat @#/2
    100%,100% -point 50%,50%,0,1,1 -distance[-1] 1 -_fade $1,$2
  -mv[-1] 0 -done -v+

#@gmic fade_diamond : '0<=_start<=100,0<=_end<=100' : Create diamond fading from image(s).
fade_diamond : -float ${1=70},${2=90}
  -if "$1<0 || $1>100 || $2<0 || $2>100" -error "Invalid argument '$*' (should be '0<=_start<=100,0<=_end<=100')." -endif
  -e "Create ($1%,$2%) diamond-shaped fading from image$?."
  -v- -repeat @#/2
    (0,1,0;1,1,1;0,1,0) -_fade $1,$2
  -mv[-1] 0 -done -v+

_fade :
  -t float -r[-2] [-3],5 -r[-1] [-2],3 -cut[-1] $1%,$2% -n[-1] 0,1 --*[-1] -1 -+[-1] 1 -*[-4,-1] -*[-2,-1] -+[-2,-1]

#-------------------------
#
# Image composition
#
#-------------------------

#@gmic compose_rgba : (no args) : Compose RGBA image(s) two-by-two, over RGB background.
compose_rgba :
  -e "Compose RGBA image$? two-by-two, over RGB background."
  -v- -t float -repeat @#/2
    -to_rgb[-2] -r[-1] [-2],[-2],1,100% -to_rgba[-1]
    -s[-1] v -a[-4--2] v -/[-1] 255 [-1] -negative[-1] -r[-4--1] 100%,100%,1,3
    -*[-4,-1] -*[-2,-1] -+[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic compose_average : (no args) : Compose image(s) two-by-two, using average mode.
compose_average :
  -e "Compose image$? two-by-two, using average mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 -+[-2,-1] -/[-1] 2
  -mv[-1] 0 -done -v+

#@gmic compose_multiply : (no args) : Compose image(s) two-by-two, using multiply mode.
compose_multiply :
  -e "Compose image$? two-by-two, using multiply mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 -*[-2,-1] -/[-1] 256
  -mv[-1] 0 -done -v+

#@gmic compose_screen : (no args) : Compose image(s) two-by-two, using screen mode.
compose_screen :
  -e "Compose image$? two-by-two, using screen mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 --[-2,-1] 255 -*[-2,-1] -/[-1] 256 --[-1] 255 -*[-1] -1
  -mv[-1] 0 -done -v+

#@gmic compose_darken : (no args) : Compose image(s) two-by-two, using darken mode.
compose_darken :
  -e "Compose image$? two-by-two, using darken mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 -min[-2] [-1] -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic compose_lighten : (no args) : Compose image(s) two-by-two, using lighten mode.
compose_lighten :
  -e "Compose image$? two-by-two, using lighten mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 -max[-2] [-1] -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic compose_difference : (no args) : Compose image(s) two-by-two, using difference mode.
compose_difference :
  -e "Compose image$? two-by-two, using difference mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 --[-2,-1] -abs[-1]
  -mv[-1] 0 -done -v+

#@gmic compose_negation : (no args) : Compose image(s) two-by-two, using negation mode.
compose_negation :
  -e "Compose image$? two-by-two, using negation mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 -+[-2,-1] --[-1] 255 -abs[-1] --[-1] 255 -*[-1] -1
  -mv[-1] 0 -done -v+

#@gmic compose_exclusion : (no args) : Compose image(s) two-by-two, using exclusion mode.
compose_exclusion :
  -e "Compose image$? two-by-two, using exclusion mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 --*[-2] [-1] -/[-1] -128 -+[-3--1]
  -mv[-1] 0 -done -v+

#@gmic compose_overlay : (no args) : Compose image(s) two-by-two, using overlay mode.
compose_overlay :
  -e "Compose image$? two-by-two, using overlay mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0
    --threshold[-2] 128
    --*[-3] [-2] -/[-1] 128
    --[-4,-3] 255 -*[-4,-3] -/[-3] 128 --[-3] 255 -*[-3] -1
    -*[-3] [-2] -*[-2] -1 -+[-2] 1 -*[-2,-1]
    -+[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic compose_hardlight : (no args) : Compose image(s) two-by-two, using hard light mode.
compose_hardlight :
  -e "Compose image$? two-by-two, using hard light mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0
    --threshold[-1] 128
    --*[-3] [-2] -/[-1] 128
    --[-4,-3] 255 -*[-4,-3] -/[-3] 128 --[-3] 255 -*[-3] -1
    -*[-3] [-2] -*[-2] -1 -+[-2] 1 -*[-2,-1]
    -+[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic compose_softlight : (no args) : Compose image(s) two-by-two, using soft light mode.
compose_softlight :
  -e "Compose image$? two-by-two, using soft light mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 -/[-2,-1] 256 --*[-2] [-1] -*[-1] 2 -sqr[-3] -*[-2] [-3] -*[-2] -2 -+[-3--1] -*[-1] 256
  -mv[-1] 0 -done -v+

#@gmic compose_dodge : (no args) : Compose image(s) two-by-two, using dodge mode.
compose_dodge :
  -e "Compose image$? two-by-two, using dodge mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 --[-1] 255.1 -/[-2,-1] -*[-1] -256 -cut[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic compose_colorburn : (no args) : Compose image(s) two-by-two, using color burn mode.
compose_colorburn :
  -e "Compose image$? two-by-two, using colorburn mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 --[-2] 255 -+[-1] 0.1 -/[-2,-1] -*[-1] 256 -+[-1] 255 -cut[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic compose_reflect : (no args) : Compose image(s) two-by-two, using reflect mode.
compose_reflect :
  -e "Compose image$? two-by-two, using reflect mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 -sqr[-2] --[-1] 255.1 -/[-2,-1] -*[-1] -1 -cut[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic compose_freeze : (no args) : Compose image(s) two-by-two, using freeze mode.
compose_freeze :
  -e "Compose image$? two-by-two, using freeze mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 --[-2] 255 -sqr[-2] -+[-1] 0.1 -/[-2,-1] --[-1] 255 -*[-1] -1 -cut[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic compose_stamp : (no args) : Compose image(s) two-by-two, using stamp mode.
compose_stamp :
  -e "Compose image$? two-by-two, using stamp mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 -*[-1] 2 -+[-2,-1] --[-1] 255 -cut[-1] 0,255
  -mv[-1] 0 -done -v+

#@gmic compose_interpolation : (no args) : Compose image(s) two-by-two, using interpolation mode.
compose_interpolation :
  -e "Compose image$? two-by-two, using interpolation mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 -*[-2,-1] 0.012271846 -cos[-2,-1] -/[-2,-1] -4 -+[-2,-1] -+[-1] 0.5 -*[-1] 256
  -mv[-1] 0 -done -v+

#@gmic compose_xor : (no args) : Compose image(s) two-by-two, using xor mode.
compose_xor :
  -e "Compose image$? two-by-two, using xor mode."
  -v- -remove_opacity -to_colormode -t float -repeat @#/2
    -r[-1] [-2],0 -xor[-2,-1]
  -mv[-1] 0 -done -v+

#@gmic compose_edges : 'smoothness=0.8' : Compose image(s) togethers using edge composition.
compose_edges : -float ${1=0.8}
  -e "Compose image$? using edge composition, with smoothness $1."
  -if @#>1 -v- -to_rgb -t float -repeat @#
    --gradient_norm[-1] -+[-1] 1 -blur[-1] $1 -n[-1] 1,10 -sqr[-1] -s[-2] v -*[-4--2] [-1] -a[-4--1] v
  -mv[-1] 0 -done -r[1--1] [0],0,0,1 -+ -s[-1] v -/[-4--2] [-1] -rm[-1] -a[-3--1] v -v+ -endif

#-------------------------
#
# Motion related filters
#
#-------------------------

#@gmic cross_correlation : (no args) : Compute cross-correlation using two-by-two image(s).
cross_correlation :
  -e "Compute cross-correlation using two-by-two image$?."
  -v- -t float -repeat @#/2
    -norm[-2,-1] -fft[-2] -fft[-1] [-2,-1] -mul[-2] [-5] -mul[-1] [-6]
    --[-2,-1] -*[-5,-3] -*[-3,-2] -+[-3,-2] -ifft[-2,-1] -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic normalized_cross_correlation : (no args) : Compute normalized cross-correlation using two-by-two image(s).
normalized_cross_correlation :
  -e "Compute normalized cross-correlation using two-by-two image$?."
  -v- -t float -repeat @#/2
    -norm[-2,-1] -fft[-2] -fft[-1] [-2,-1] -mul[-2] [-5] -mul[-1] [-6]
    --[-2,-1] -*[-5,-3] -*[-3,-2] -+[-3,-2] [-2,-1] -a[-2,-1] v -norm[-1]
    -/[-3] [-1] -/[-2,-1] -ifft[-2,-1] -rm[-1]
  -mv[-1] 0 -done -v+

#@gmic phase_correlation : (no args) : Estimate translation vector using two-by-two image(s).
phase_correlation :
  -e "Estimate translation vector using two-by-two image$?."
  -v- -t float -repeat @#/2
    -normalized_cross_correlation[-2,-1]
    (@{-1,+}) -*[-1] 2 -s[-1] x -rm[-1]
    -if @-3>@{-4,w} --[-3] @{-4,w} --[-3] @{-4,w} -endif
    -if @-2>@{-4,h} --[-2] @{-4,h} --[-2] @{-4,h} -endif
    -if @-1>@{-4,d} --[-1] @{-4,d} --[-1] @{-4,d} -endif
    -a[-3--1] v -/[-1] 2 -*[-1] -1 -rm[-2]
  -mv[-1] 0 -done -v+

#@gmic morph : 'nb_frames>0,_smoothness>=0,_precision>0' : Create morphing sequence between image(s).
morph : -int $1 -float ${2=0.2} -float ${3=0.1}
  -if "$1<=0 || $2<0 || $3<=0" -error "Invalid argument '$*' (should be 'nb_frames>0,_smoothness>=0,_precision>0')." -endif
  -e "Create morphing sequence between image$?, with $1 intra-frames, smoothness $2 and precision $3."
  -v- -t float -r[1--1] [0],3 -i[0] (@#) --[0] 1 -repeat @0
    --equalize[-2,-1] 256 -n[-2,-1] 0,255
    --displacement[-2] [-1],$2,$3 --warp[-5] [-1],1,1,1,$1 -a[-$1--1] z -rm[-2]
    --displacement[-2] [-3],$2,$3 --warp[-5] [-1],1,1,1,$1 -a[-$1--1] z -rm[-7--4,-2]
    (1/0) -r[-1] [-2],3 -*[-3] [-1] -*[-2,-1] -mirror[-1] z -+[-2,-1] -s[-1] z
    -mv[-$1--1] 1 -mv[1] @#
  -done -mv[-1] 1 -rm[0] -v+

#@gmic register_nonrigid : '_smoothness>=0,_precision>0,_nb_scale>=0' : Register image(s) with non-rigid warp.
register_nonrigid : -float ${1=0.2},${2=0.1} -int ${3=0}
  -if "$1<0 || $2<=0 || $3<0" -error "Invalid argument '$*' (should be '_smoothness>=0,_precision>0,_nbscales>=0')." -endif
  -e "Register image$? with non-rigid warp, smoothness $1, precision $2 and $3 scale(s)."
  -v- -t float --equalize[0] 256 -n[-1] 0,255 -mv[-1] 1
  -repeat @# -if @{>,-1}>1
    --equalize[-1] 256 -n[-1] 0,255 -displacement[-1] [1],$1,$2,$3
    -warp[-2] [-1],1,1,1 -rm[-1]
  -mv[-1] 2 -endif -done -rm[1] -v+

#@gmic register_rigid : '_smoothness>=0' : Register image(s) with rigid warp.
register_rigid : -float ${1=1}
  -if $1<0 -error "Invalid argument '$*' (should be '_smoothness>=0')." -endif
  -e "Register image$? with rigid warp and smoothness $1."
  -v- -t float --equalize[0] 256 -blur[-1] $1 -n[-1] 0,255 -mv[-1] 1
  -repeat @# -if @{>,-1}>1
    --equalize[-1] 256 -blur[-1] $1 -n[-1] 0,255 --phase_correlation[1,-1] -rm[-2] -*[-1] -1
    -translate[-2] @-1,0,1 -rm[-1]
  -mv[-1] 2 -endif -done -rm[1] -v+

#-------------------------
#
# Video related filters
#
#-------------------------

#@gmic deinterlace : '_method={0,1}' : Deinterlace image(s) ('method' can be 0=standard or 1=motion-compensated).
deinterlace : -int ${1=0}
  -if $1 -e "Deinterlace image$? with motion-compensated method."
  -else  -e "Deinterlace image$? with standard method." -endif
  -v- -t float -repeat @#
    -i[-2] (@{-1,w},@{-1,h})
    -if $1==0
      -l[-1] -s y -a[0--1:2] y -a[1--1] y -r[-2] [-1],0 -r[-2,-1] 100%,200%,100%,100%,5 -+[-2,-1] -/[-1] 2 -endl
    -else
      -l[-1] -s y -a[0--1:2] y -a[1--1] y -r[-2] [-1],0 -r[-2,-1] 100%,200%,1,100%,5
      --displacement[-2] [-1],0.05 -warp[-3] [-1],1,1,1 -rm[-1] -+[-2,-1] -/[-1] 2 -endl
    -endif
    -r[-1] @-2 -rm[-2]
  -mv[-1] 0 -done -v+

#-------------------------
#
#  3D-related filters
#
#-------------------------

# G'MIC "easter-egg(s)" !
dick3d :
  -e ""
  -e "!!***********************************************************!!"
  -e "!! Congratulations ! You have found the hidden Easter-egg(s) !!"
  -e "!!***********************************************************!!"
  -e ""
  -v- -rm -t float 2 1,2 1,1,2 -f -1,1 -r 100,100,100,1,3 -sqr -+ -* -8 -exp
  [0],2 -translate[-1] -20 -translate[-2] 20 -+[-1,-2] -translate[-1] 0,20
  -r[-2] 100,220,100,1,3 -r[-2] 100,100,100,3,0,0,1 -translate[-2] 0,-10 -+
  -isovalue3d 0.5 -rd3d 4 -d3d -v+

#@gmic anim3d : '_width>0,_height>0,_dx,_dy,_dz' : Animate 3D object(s) in a window.
anim3d : -int ${1=640},${2=480} -float ${3=0},${4=10},${5=0}
  -if "$1<=0 || $2<=0" -error "Invalid argument '$*' (should be '_width>0,_height>0,_dx,_dy,dz')." -endif
  -e "Animate 3D object$?, in a $1x$2 window with angle velocities ($3,$4,$5)."
  -v- -repeat @#
    --n3d[@{>,-1}] -*3d {min($1,$2)/1.7} (0,0,0)
    -do
       --rot3d[-2] 1,0,0,@{-1,0} -rot3d[-1] 0,1,0,@{-2,1} -rot3d[-1] 0,0,1,@{-2,2} ($3,$4,$5) -+[-3,-1]
       $1,$2,1,3,200 -object3d[-1] [-2],50%,50%,0,1
       -w[-1] @{-1,w},@{-1,h},0,20 -rm[-2,-1]
    -while @! -rm[-1] -w
  -done -v+

#@gmic imagecube3d : '_resolution>0' : Create 3D mapped cube from image(s).
imagecube3d : -int ${1=128}
  -if $1<=0 -error "Invalid argument '$*' (should be '_resolution>0')." -endif
  -e "Create 3D mapped cube from image$?, with resolution $1."
  -v- -repeat @#
    -r[-1] $1,$1,1,-100,2 -mirror[-1] x -elevation3d[-1] 0 -c3d[-1] -n3d[-1] -+3d[-1] 0,0,0.5 --rot3d[-1] 0,1,0,180
    -+3d[-2,-1] --rot3d[-1] 0,1,0,90 --rot3d[-2] 1,0,0,90 -+3d[-3--1]
  -mv[-1] 0 -done -v+

#-------------------------
#
# Other various filters
#
#-------------------------

#@gmic factorial : 'N' : Print the factorial of the integer 'N'.
factorial : -int $1
  -v- ($1) -+[-1] 1 -if @-1 (1) (1) -repeat $1 -*[-1] @-2 -+[-2] 1 -done -v+ -e "Factorial($1) = @-1" -v- -rm[-3--1]
  -else -v+ -e "Factorial($1) is undefined." -endif -v+

# Generate a 'no-preview' image.
gmic4gimp_no_preview :
  -if @#>0 -k[0] -else 256,256,1,1,128 -endif
  118,50 -text[-1] "No preview\navailable",2,1,24,1,255 -r[-1] [-2],[-2],1,1,0,0,1 -to_colormode[-2,-1]
  (1.5,0,1.5;0,0,0;1.5,0,1.5) -r[-1] [-3],3 -*[-3,-1] -cut[-2] 0,255 -or
  -skip $*

#--------------------------
#
# Define menu entries
# for the GIMP plug-in.
#
#--------------------------

#----------------------
# English translations
#----------------------

#@gimp_en <b><i>About</i></b>
#----------------------------

#@gimp_en G'MIC plug-in : gmic4gimp_logo_big_en, gmic4gimp_logo_en
#@gimp_en : note = note{"
#@gimp_en : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic <b>I</b>mage <b>C</b>onverter )</span>\n\nproposed to you by"}
#@gimp_en : note = link("David Tschumperl\303\251","http://www.greyc.ensicaen.fr/~dtschump")
#@gimp_en : note = link{"( IMAGE Team / GREYC Laboratory - CNRS UMR 6072 )","http://www.greyc.ensicaen.fr/EquipeImage"}
#@gimp_en : note = note{"
#@gimp_en : This plug-in is based on the open-source libraries <b>G'MIC</b> and <b>CImg</b> (C++ Template Image Processing Library),
#@gimp_en : available at :"}
#@gimp_en : note = link("http://gmic.sourceforge.net/")
#@gimp_en : note = note{"and"}
#@gimp_en : note = link("http://cimg.sourceforge.net/")
#@gimp_en : note = note{"\n
#@gimp_en : If you appreciate <b>G'MIC</b>, you are welcome to send us a nice postcard from your place, at :\n\n
#@gimp_en : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gimp_en :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gimp_en : Postcards senders automatically enter the <i>Friends Hall of Fame</i> :) !
#@gimp_en : "}
gmic4gimp_logo :
  -rm 65,32,1,3 -text G\'MIC,3,2,32,1,1 -r 200,100,1,3,5 -blur 4 -sharpen 5 --f 256
  -plasma[-1] 10,3 -n[-1] 0,255 -cut 0,255 -* -elevation3d -0.4 230,120,1,3 -r3d 3 -sl3d 0
  -rotate3d[-2] 1,0,0,10 -*3d[-2] 0.9 -c3d[-2] -object3d[-1] [-2],50%,40%,0,1 -rm[-2] -sqrt
  -n 0,300 -cut 0,255 -text $1,12%,75%,24,1,255
gmic4gimp_logo_en :
  -gmic4gimp_logo "Plug-in for GIMP"
gmic4gimp_logo_big_en :
  -gmic4gimp_logo_en -quantize 8 -resize2x -frame 1,1,255

#@gimp_en Release notes : nop, gmic4gimp_logo_en
#@gimp_en : note = note{"
#@gimp_en : - <b>2009/01/13</b> : version <i>1.3.0</i> (Initial).\n
#@gimp_en : - <b>2009/03/18</b> : version <i>1.3.1</i>.\n
#@gimp_en : - <b>2009/05/07</b> : version <i>1.3.1.4</i>.\n
#@gimp_en : - <span foreground="purple"><b>2009/05/27</b> : version <i>1.3.1.7</i> (Current).</span>\n
#@gimp_en : "}

#@gimp_en Contributors : nop, gmic4gimp_friends_en
#@gimp_en : note = note{"
#@gimp_en : We would like to thank all these people who contributed to <b>G'MIC</b> in one way or another.
#@gimp_en : A big hug to : \n\n
#@gimp_en : <b> -</b> <i>Claude Bulin</i> <small>(packaging)</small>
#@gimp_en : <b> -</b> <i>J&#233;rome Ferrari</i> <small>(testing)</small>
#@gimp_en : <b> -</b> <i>Jalal Fadili</i> <small>(compiling)</small>
#@gimp_en : <b> -</b> <i>Angelo Lama</i> <small>(testing)</small>
#@gimp_en : <b> -</b> <i>PhotoComiX</i> <small>(testing &amp; Italian translation)</small>
#@gimp_en : <b> -</b> <i>Gilmoth</i> <small>(Italian translation)</small>
#@gimp_en : <b> -</b> <i>Fran&#231;ois Collard</i> <small>(testing)</small>
#@gimp_en : <b> -</b> <i>St&#233;phane de la Linuxerie</i> <small>(design)</small>
#@gimp_en : <b> -</b> <i>Dani Sard&#224;</i> <small>(Catalan translation)</small>
#@gimp_en : <b> -</b>"}
gmic4gimp_friends :
  -rm -_heart80x73 -resize3x
  --*[-1] 70 --*[-2] 40 -*[-3] 255 -a v
  -flood 0,0,0,0,1,255 -blur_radial 1.5 -whirls 7,4,1,2.79
  -text $1,16,30,24,0.7,0
  -gmic4gimp_unsharp 0.45,10,0,4,4,1,0,1
gmic4gimp_friends_en :
  -gmic4gimp_friends "Greetings to\n  all G'MIC\n  friends !"

#@gimp_en Filters design : nop, gmic4gimp_logo_en
#@gimp_en : note = note{"
#@gimp_en : It is possible to add your own <b>user-defined filters</b> to the <b>G'MIC</b> plug-in :\n\n
#@gimp_en : To do so, you need to create a <span foreground="purple" style="italic">.gmic</span> text file (do not forget the first dot !)
#@gimp_en : in your <i>Home</i> directory (or <i>Applications Data</i> directory on Windows).
#@gimp_en : The plug-in will read it each time it is launched, or when the <i>Update Filters</i>
#@gimp_en : button is pressed. This file must be a regular <b>G'MIC</b> macro file, containing the filter definitions that
#@gimp_en : will appear in the filter list.
#@gimp_en : You can see an example of such a file at :"}
#@gimp_en : note = link("http://gmic.sourceforge.net/.gmic_def")
#@gimp_en : note = note{"
#@gimp_en : Writting a new filter with the <b>G'MIC</b> language is not particularly trivial (though not awful), but
#@gimp_en : it can be generally done in very few lines.\n\n
#@gimp_en : <span foreground="purple" underline="single">Example of a valid <i>.gmic</i> file :</span>\n\n
#@gimp_en : <tt>#@gimp My effect : my_effect, my_effect, Sigma = float(2,0,10)\n
#@gimp_en : my_effect :\n  --blur $1 -n 0,255 -xor</tt>\n\n
#@gimp_en : By the way, you are encouraged to share your nice custom filters on the dedicated <b>G'MIC</b> forum :
#@gimp_en : "}
#@gimp_en : note = link("Go to the G'MIC forum","http://sourceforge.net/forum/forum.php?forum_id=923318")

#@gimp_en Filters update : nop, gmic4gimp_logo_en
#@gimp_en : note = note{"
#@gimp_en : The <b>G'MIC</b> plug-in is able to <b>update</b> his list of filters definitions
#@gimp_en : from the Internet. Pushing the <i>Update Filters</i> button on the left pane
#@gimp_en : makes <b>G'MIC</b> connect to the update server
#@gimp_en : and download the latest available filters definitions.\n\n
#@gimp_en : Basically, this procedure creates a file
#@gimp_en : <span foreground="purple" style="italic">.gmic_def.xxxx</span> into your <i>Home</i> directory
#@gimp_en : (or <i>Application Data</i> directory on Windows),
#@gimp_en : where <i>xxxx</i> are the four digits of the <b>G'MIC</b> plug-in version number.
#@gimp_en : In case of troubles, you can manually update your filters by retrieving the update file from :"}
#@gimp_en : note = link("http://www.greyc.ensicaen.fr/~dtschump/gmic_def.xxxx")
#@gimp_en : note = note{"
#@gimp_en : Then, just copy and rename this file as your <span foreground="purple" style="italic">.gmic_def.xxxx</span>
#@gimp_en : (do not forget the first dot, and replace the <i>xxxx</i> by your <b>G'MIC</b> version number)
#@gimp_en : and the update procedure is done.
#@gimp_en : By the way, deleting this file resets all the filters definitions to their initial state.
#@gimp_en : "}

#@gimp_en Friends Hall of Fame : nop, gmic4gimp_friends_en
#@gimp_en : note = note{"\n<span foreground="purple" underline="single">Postcard senders :</span>"}
#@gimp_en : note = note{"    <b>-</b> <b>0</b> postcards received so far, you could be the first sender ! :)"}

#---------------------
# French translations
#---------------------

#@gimp_fr <b><i>&#192; propos</i></b>
#------------------------------------

#@gimp_fr Le greffon G'MIC : gmic4gimp_logo_big_fr, gmic4gimp_logo_fr
#@gimp_fr : note = note{"
#@gimp_fr : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic <b>I</b>mage <b>C</b>onverter )</span>\n\npar"}
#@gimp_fr : note = link("David Tschumperl\303\251","http://www.greyc.ensicaen.fr/~dtschump")
#@gimp_fr : note = link{"( Equipe IMAGE / Laboratoire GREYC - CNRS UMR 6072 )","http://www.greyc.ensicaen.fr/EquipeImage"}
#@gimp_fr : note = note{"
#@gimp_fr : Ce greffon est bas&#233; sur les biblioth&#232;ques libres <b>G'MIC</b> et <b>CImg</b> (C++ Template Image Processing Library),
#@gimp_fr : disponibles aux adresses :"}
#@gimp_fr : note = link("http://gmic.sourceforge.net/")
#@gimp_fr : note = note{"et"}
#@gimp_fr : note = link("http://cimg.sourceforge.net/")
#@gimp_fr : note = note{"\n
#@gimp_fr : Si vous appr&#233;ciez <b>G'MIC</b>, vous pouvez nous le faire savoir en envoyant une petite carte
#@gimp_fr : postale de votre ville, &#224; l'adresse :\n\n
#@gimp_fr : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gimp_fr :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gimp_fr : Envoyer une carte postale vous fera rentrer <i>de facto</i> dans le <i>Cercle des amis de G'MIC</i> :) !
#@gimp_fr : "}
gmic4gimp_logo_fr :
  -gmic4gimp_logo "Greffon pour GIMP"
gmic4gimp_logo_big_fr :
  -gmic4gimp_logo_fr -quantize 8 -resize2x -frame 1,1,255

#@gimp_fr Notes de versions : nop, gmic4gimp_logo_fr
#@gimp_fr : note = note{"
#@gimp_fr : - <b>2009/01/13</b> : version <i>1.3.0</i> (Initiale).\n
#@gimp_fr : - <b>2009/03/18</b> : version <i>1.3.1</i>.\n
#@gimp_fr : - <b>2009/05/07</b> : version <i>1.3.1.4</i>.\n
#@gimp_fr : - <span foreground="purple"><b>2009/05/27</b> : version <i>1.3.1.7</i> (Actuelle).</span>\n
#@gimp_fr : "}

#@gimp_fr Contributeurs : nop, gmic4gimp_friends_fr
#@gimp_fr : note = note{"
#@gimp_fr : Nous voudrions remercier l'ensemble de ces personnes, qui ont d'une fa&#231;on ou d'une autre,
#@gimp_fr : contribu&#233;es &#224; <b>G'MIC</b>.
#@gimp_fr : Un grand merci &#224; : \n\n
#@gimp_fr : <b> -</b> <i>Claude Bulin</i> <small>(empaquetage)</small>
#@gimp_fr : <b> -</b> <i>J&#233;rome Ferrari</i> <small>(tests)</small>
#@gimp_fr : <b> -</b> <i>Jalal Fadili</i> <small>(compilation)</small>
#@gimp_fr : <b> -</b> <i>Angelo Lama</i> <small>(tests)</small>
#@gimp_fr : <b> -</b> <i>PhotoComiX</i> <small>(tests)</small>
#@gimp_fr : <b> -</b> <i>Fran&#231;ois Collard</i> <small>(tests)</small>
#@gimp_fr : <b> -</b> <i>St&#233;phane de la Linuxerie</i> <small>(design)</small>
#@gimp_en : <b> -</b> <i>Dani Sard&#224;</i> <small>(traduction Catalan)</small>
#@gimp_en : <b> -</b>"}
gmic4gimp_friends_fr :
  -gmic4gimp_friends "Coucou &#224; tous\nles amis de\n   G'MIC !"

#@gimp_fr Cr&#233;ation de filtres : nop, gmic4gimp_logo_fr
#@gimp_fr : note = note{"
#@gimp_fr : Il est possible d'ajouter vos <b>propres filtres</b> au greffon <b>G'MIC</b> :\n\n
#@gimp_fr : Pour cela, il vous suffit de cr&#233;er un fichier <span foreground="purple" style="italic">.gmic</span>
#@gimp_fr : (ne pas oublier le premier point !) dans votre dossier <i>Home</i> (ou <i>Applications Data</i> sous Windows).
#@gimp_fr : Ce greffon va lire ce fichier &#224; chaque d&#233;marrage, ou lorsque le bouton <i>Actualiser</i>
#@gimp_fr : sera cliqu&#233;. Ce fichier doit &#234;tre au format de macros <b>G'MIC</b>, contenant les d&#233;finitions
#@gimp_fr : des nouveaux filtres qui vont appara&#238;tre dans la liste.
#@gimp_fr : Un exemple d'un tel fichier est visible &#224; l'adresse :"}
#@gimp_fr : note = link("http://gmic.sourceforge.net/.gmic_def")
#@gimp_fr : note = note{"
#@gimp_fr : Ecrire un filtre en langage <b>G'MIC</b> n'est pas particuli&#232;rement trivial (sans &#234;tre non plus tr&#232;s difficile),
#@gimp_fr : et ne n&#233;cessite souvent que quelques lignes.\n\n
#@gimp_fr : <span foreground="purple" underline="single">Exemple de fichier <i>.gmic</i> valide :</span>\n\n
#@gimp_fr : <tt>#@gimp My effect : my_effect, my_effect, Sigma = float(2,0,10)\n
#@gimp_fr : my_effect :\n  --blur $1 -n 0,255 -xor</tt>\n\n
#@gimp_fr : Vous &#234;tes bien s&#251;r encourag&#233;s &#224; partager vos propres filtres sur le forum <b>G'MIC</b> pr&#233;vu &#224;
#@gimp_fr : cet effet :
#@gimp_fr : "}
#@gimp_fr : note = link("Participer au forum G'MIC","http://sourceforge.net/forum/forum.php?forum_id=923318")

#@gimp_fr Mise &#224; jour des filtres : nop, gmic4gimp_logo_fr
#@gimp_fr : note = note{"
#@gimp_fr : Le greffon <b>G'MIC</b> est capable de <b>mettre &#224; jour</b> sa liste de d&#233;finitions de filtres
#@gimp_fr : en se connectant &#224; Internet. L'appui sur le bouton <i>Actualiser</i>
#@gimp_fr : va permettre &#224; <b>G'MIC</b> de se connecter sur le serveur de mises &#224; jour, et de t&#233;l&#233;charger
#@gimp_fr : les derni&#232;res d&#233;finitions de filtres.\n\n
#@gimp_fr : Techniquement, cette proc&#233;dure cr&#233;&#233; un fichier
#@gimp_fr : <span foreground="purple" style="italic">.gmic_def.xxxx</span> dans votre r&#233;pertoire <i>Home</i>
#@gimp_fr : (ou <i>Application Data</i> sur Windows),
#@gimp_fr : o&#249; <i>xxxx</i> sont les quatres chiffres du num&#233;ro de version du greffon <b>G'MIC</b>.
#@gimp_fr : En cas de probl&#232;mes, vous pouvez donc toujours mettre &#224; jour vos filtres manuellement,
#@gimp_fr : en t&#233;l&#233;chargeant le fichier suivant :"}
#@gimp_fr : note = link("http://www.greyc.ensicaen.fr/~dtschump/gmic_def.xxxx")
#@gimp_fr : note = note{"
#@gimp_fr : Copiez juste ce fichier &#224; la bonne place, et renommez le en <span foreground="purple" style="italic">.gmic_def.xxxx</span>
#@gimp_fr : (n'oubliez pas le premier point, et remplacez les <i>xxxx</i> par le num&#233;ro de version de votre greffon <b>G'MIC</b>)
#@gimp_fr : et la proc&#233;dure de mise &#224; jour sera effectu&#233;e.
#@gimp_fr : Bien entendu, effacer ce fichier remet l'ensemble des d&#233;finitions des filtres &#224; leurs &#233;tats initiaux.
#@gimp_fr : "}

#@gimp_fr Le cercle des amis de G'MIC : nop, gmic4gimp_friends_fr
#@gimp_fr : note = note{"\n<span foreground="purple" underline="single">Contributeurs en cartes postales :</span>"}
#@gimp_fr : note = note{"    <b>-</b> <b>0</b> cartes postales ont &#233;t&#233; re&#231;ues &#224; ce jour, vous pourriez &#234;tre le premier contributeur ! :)"}

#----------------------
# Catalan translations
#----------------------

#@gimp_ca <b><i>About</i></b>
#----------------------------

#@gimp_ca G'MIC plug-in : gmic4gimp_logo_big_ca, gmic4gimp_logo_ca
#@gimp_ca : note = note{"
#@gimp_ca : <span foreground="purple">( <b>G</b>REYC's <b>M</b>agic <b>I</b>mage <b>C</b>onverter )</span>\n\n &#233;s una gentilesa de"}
#@gimp_ca : note = link("David Tschumperl\303\251","http://www.greyc.ensicaen.fr/~dtschump")
#@gimp_ca : note = link{"( IMAGE Team / GREYC Laboratory - CNRS UMR 6072 )","http://www.greyc.ensicaen.fr/EquipeImage"}
#@gimp_ca : note = note{"
#@gimp_ca : Aquest connector est&#224; basat en les biblioteques de codi obert <b>G'MIC</b> i <b>CImg</b> (C++ Template Image Processing Library),
#@gimp_ca : disponibles a :"}
#@gimp_ca : note = link("http://gmic.sourceforge.net/")
#@gimp_ca : note = note{"i"}
#@gimp_ca : note = link("http://cimg.sourceforge.net/")
#@gimp_ca : note = note{"\n
#@gimp_ca : Si t'agrada el <b>G'MIC</b>, pots enviar-nos una postal del lloc on vius, a :\n\n
#@gimp_ca : <small><tt>David Tschumperl&#233;,\n Laboratoire GREYC (CNRS UMR 6072), Equipe Image,\n
#@gimp_ca :  6 Bd du Mar&#233;chal Juin,\n 14050 Caen Cedex / France.</tt></small>\n\n
#@gimp_ca : Tot aquell que envi&#239; una postal apareixer&#224; al <i>Friends Hall of Fame</i> :) !
#@gimp_ca : "}
gmic4gimp_logo_ca :
  -gmic4gimp_logo "  per al GIMP"
gmic4gimp_logo_big_ca :
  -gmic4gimp_logo_ca -quantize 8 -resize2x -frame 1,1,255

#@gimp_ca Release notes : nop, gmic4gimp_logo_ca
#@gimp_ca : note = note{"
#@gimp_ca : - <b>2009/01/13</b> : versi&#243; <i>1.3.0</i> (Inicial).\n
#@gimp_ca : - <b>2009/03/18</b> : versi&#243; <i>1.3.1</i>.\n
#@gimp_ca : - <b>2009/05/07</b> : versi&#243; <i>1.3.1.4</i>.\n
#@gimp_ca : - <span foreground="purple"><b>2009/05/27</b> : versi&#243; <i>1.3.1.7</i> (Actual).</span>\n
#@gimp_ca : "}

#@gimp_ca Contributors : nop, gmic4gimp_friends_ca
#@gimp_ca : note = note{"
#@gimp_ca : Voldr&#237;em agrair tothom qui ha collaborat amb el <b>G'MIC</b> d'una manera o altra.
#@gimp_ca : Una forta abra&#231;ada a : \n\n
#@gimp_ca : <b> -</b> <i>Claude Bulin</i> <small>(empaquetat)</small>
#@gimp_ca : <b> -</b> <i>J&#233;rome Ferrari</i> <small>(proves)</small>
#@gimp_ca : <b> -</b> <i>Jalal Fadili</i> <small>(compilaci&#243;)</small>
#@gimp_ca : <b> -</b> <i>Angelo Lama</i> <small>(proves)</small>
#@gimp_ca : <b> -</b> <i>PhotoComiX</i> <small>(proves)</small>
#@gimp_ca : <b> -</b> <i>Fran&#231;ois Collard</i> <small>(proves)</small>
#@gimp_ca : <b> -</b> <i>St&#233;phane de la Linuxerie</i> <small>(disseny)</small>
#@gimp_ca : <b> -</b> <i>Dani Sard&#224;</i> <small>(traducci&#243; catalana)</small>
#@gimp_ca : <b> -</b>"}
gmic4gimp_friends_ca :
  -gmic4gimp_friends "Salutacions\n a tots els\nG'MIC friends !"

#@gimp_ca Filters design : nop, gmic4gimp_logo_ca
#@gimp_ca : note = note{"
#@gimp_ca : Si voleu podeu afegir els vostres <b>filtres d'usuari</b> al connector <b>G'MIC</b> :\n\n
#@gimp_ca : Per a fer-ho, cal que creeu un fitxer <span foreground="purple" style="italic">.gmic</span> (no oblideu el primer punt !)
#@gimp_ca : a la vostra <i>Carpeta d'inici</i> (o a la carpeta <i>Application Data</i> al Windows).
#@gimp_ca : El connector el llegir&#224; cada vegada que s'arranqui, o quan premeu el bot&#243; <i>Actualitzar els filtres</i>.
#@gimp_ca : Aquest fitxer ha de ser un arxiu de macro del <b>G'MIC</b>, i ha de contindre les definicions de filtre
#@gimp_ca : que han d'apar&#232;ixer a la llista de filtres.
#@gimp_ca : Podeu veure un exemple d'un arxiu d'aquesta mena a :"}
#@gimp_ca : note = link("http://gmic.sourceforge.net/.gmic_def")
#@gimp_ca : note = note{"
#@gimp_ca : Escriure un nou filtre amb el llenguatge <b>G'MIC</b> no &#233;s trivial del tot (per&#242; tampoc una cosa inabastable), per&#242;
#@gimp_ca : normalment es pot fer en unes quantes l&#237;nies.\n\n
#@gimp_ca : <span foreground="purple" underline="single">Example d'un fitxer <i>.gmic</i> v&#224;lid :</span>\n\n
#@gimp_ca : <tt>#@gimp My effect : my_effect, my_effect, Sigma = float(2,0,10)\n
#@gimp_ca : my_effect :\n  --blur $1 -n 0,255 -xor</tt>\n\n
#@gimp_ca : Per cert, us encoratgem a que compartiu els vostres filtres personalitzats al f&#242;rum espec&#237;fic de <b>G'MIC</b> :
#@gimp_ca : "}
#@gimp_ca : note = link("Enlla\303\247a al f\303\262rum G'MIC","http://sourceforge.net/forum/forum.php?forum_id=923318")

#@gimp_ca Filters update : nop, gmic4gimp_logo_ca
#@gimp_ca : note = note{"
#@gimp_ca : El connector <b>G'MIC</b> &#233;s capa&#231; d'<b>actualitzar</b> la seva llista de definicions de filtres
#@gimp_ca : des d'Internet. Prement el bot&#243; <i>Actualitzar els filtres</i> al plaf&#243; de l'esquerra
#@gimp_ca : fa que <b>G'MIC</b> es connecti amb el servidor d'actualitzacions
#@gimp_ca : i que descarregui les darreres definicions de filtres disponibles.\n\n
#@gimp_ca : B&#224;sicament, aquest procediment crea un fitxer
#@gimp_ca : <span foreground="purple" style="italic">.gmic_def.xxxx</span> a la vostra <i>Carpeta d'inici</i>
#@gimp_ca : (o a la carpeta <i>Application Data</i> a Windows),
#@gimp_ca : on <i>xxxx</i> s&#243;n els quatre d&#237;gits de la versi&#243; del connector <b>G'MIC</b>.
#@gimp_ca : En cas que tingueu problemes, podeu actualitzar manualment els vostres filtres, baixant-vos el fitxer d'actualitzaci&#243; des de:"}
#@gimp_ca : note = link("http://www.greyc.ensicaen.fr/~dtschump/gmic_def.xxxx")
#@gimp_ca : note = note{"
#@gimp_ca : Llavors, nom&#233;s cal que copieu i canvieu el nom d'aquest fitxer com a <span foreground="purple" style="italic">.gmic_def.xxxx</span>
#@gimp_ca : (no oblideu el primer punt, i substitu&#239;u <i>xxxx</i> per el n&#250;mero de versi&#243; del vostre <b>G'MIC</b>)
#@gimp_ca : i ja est&#224;!
#@gimp_ca : Per cert, si esborreu aquest fitxer, tornareu a establir les definicions de filtres originals.
#@gimp_ca : "}

#@gimp_ca Friends Hall of Fame : nop, gmic4gimp_friends_en
#@gimp_ca : note = note{"\n<span foreground="purple" underline="single">Qui ha enviat postals :</span>"}
#@gimp_ca : note = note{"    <b>-</b> <b>0</b> postals rebudes a dia d'avui. Anima't, podries ser el primer ! :)"}

#----------------------
# Untranslated filters
#----------------------


#@gimp _<b>Arrays &amp; frames</b>
#----------------------------------


#@gimp Regular array : array, gmic4gimp_array
#@gimp : Number of tiles along X = int(2,1,10)
#@gimp : Number of tiles along Y = int(2,1,10)
#@gimp : Image size = choice("Shrink", "Expand", "Repeat [Memory consuming !]")
gmic4gimp_array :
  -array $1,$2,0

#@gimp Faded array : array_fade, gmic4gimp_array_fade
#@gimp : Number of tiles along X = int(2,1,10)
#@gimp : Number of tiles along Y = int(2,1,10)
#@gimp : Fading start = float(80,1,100)
#@gimp : Fading end = float(90,1,100)
#@gimp : Image size = choice("Shrink", "Expand", "Repeat [Memory consuming !]")
gmic4gimp_array_fade :
  -array_fade $1,$2,$3,$4,0

#@gimp Mirrored array : array_mirror, gmic4gimp_array_mirror
#@gimp : Number of iterations = int(1,1,10)
#@gimp : Mirror mode = choice(2,"X-axis","Y-axis","XY-axes")
#@gimp : Expand size = bool(0)
gmic4gimp_array_mirror :
  -array_mirror $1,$2,0

#@gimp Image grid : grid, grid
#@gimp : Grid tile size along X = int(10,2,100)
#@gimp : Grid tile size along Y = int(10,2,100)

#@gimp Rotated tiles : gmic4gimp_rotate_tiles, gmic4gimp_rotate_tiles
#@gimp : Number of cells along X = int(5,1,80)
#@gimp : Number of cells along Y = int(5,1,80)
#@gimp : Rotation angle = float(15,0,360)
gmic4gimp_rotate_tiles :
  -to_rgba -rotate_tiles $3,$1,$2

#@gimp Normalized tiles : gmic4gimp_normalize_tiles, gmic4gimp_normalize_tiles
#@gimp : Number of cells along X = int(25,1,80)
#@gimp : Number of cells along Y = int(25,1,80)
gmic4gimp_normalize_tiles :
  -repeat @# -l[-1] -split_tiles $1,$2 -n 0,255 -append_tiles $1,$2 -endl -mv[-1] 0 -done

#@gimp Taquin puzzle : taquin, taquin
#@gimp : Number of X-subdivisions = int(7,1,20)
#@gimp : Number of Y-subdivisions = int(7,1,20)

#@gimp Random array : array_random, array_random
#@gimp : Number of source tiles along X = int(5,1,20)
#@gimp : Number of source tiles along Y = int(5,1,20)
#@gimp : Number of destination tiles along X = int(7,1,20)
#@gimp : Number of destination tiles along Y = int(7,1,20)

#@gimp Random patterns : gmic4gimp_array_pattern, gmic4gimp_array_pattern_preview
#@gimp : Number of tiles along X = int(10,1,30)
#@gimp : Number of tiles along Y = int(10,1,30)
#@gimp : Density of tiles = float(80,0,100)
#@gimp : Angle of tiles = float(180,0,180)
#@gimp : Zoom of tiles = float(30,0,100)
#@gimp : Opacity = float(1,0,1)
#@gimp : Image size = choice("Shrink", "Expand", "Repeat [Memory consuming !]")
gmic4gimp_array_pattern :
  -to_rgba -array_pattern $1,$2,$3,$4,$5,$6,0

gmic4gimp_array_pattern_preview :
  -to_rgba -array_pattern $1,$2,$3,$4,$5,$6,$7

#@gimp Shifted tiles : gmic4gimp_shift_tiles, gmic4gimp_shift_tiles
#@gimp : Number of tiles along X = int(10,1,30)
#@gimp : Number of tiles along Y = int(10,1,30)
#@gimp : Shift amplitude = float(10,0,100)
gmic4gimp_shift_tiles :
  -to_rgba -shift_tiles $1,$2,$3

#@gimp Tiles to layers : split_tiles, gmic4gimp_split_tiles
#@gimp : Number of tiles along X = int(2,1,100)
#@gimp : Number of tiles along Y = int(2,1,100)
#@gimp : Homogeneous tiles = bool(false)
gmic4gimp_split_tiles :
  -split_tiles $1,$2,$3 -k[50%]

#@gimp Regular frame : gmic4gimp_frame, gmic4gimp_frame
#@gimp : Width = int(10,0,100)
#@gimp : Height = int(10,0,100)
#@gimp : Color = color(255,255,255,0)
gmic4gimp_frame :
  -repeat @#
    ({@{-1,w}*$1/100},{@{-1,h}*$2/100}) -round[-1] 1
    -frame[-2] @-1,$3,$4,$5,$6 -rm[-1]
  -mv[-1] 0 -done

#@gimp Fuzzy frame : gmic4gimp_frame_fuzzy, gmic4gimp_frame_fuzzy
#@gimp : Width = int(10,0,99)
#@gimp : Height = int(10,0,99)
#@gimp : Fuzzyness = float(10,0,40)
#@gimp : Smoothness = float(1,0,5)
#@gimp : Color = color(255,255,255,0)
gmic4gimp_frame_fuzzy :
  -repeat @#
    ({@{-1,w}*$1/200},{@{-1,h}*$2/200}) -round[-1] 1
    -frame_fuzzy[-2] @-1,$3,$4,$5,$6,$7,$8 -rm[-1]
  -mv[-1] 0 -done

#@gimp Round frame : frame_round, frame_round
#@gimp : Roundness = float(6,0.1,20)
#@gimp : Size = float(60,0,100)
#@gimp : Smoothness = float(0.1,0,5)
#@gimp : Color = color(255,255,255,0)

#@gimp _<b>Artistic</b>
#-----------------------


#@gimp Polaroid : gmic4gimp_polaroid, gmic4gimp_polaroid
#@gimp : Frame border size = int(20,1,400)
#@gimp : Bottom border size = int(120,1,400)
#@gimp : Background size = int(20,1,400)
#@gimp : Rotation angle = float(20,0,360)
gmic4gimp_polaroid :
  -polaroid $1,$2,$3 -rotate $4,1

#@gimp Old photograph : old_photo, old_photo

#@gimp Drop shadow : gmic4gimp_drop_shadow, gmic4gimp_drop_shadow
#@gimp : Image X-offset = int(-10,-50,50)
#@gimp : Image Y-offset = int(-10,-50,50)
#@gimp : Smoothness = float(1.8,0,5)
#@gimp : Image expansion = float(170,100,250)
#@gimp : Rotation angle = float(0,0,360)
gmic4gimp_drop_shadow :
  -drop_shadow $1,$2,-$3,$4 -rotate $5,1

#@gimp Color ellipses : gmic4gimp_color_ellipses, gmic4gimp_color_ellipses
#@gimp : Number of ellipses = int(400,0,3000)
#@gimp : Maximum radius = float(16,0,100)
#@gimp : Opacity = float(0.1,0.01,0.5)
gmic4gimp_color_ellipses :
  -to_rgb -color_ellipses $1,$2,$3

#@gimp Cartoon : cartoon, cartoon
#@gimp : Edge threshold = float(30,1,70)

#@gimp Pen drawing : gmic4gimp_pen_drawing, gmic4gimp_pen_drawing
#@gimp : Amplitude = float(100,0,500)
gmic4gimp_pen_drawing :
  -to_rgb -drawing $1

#@gimp Whirl drawing : draw_whirl, draw_whirl
#@gimp : Amplitude = float(20,0,100)

#@gimp Cubism : gmic4gimp_cubism, gmic4gimp_cubism
#@gimp : Iterations = int(1000,1,3000)
#@gimp : Bloc size = float(3,0,10)
#@gimp : Maximum angle = float(90,0,360)
#@gimp : Opacity = float(0.7,0.01,1)
#@gimp : Smoothness = float(0,0,5)
gmic4gimp_cubism :
  -repeat @#
  (@{-1,w},@{-1,h}) -*[-1] $2 -/[-1] 100 -f[-1] @{-1,m} -round[-1] 1 -cubism[-2] $1,@{-1,0},$3,$4,$5 -rm[-1]
  -mv[-1] 0 -done

#@gimp Kaleidoscope : gmic4gimp_kaleidoscope, gmic4gimp_kaleidoscope
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Radius cut = float(100,0,100)
#@gimp : Angle cut = float(10,0,100)
#@gimp : Borders conditions = choice(2,"Black","Nearest","Repeat")
gmic4gimp_kaleidoscope :
  -translate $3%,$4%,0,0,2 -kaleidoscope $1,$2,$5,$6,$7

#@gimp B&amp;W stencil : stencilbw, stencilbw
#@gimp : Edge threshold = float(30,0,150)
#@gimp : Smoothness = float(10,0,30)

#@gimp B&amp;W pencil : pencilbw, pencilbw
#@gimp : Pencil type = float(0.3,0,5)
#@gimp : Amplitude = float(60,0,200)

#@gimp B&amp;W dots : dotsbw, gmic4gimp_dotsbw_preview
gmic4gimp_dotsbw_preview :
  -r 300%,300%,1,3,3 -dotsbw

#@gimp Warhol : warhol, warhol
#@gimp : Number of tiles along X = int(3,1,10)
#@gimp : Number of tiles along Y = int(3,1,10)
#@gimp : Smoothness = float(2,0,10)
#@gimp : Color = float(40,0,60)

#@gimp Soft glow : gmic4gimp_glow, gmic4gimp_glow
#@gimp : Amplitude = float(1,0,5)
gmic4gimp_glow :
  -glow -$1

#@gimp Tetris effect : gmic4gimp_tetris, gmic4gimp_tetris
#@gimp : Scale = int(10,1,20)
gmic4gimp_tetris :
  -to_rgb -tetris $1


#@gimp _<b>Colors</b>
#---------------------


#@gimp RGB mixer : gmic4gimp_mix_rgb, gmic4gimp_mix_rgb
#@gimp : Red gain = float(1,0,4)
#@gimp : Red offset = float(0,-255,255)
#@gimp : Green gain = float(1,0,4)
#@gimp : Green offset = float(0,-255,255)
#@gimp : Blue gain = float(1,0,4)
#@gimp : Blue offset = float(0,-255,255)
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
gmic4gimp_start_mix :
  -if $1==1 --norm[-1] -split_tones[-1] 3 -+[-2,-1] -blur[-2,-1] $2 -r[-2,-1] [-3] -*[-1] [-3] -mv[-3] @# -else
  -if $1==2 --norm[-1] -split_tones[-1] 3 -+[-3,-1] -blur[-2,-1] $2 -r[-2,-1] [-3] -*[-2] [-3] -mv[-3] @# -else
  -if $1==3 --norm[-1] -split_tones[-1] 3 -+[-3,-2] -blur[-2,-1] $2 -r[-2,-1] [-3] -*[-2] [-3] -mv[-3] @# -endif -endif -endif
gmic4gimp_end_mix :
  -if $1==1 -*[-3,-1] -+[-2,-1] -else
  -if $1==2 -*[-2,-1] -+[-2,-1] -else
  -if $1==3 -*[-2,-1] -+[-2,-1] -endif -endif -endif

gmic4gimp_mix_rgb :
  -repeat @# -l[-1] -split_opacity 1 -to_rgb[-1]
    -gmic4gimp_start_mix $7,$8
    --[-1] 128 -s[-1] v
    -*[-3] $1 -+[-3] $2 -*[-2] $3 -+[-2] $4 -*[-1] $5 -+[-1] $6
    -a[-3--1] v -+[-1] 128 -cut[-1] 0,255
    -gmic4gimp_end_mix $7
  -if @#!=3 -reverse -a v -endif -endl -mv[-1] 0 -done

#@gimp YCbCr mixer : gmic4gimp_mix_ycbcr, gmic4gimp_mix_ycbcr
#@gimp : Luminance gain = float(1,0,4)
#@gimp : Luminance offset = float(0,-255,255)
#@gimp : Blue chroma gain = float(1,0,4)
#@gimp : Blue chroma offset = float(0,-255,255)
#@gimp : Red chroma gain = float(1,0,4)
#@gimp : Red chroma offset = float(0,-255,255)
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
gmic4gimp_mix_ycbcr :
  -repeat @# -l[-1] -split_opacity 1 -to_rgb[-1]
    -gmic4gimp_start_mix $7,$8
    -rgb2ycbcr[-1] --[-1] 128 -s[-1] v
    -*[-3] $1 -+[-3] $2 -*[-2] $3 -+[-2] $4 -*[-1] $5 -+[-1] $6
    -a[-3--1] v -+[-1] 128 -cut[-1] 0,255 -ycbcr2rgb[-1]
    -gmic4gimp_end_mix $7
  -if @#!=3 -reverse -a v -endif -endl -mv[-1] 0 -done

#@gimp HSV mixer : gmic4gimp_mix_hsv, gmic4gimp_mix_hsv
#@gimp : Hue gain = float(1,0,4)
#@gimp : Hue offset = float(0,-180,180)
#@gimp : Saturation gain = float(1,0,4)
#@gimp : Saturation offset = float(0,-1,1)
#@gimp : Value gain = float(1,0,4)
#@gimp : Value offset = float(0,-1,1)
#@gimp : Tones range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gimp : Tones smoothness = float(2,0,10)
gmic4gimp_mix_hsv :
  -repeat @# -l[-1] -split_opacity 1 -to_rgb[-1]
    -gmic4gimp_start_mix $7,$8
    -rgb2hsv[-1] -s[-1] v --[-2,-1] 0.5
    -*[-3] $1 -+[-3] $2 -*[-2] $3 -+[-2] $4 -*[-1] $5 -+[-1] $6
    -mod[-3] 360 -+[-2,-1] 0.5 -cut[-2,-1] 0,1 -a[-3--1] v -hsv2rgb[-1]
    -gmic4gimp_end_mix $7
  -if @#!=3 -reverse -a v -endif -endl -mv[-1] 0 -done

#@gimp Black &amp; White : gmic4gimp_blackandwhite, gmic4gimp_blackandwhite
#@gimp : Red level = float(0.299,0,1)
#@gimp : Green level = float(0.587,0,1)
#@gimp : Blue level = float(0.114,0,1)
#@gimp : Contrast = float(1,0,4)
#@gimp : Brightness = float(0,-255,255)
#@gimp : Grain level (shadows) = float(0,0,200)
#@gimp : Grain level (midtones) = float(0,0,200)
#@gimp : Grain level (highlights) = float(0,0,200)
#@gimp : Grain tone fading = float(2,0,10)
#@gimp : Grain scale = float(0,0,3)
#@gimp : Grain type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
gmic4gimp_blackandwhite :
  -repeat @# -l[-1] -split_opacity 1 -to_rgb[-1] -s[-1] v
    -*[-3] $1 -*[-2] $2 -*[-1] $3 -+[-3--1]
    ($1) -+[-1] $2 -+[-1] $3 -/[-2] @-1 -rm[-1]
    --[-1] 128 -*[-1] $4 -+[-1] 128 -+[-1] $5 -cut[-1] 0,255
    --split_tones[-1] 3 -a[-3--1] v -blur[-1] $7
    --f[-2] 1 -noise[-1] 100,$11 -blur[-1] $10 --n[-1] -$7,$7 --n[-2] -$8,$8 -n[-3] -$6,$6 -a[-3--1] v -*[-2,-1]
    -s[-1] v -+[-4--1] -cut[-1] 0,255
  -if @#!=1 -reverse -a v -endif -endl -mv[-1] 0 -done

#@gimp B&amp;W dithering : ditheredbw, ditheredbw

#@gimp Select color : gmic4gimp_select_color, gmic4gimp_select_color
#@gimp : Similarity space = choice(0,"RGB[A]","YCbCr","Red","Green","Blue","Opacity","Luminance","Blue & Red chrominances","Hue","Saturation")
#@gimp : Tolerance = float(20,0,100)
#@gimp : Selected color = color(255,255,255,255)
#@gimp : Invert selection = bool(0)
_gmic4gimp_select_color :
  -if $1==1 -to_rgb -rgb2ycbcr -return -endif
  -if $1==2 -to_rgb -rgb2hsv -repeat @# -s[-1] v -n[-3--1] 0,255 -a[-3--1] v -mv[-1] 0 -done -return -endif
  -if $1==3 -to_rgb -channels 1 -return -endif
  -if $1==4 -to_rgb -channels 2 -return -endif
  -if $1==5 -to_rgba -channels 3 -return -endif
  -if $1==6 -to_rgb -rgb2ycbcr -channels 0 -endif
  -if $1==7 -to_rgb -rgb2ycbcr -channels 1,2 -endif
  -if $1==8 -to_rgb -rgb2hsv -channels 0 -/ 180 -* 3.1415926 -sin -n 0,255 -endif
  -if $1==9 -to_rgb -rgb2hsv -channels 1 -n 0,255 -endif

gmic4gimp_select_color :
  ($3^$4^$5^$6) -_gmic4gimp_select_color $1
  -select_color[0--1] $2%,@-1 -rm[-1]
  -if $7 -* -1 -+ 1 -endif
  -n 0,255

#@gimp Replace color : gmic4gimp_replace_color, gmic4gimp_replace_color
#@gimp : Tolerance = float(100,1,450)
#@gimp : Smoothness = float(0,0,10)
#@gimp : Selected color = color(255,255,255,255)
#@gimp : Replace color = color(0,0,0,0)
gmic4gimp_replace_color :
  -to_rgba -replace_color $1,$2%,${3*} -cut 0,255

#@gimp User-defined : gmic4gimp_custom_transform, gmic4gimp_custom_transform
#@gimp : RGBA formula = text{"i + 90*(x/w)*cos(i/10)"}
#@gimp : Red formula = text{"i"}
#@gimp : Green formula = text{"i"}
#@gimp : Blue formula = text{"i"}
#@gimp : Opacity formula = text{"i"}
#@gimp : Value normalization = bool(0)
gmic4gimp_custom_transform :
  -to_rgba -repeat @#
    -f[-1] $1 -s[-1] v -f[-4] $2 -f[-3] $3 -f[-2] $4 -f[-1] $5 -a v
  -mv[-1] 0 -done
  -if $6 -n 0,255 -else -cut 0,255 -endif


#@gimp _<b>Contours</b>
#----------------------


#@gimp Gradient norm : gmic4gimp_gradient_norm, gmic4gimp_gradient_norm
#@gimp : Smoothness = float(0,0,5)
#@gimp : Edge threshold = float(30,1,70)
#@gimp : Use threshold = bool(0)
#@gimp : Negative colors = bool(0)
gmic4gimp_gradient_norm :
  -blur $1% -gradient_norm -if $3 -threshold $2% -endif -n 0,255 -if $4 -negative -endif

#@gimp Gradient as RGB : gmic4gimp_gradient2rgb, gmic4gimp_gradient2rgb
#@gimp : Smoothness = float(0,0,5)
#@gimp : Orientation only = bool(0)
#@gimp : Negative colors = bool(0)
gmic4gimp_gradient2rgb :
  -blur $1% -gradient2rgb $2 -n 0,255 -if $3 -negative -endif

#@gimp Local orientation : gmic4gimp_local_orientation gmic4gimp_local_orientation
#@gimp : Smoothness = float(0,0,5)
gmic4gimp_local_orientation :
  -blur $1% -norm -gradient_orientation 2 -complex2polar -rm[0--1:2] -n 0,255

#@gimp Laplacian : gmic4gimp_laplacian, gmic4gimp_laplacian
#@gimp : Smoothness = float(0,0,5)
#@gimp : Absolute value = bool(0)
#@gimp : Negative colors = bool(0)
gmic4gimp_laplacian :
  -blur $1% -laplacian -if $2 -abs -endif -n 0,255 -if $3 -negative -endif

#@gimp Curvature : gmic4gimp_curvature, gmic4gimp_curvature
#@gimp : Smoothness = float(2,0,5)
#@gimp : Absolute value = bool(0)
#@gimp : Negative colors = bool(0)
gmic4gimp_curvature :
  -blur $1% -curvature -if $2 -abs -endif -n 0,255 -if $3 -negative -endif

#@gimp Edges : gmic4gimp_edges, gmic4gimp_edges
#@gimp : Edge threshold = float(30,1,70)
#@gimp : Smoothness = float(0,0,2)
#@gimp : Negative colors = bool(0)
gmic4gimp_edges :
  -to_rgb -blur $2% -edges $1 -n 0,255 -if $3 -negative -endif

#@gimp Difference of Gaussians : gmic4gimp_dog, gmic4gimp_dog
#@gimp : 1st Variance = float(1.4,0,5)
#@gimp : 2nd Variance = float(1.5,0,5)
#@gimp : Negative colors = bool(0)
gmic4gimp_dog :
  -dog $1%,$2% -n 0,255 -if $3 -negative -endif



#@gimp _<b>Deformations</b>
#--------------------------


#@gimp Water : water, water
#@gimp : Amplitude = float(30,0,300)
#@gimp : Smoothness = float(1.5,0,4)

#@gimp Water reflection : gmic4gimp_reflect, gmic4gimp_reflect
gmic4gimp_reflect :
  -to_rgb -reflect

#@gimp Wave : wave, wave
#@gimp : Amplitude = float(10,0,30)
#@gimp : Frequency = float(0.4,0,2)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)

#@gimp Twirl : twirl, twirl
#@gimp : Amplitude = float(1,-5,5)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Borders conditions = choice(1,"Black","Nearest","Repeat")

#@gimp Flower : gmic4gimp_flower, gmic4gimp_flower
#@gimp : Amplitude = float(30,-100,100)
#@gimp : Number of petals = int(6,0,20)
#@gimp : Radius offset = float(0,0,100)
#@gimp : Angle = float(0,0,360)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Borders conditions = choice(2,"Black","Nearest","Repeat")
gmic4gimp_flower :
  -flower $1,$2,$3%,$4,$5,$6,$7

#@gimp Random : deform, deform
#@gimp : Amplitude = float(10,0,100)

#@gimp Fish-eye : fish_eye, fish_eye
#@gimp : Amplitude = float(50,0,100)

#@gimp Perspective : gmic4gimp_warp_perspective, gmic4gimp_warp_perspective
#@gimp : X-angle = float(1.73,-4,4)
#@gimp : Y-angle = float(0,-4,4)
#@gimp : Zoom = float(1,0.1,4)
#@gimp : X-center = float(50,0,100)
#@gimp : Y-center = float(50,0,100)
#@gimp : X-offset = float(0,0,100)
#@gimp : Y-offset = float(0,0,100)
#@gimp : Borders conditions = choice(2,"Black","Nearest","Repeat")
gmic4gimp_warp_perspective :
  -translate $6%,$7%,0,0,2 -warp_perspective $1,$2,$3,$4,$5,$8

#@gimp Euclidean to polar : gmic4gimp_euclidean2polar, gmic4gimp_euclidean2polar
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Dilatation = float(1,0.1,10)
#@gimp : Borders conditions = choice(1,"Black","Nearest","Repeat")
#@gimp : Inverse transform = bool(0)
gmic4gimp_euclidean2polar :
  -if $5 -polar2euclidean $1,$2,$3,$4 -else -euclidean2polar $1,$2,$3,$4 -endif

#@gimp User-defined : gmic4gimp_custom_deformation, gmic4gimp_custom_deformation_preview
#@gimp : X-warping formula = text{"(w+h)/20*cos(y*20/h)"}
#@gimp : Y-warping formula = text{"(w+h)/20*sin(x*20/w)"}
#@gimp : Relative warping = bool(1)
#@gimp : Interpolation mode = choice(1,"Nearest neighbor","Linear")
#@gimp : Border conditions = choice(1,"Black","Nearest","Repeat")
#@gimp : Number of warping frames = int(1,1,100)
gmic4gimp_custom_deformation :
   -repeat @#
    --norm[-1] [-1] -f[-2] $1 -f[-1] $2
    -a[-2,-1] v -warp[-2] [-1],$3,$4,$5,$6 -rm[-1]
  -mv[-1] 0 -done

gmic4gimp_custom_deformation_preview :
  -gmic4gimp_custom_deformation $1,$2,$3,$4,$5,1


#@gimp _<b>Degradations</b>
#---------------------------


#@gimp Additive noise : gmic4gimp_noise, gmic4gimp_noise
#@gimp : Amplitude = float(10,0,200)
#@gimp : Noise type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
#@gimp : Value range = choice("Cut","Normalize")
#@gimp : Channels = choice(1,"RGB[A]","Luminance","Blue & Red chrominances","Blue chrominance","Red chrominance")
gmic4gimp_noise0 :
  -noise $1,$2
gmic4gimp_noise1 :
  -to_rgb -repeat @# -rgb2ycbcr[-1] -s[-1] v -noise[-3] $1,$2 -a[-3--1] v -ycbcr2rgb[-1] -mv[-1] 0 -done
gmic4gimp_noise2 :
  -to_rgb -repeat @# -rgb2ycbcr[-1] -s[-1] v -noise[-2,-1] $1,$2 -a[-3--1] v -ycbcr2rgb[-1] -mv[-1] 0 -done
gmic4gimp_noise3 :
  -to_rgb -repeat @# -rgb2ycbcr[-1] -s[-1] v -noise[-2] $1,$2 -a[-3--1] v -ycbcr2rgb[-1] -mv[-1] 0 -done
gmic4gimp_noise4 :
  -to_rgb -repeat @# -rgb2ycbcr[-1] -s[-1] v -noise[-1] $1,$2 -a[-3--1] v -ycbcr2rgb[-1] -mv[-1] 0 -done
gmic4gimp_noise :
  -gmic4gimp_noise$4 $1,$2 -if $3 -n 0,255 -else -cut 0,255 -endif

#@gimp Spread noise : gmic4gimp_spread, gmic4gimp_spread
#@gimp : Variations along X = float(4,0,20)
#@gimp : Variations along Y = float(4,0,20)
#@gimp : Channels = choice(1,"RGB[A]","Luminance","Blue & Red chrominances","Blue chrominance","Red chrominance")
gmic4gimp_spread0 :
  -spread $1,$2
gmic4gimp_spread1 :
  -to_rgb -repeat @# -rgb2ycbcr[-1] -s[-1] v -spread[-3] $1,$2 -a[-3--1] v -ycbcr2rgb[-1] -mv[-1] 0 -done
gmic4gimp_spread2 :
  -to_rgb -repeat @# -rgb2ycbcr[-1] -s[-1] v -spread[-2,-1] $1,$2 -a[-3--1] v -ycbcr2rgb[-1] -mv[-1] 0 -done
gmic4gimp_spread3 :
  -to_rgb -repeat @# -rgb2ycbcr[-1] -s[-1] v -spread[-2] $1,$2 -a[-3--1] v -ycbcr2rgb[-1] -mv[-1] 0 -done
gmic4gimp_spread4 :
  -to_rgb -repeat @# -rgb2ycbcr[-1] -s[-1] v -spread[-1] $1,$2 -a[-3--1] v -ycbcr2rgb[-1] -mv[-1] 0 -done
gmic4gimp_spread :
  -gmic4gimp_spread$3 $1,$2

#@gimp Random shade stripes : shade_stripes, shade_stripes
#@gimp : Frequency = float(30,1,100)
#@gimp : Stripes orientation = choice(1,"Horizontal","Vertical")
#@gimp : Darkness = float(0.8,0,3)
#@gimp : Lightness = float(1.3,0,3)

#@gimp Old-movie stripes : stripes_y, stripes_y
#@gimp : Frequency = float(10,0,100)

#@gimp Damp patch : damp_patch, damp_patch
#@gimp : Opacity = float(0.7,0,1)

#@gimp Light patch : light_patch, light_patch
#@gimp : Density = int(5,2,30)
#@gimp : Darkness = float(0.7,0,1)
#@gimp : Lightness = float(2.5,1,4)

#@gimp Linear blur : gmic4gimp_blur_linear, gmic4gimp_blur_linear
#@gimp : Tangent amplitude = float(0.07,0.01,0.5)
#@gimp : Orthogonal amplitude = float(0.01,0.005,0.1)
#@gimp : Angle = float(0,0,180)
#@gimp : Border conditions = choice(1,"Black","Nearest")
#@gimp : Value normalization = bool(0)
gmic4gimp_blur_linear :
  -blur_linear $1,$2,$3,$4 -if $5 -n 0,255 -endif

#@gimp Radial blur : gmic4gimp_blur_radial, gmic4gimp_blur_radial
#@gimp : Amplitude = float(3,0,20)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Value normalization = bool(0)
gmic4gimp_blur_radial :
  -blur_radial -$1,$2,$3 -if $4 -n 0,255 -endif

#@gimp Angular blur : gmic4gimp_blur_angular, gmic4gimp_blur_angular
#@gimp : Amplitude = float(2,0,10)
#@gimp : X-center = float(0.5,0,1)
#@gimp : Y-center = float(0.5,0,1)
#@gimp : Value normalization = bool(0)
gmic4gimp_blur_angular :
  -blur_angular -$1,$2,$3 -if $4 -n 0,255 -endif

#@gimp RGB Bayer mask : rgb2bayer, rgb2bayer
#@gimp : Starting pattern = choice(0,"Red-Green","Blue-Green","Green-Red","Green-Blue")
#@gimp : Keep colors = bool(1)


#@gimp _<b>Enhancement</b>
#--------------------------


#@gimp Anisotropic smoothing : gmic4gimp_anisotropic_filter, gmic4gimp_anisotropic_filter
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Sharpness = float(0.7,0,2)
#@gimp : Anisotropy = float(0.3,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : Spatial precision = float(0.8,0.1,2)
#@gimp : Angular precision = float(30,1,180)
#@gimp : Value precision = float(2,0.1,5)
#@gimp : Interpolation type = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gimp : Fast approximation = bool(1)
#@gimp : Number of iterations = int(1,1,10)
#@gimp : Channels processing = choice("RGB[A]","Luminance","Blue & Red chrominances","Blue chrominance","Red chrominance")
#@gimp : Tile subdivisions = int(1,1,10)
#@gimp : note = note{"\n<small><b>Note : </b>This filter is a part of the <b>GREYCstoration</b> framework :</small>"}
#@gimp : note = link("http://cimg.sourceforge.net/greycstoration/")

# RGB[A] version
gmic4gimp_anisotropic_filter0 :
  -repeat @# -l[@{>,-1}]
     -split_tiles $12,$12 -repeat $11 -smooth $1,$2,$3,$4,$5,$6,$7,$8,$9,$10 -done -append_tiles $12,$12 -cut 0,255
  -endl -done

# Luminance version
gmic4gimp_anisotropic_filter1 :
  -repeat @# -l[@{>,-1}]
    -split_opacity 1 -rgb2ycbcr[-1] -s[-1] v
    -repeat $11 -smooth[-3] $1,$2,$3,$4,$5,$6,$7,$8,$9,$10 -done
    -a[-3--1] v -ycbcr2rgb[-1] -cut[-1] 0,255 -reverse -a v
  -endl -done

# Chrominance version
gmic4gimp_anisotropic_filter2 :
  -repeat @# -l[@{>,-1}]
    -split_opacity 1 -rgb2ycbcr[-1] -s[-1] v
    -repeat $11 -smooth[-2,-1] $1,$2,$3,$4,$5,$6,$7,$8,$9,$10 -done
    -a[-3--1] v -ycbcr2rgb[-1] -cut[-1] 0,255 -reverse -a v
  -endl -done

# Blue chrominance version
gmic4gimp_anisotropic_filter3 :
  -repeat @# -l[@{>,-1}]
    -split_opacity 1 -rgb2ycbcr[-1] -s[-1] v
    -repeat $11 -smooth[-2] $1,$2,$3,$4,$5,$6,$7,$8,$9,$10 -done
    -a[-3--1] v -ycbcr2rgb[-1] -cut[-1] 0,255 -reverse -a v
  -endl -done

# Red chrominance version
gmic4gimp_anisotropic_filter4 :
  -repeat @# -l[@{>,-1}]
    -split_opacity 1 -rgb2ycbcr[-1] -s[-1] v
    -repeat $11 -smooth[-1] $1,$2,$3,$4,$5,$6,$7,$8,$9,$10 -done
    -a[-3--1] v -ycbcr2rgb[-1] -cut[-1] 0,255 -reverse -a v
  -endl -done

# Generic version
gmic4gimp_anisotropic_filter :
  -gmic4gimp_anisotropic_filter$12 $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$13

#@gimp Patch-based smoothing : gmic4gimp_patch_filter, gmic4gimp_patch_filter
#@gimp : Spatial variance = float(10,0.1,200)
#@gimp : Patch variance = float(10,0.1,200)
#@gimp : Patch size = int(3,2,21)
#@gimp : Lookup size = int(5,2,21)
#@gimp : Patch smoothness = float(0,0,4)
#@gimp : Fast approximation = bool(1)
#@gimp : Number of iterations = int(1,1,10)
#@gimp : Channels processing = choice("RGB[A]","Luminance","Blue & Red chrominances","Blue chrominance","Red chrominance")
#@gimp : note = note{"\n<small><b>Note : </b>This filter is a part of the <b>GREYCstoration</b> framework :</small>"}
#@gimp : note = link("http://cimg.sourceforge.net/greycstoration/")

# RGB[A] version
gmic4gimp_patch_filter0 :
  -repeat @# -l[@{>,-1}]
    -repeat $7 -denoise $1,$2,$3,$4,$5,$6 -done -cut 0,255
  -endl -done

# Luminance version
gmic4gimp_patch_filter1 :
  -repeat @# -l[@{>,-1}]
    -split_opacity 1 -rgb2ycbcr[-1] -s[-1] v
    -repeat $7 -denoise[-3] $1,$2,$3,$4,$5,$6 -done
    -a[-3--1] v -ycbcr2rgb[-1] -cut[-1] 0,255 -reverse -a v
  -endl -done

# Chrominance version
gmic4gimp_patch_filter2 :
  -repeat @# -l[@{>,-1}]
    -split_opacity 1 -rgb2ycbcr[-1] -s[-1] v
    -repeat $7 -denoise[-2,-1] $1,$2,$3,$4,$5,$6 -done
    -a[-3--1] v -ycbcr2rgb[-1] -cut[-1] 0,255 -reverse -a v
  -endl -done

# Blue chrominance version
gmic4gimp_patch_filter3 :
  -repeat @# -l[@{>,-1}]
    -split_opacity 1 -rgb2ycbcr[-1] -s[-1] v
    -repeat $7 -denoise[-2] $1,$2,$3,$4,$5,$6 -done
    -a[-3--1] v -ycbcr2rgb[-1] -cut[-1] 0,255 -reverse -a v
  -endl -done

# Red chrominance version
gmic4gimp_patch_filter4 :
  -repeat @# -l[@{>,-1}]
    -split_opacity 1 -rgb2ycbcr[-1] -s[-1] v
    -repeat $7 -denoise[-1] $1,$2,$3,$4,$5,$6 -done
    -a[-3--1] v -ycbcr2rgb[-1] -cut[-1] 0,255 -reverse -a v
  -endl -done

# Generic version
gmic4gimp_patch_filter :
  -gmic4gimp_patch_filter$8 $1,$2,$3,$4,$5,$6,$7

#@gimp Edge-preserving flow : gmic4gimp_edgepreserving_flow, gmic4gimp_edgepreserving_flow
#@gimp : Sharpness = float(0.7,0,2)
#@gimp : Anisotropy = float(0.3,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : Time step = float(15,5,50)
#@gimp : Number of iterations = int(8,1,100)
gmic4gimp_edgepreserving_flow :
  -smooth $6,$1,$2,$3,$4,$5,0 -cut 0,255

#@gimp Mean-curvature flow : gmic4gimp_meancurvature_flow, gmic4gimp_meancurvature_flow
#@gimp : Time step = float(30,5,50)
#@gimp : Number of iterations = int(4,1,10)
#@gimp : Keep iterations as different layers = bool(false)
gmic4gimp_meancurvature_flow :
  -meancurvature_flow $2,$1,$3 -cut 0,255

#@gimp Total-variation flow : gmic4gimp_tv_flow, gmic4gimp_tv_flow
#@gimp : Time step = float(30,5,100)
#@gimp : Number of iterations = int(10,1,40)
#@gimp : Keep iterations as different layers = bool(false)
gmic4gimp_tv_flow :
  -tv_flow $2,$1,$3 -cut 0,255

#@gimp Bilateral filtering : gmic4gimp_bilateral, gmic4gimp_bilateral
#@gimp : Spatial variance = float(10,0,100)
#@gimp : Value variance = float(7,0,100)
#@gimp : Number of iterations = int(2,1,10)
gmic4gimp_bilateral :
  -repeat @# -l[@{>,-1}]
    -repeat $3 -bilateral $1,$2 -done
  -endl -done

#@gimp Unsharp mask : gmic4gimp_unsharp, gmic4gimp_unsharp
#@gimp : Radius = float(0.25,0,2)
#@gimp : Amount = float(3,0,10)
#@gimp : Threshold = float(0,0,20)
#@gimp : Darkness level = float(1,0,4)
#@gimp : Lightness level = float(1,0,4)
#@gimp : Number of iterations = int(1,1,10)
#@gimp : Negative effect = bool(0)
#@gimp : Monochrome = bool(1)
#@gimp : note = note{"\n\n<small><b>Note : </b>
#@gimp : This filter is inspired by the original <i>Unsharp Mask</i> filter in GIMP, with additional parameters.
#@gimp : </small>"}
gmic4gimp_unsharp :
  -repeat @# -repeat $6
    --blur[-1] $1% --[-1] [-2] -*[-1] -$2
    --norm[-1] -threshold[-1] $3% -r[-1] [-2] -*[-2,-1]
    -if $7 -*[-1] -1 -endif
    --cut[-1] 0,100% -cut[-2] -100%,0 -*[-2] $4 -*[-1] $5 -+[-2,-1]
    -if $8 -l[-1] -s v (@#) -+[0--2] -/[-2] @-1 -rm[-1] -endl -r[-1] [-2] -endif
    -+[-2,-1] -cut[-1] 0,255
  -done -mv[-1] 0 -done

#@gimp Inverse diffusion : gmic4gimp_sharpen_inversediff, gmic4gimp_sharpen_inversediff
#@gimp : Amplitude = float(50,1,300)
#@gimp : Number of iterations = int(2,1,10)
gmic4gimp_sharpen_inversediff :
  -repeat $2 -sharpen $1,0 -cut 0,255 -done

#@gimp Shock filters : gmic4gimp_sharpen_shock, gmic4gimp_sharpen_shock
#@gimp : Amplitude = float(150,1,400)
#@gimp : Edge threshold = float(0.1,0,0.7)
#@gimp : Gradient smoothness = float(0.8,0,10)
#@gimp : Tensor smoothness = float(1.1,0,10)
#@gimp : Number of iterations = int(1,1,10)
gmic4gimp_sharpen_shock :
  -repeat $5 -sharpen $1,1,$2,$3,$4 -cut 0,255 -done

#@gimp Region inpainting : gmic4gimp_inpaint, gmic4gimp_inpaint_preview
#@gimp : Use smooth inpaint = bool(true)
#@gimp : Number of global iterations = int(10,1,30)
#@gimp : Number of local iterations = int(10,1,30)
#@gimp : Time step = float(20,5,50)
#@gimp : Gradient smoothness = float(0.7,0,5)
#@gimp : Tensor smoothness = float(1.2,0,5)
#@gimp : note = note("<small><b>Note :</b>
#@gimp : This filter tries to reconstruct the content of image regions.
#@gimp : The inpainted region is defined as a white area in the top layer.
#@gimp : </small>")
gmic4gimp_inpaint :
  -if @#==1 -return -endif
  -if $1 -inpaint_flow $2,$3,$4,-$5,-$6 -cut 0,255 -else -inpaint[1--1] [0] -endif
  -to_rgba[0] -f[0] 0

gmic4gimp_inpaint_preview :
  -if @#==1 -return -endif
  -gmic4gimp_inpaint $* -rm[0]

#@gimp Deinterlace : deinterlace, gmic4gimp_deinterlace
#@gimp : Algorithm = choice("Standard","Motion-compensated")
gmic4gimp_deinterlace :
  -deinterlace 0 -skip $*

#@gimp Red-Eye attenuation : red_eye, red_eye
#@gimp : Detection threshold = float(75,0,100)
#@gimp : Detection smoothness = float(3.5,0,20)
#@gimp : Attenuation factor = float(0.1,0,1)

#@gimp Scale2x algorithm : gmic4gimp_scalenx, gmic4gimp_scalenx_preview
#@gimp : Scaling factor = choice("x 2","x 3","x 4","x 6","x 8","x 9","x 12","x 16","x 18","x 27")
#@gimp : note = note{"\n<small><b>Note : </b>
#@gimp : This filter re-implements the scaling algorithm described at :
#@gimp : </small>"}
#@gimp : note = link("http://scale2x.sourceforge.net")
#@gimp : note = note{"<small>
#@gimp : This filter is useful for resizing images that have very few colors
#@gimp : (e.g. indexed images). It is generally useless for true colors images.
#@gimp : </small>"}
gmic4gimp_scalenx :
  -if $1==0 -resize2x -else
  -if $1==1 -resize3x -else
  -if $1==2 -resize2x -resize2x -else
  -if $1==3 -resize3x -resize2x -else
  -if $1==4 -resize2x -resize2x -resize2x -else
  -if $1==5 -resize3x -resize3x -else
  -if $1==6 -resize3x -resize2x -resize2x -else
  -if $1==7 -resize2x -resize2x -resize2x -resize2x -else
  -if $1==8 -resize3x -resize3x -resize2x -else
  -if $1==9 -resize3x -resize3x -resize3x
  -endif -endif -endif -endif -endif
  -endif -endif -endif -endif -endif

gmic4gimp_scalenx_preview :
  -crop 40%,40%,60%,60% -gmic4gimp_scalenx $1


#@gimp _<b>Layers</b>
#---------------------


#@gimp Average : compose_average, compose_average
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Multiply : compose_multiply, compose_multiply
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Screen : compose_screen, compose_screen
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Darken : compose_darken, compose_darken
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Lighten : compose_lighten, compose_lighten
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Difference : compose_difference, compose_difference
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Negation : compose_negation, compose_negation
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Exclusion : compose_exclusion, compose_exclusion
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Overlay : compose_overlay, compose_overlay
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Hard light : compose_hardlight, compose_hardlight
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Soft light : compose_softlight, compose_softlight
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Dodge : compose_dodge, compose_dodge
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Color burn : compose_colorburn, compose_colorburn
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Reflect : compose_reflect, compose_reflect
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Freeze : compose_freeze, compose_freeze
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Stamp : compose_stamp, compose_stamp
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Interpolation : compose_interpolation, compose_interpolation
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp XOR : compose_xor, compose_xor
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Edges merging : compose_edges, compose_edges
#@gimp : Smoothness = float(0.8,0,5)
#@gimp : Note = note{"<small><b>Note :</b>
#@gimp : This filter needs two layers to work properly. Set also the <i>Filter input</i> option below, to handle multiple input layers.
#@gimp : </small>"}

#@gimp Layers alignment : gmic4gimp_align_layers, gmic4gimp_align_layers_preview
#@gimp : Alignment type = choice(0,"Rigid","Non-rigid")
#@gimp : Smoothness = float(0.7,0,1)
#@gimp : Number of scales = choice(0,"Auto","1","2","3","4","5","6","7","8")
gmic4gimp_align_layers :
  -remove_opacity
  -if $1 -register_nonrigid $2,0.1,$3
  -else ($2) -*[-1] 3 -register_rigid[0--2] @-1 -rm[-1]
  -endif

gmic4gimp_align_layers_preview :
  -gmic4gimp_align_layers $1,$2,0 -compose_edges 0.1

#@gimp Layers morphing : gmic4gimp_morph, gmic4gimp_no_preview
#@gimp : Number of intra-frames = int(10,2,100)
#@gimp : Smoothness = float(0.2,0,2)
#@gimp : Precision = float(0.1,0,2)
gmic4gimp_morph :
  -to_rgb -morph $1,$2,$3


#@gimp _<b>Patterns</b>
#-----------------------


#@gimp Random puzzle : puzzle, puzzle
#@gimp : Scale = float(10,1,20)

#@gimp Mosaic pattern : mosaic, mosaic
#@gimp : Density = float(2,0.1,10)

#@gimp Whirls texture : whirls, whirls
#@gimp : Density = int(7,3,20)
#@gimp : Smoothness = float(2,0,10)
#@gimp : Darkness = float(0.2,0,1)
#@gimp : Lightness = float(1.8,1,3)

#@gimp Paper texture : paper_texture, paper_texture

#@gimp Hearts : hearts, hearts
#@gimp : Density = float(10,0,100)

#@gimp Sponge effect : sponge, sponge
#@gimp : Sponge size = int(13,3,21)


#@gimp _<b>Presets</b>
#----------------------


#@gimp PhotoComiX smoothing : gmic4gimp_anisotropic_filter, gmic4gimp_anisotropic_filter
#@gimp : Amplitude = float(60,0,1000)
#@gimp : Edge preservation = float(0.16,0,2)
#@gimp : Anisotropy = float(0.63,0,1)
#@gimp : Gradient smoothness = float(0.6,0,10)
#@gimp : Tensor smoothness = float(2.35,0,10)
#@gimp : Spatial precision = float(0.8,0.1,2)
#@gimp : Angular precision = float(30,1,180)
#@gimp : Value precision = float(2,0.1,5)
#@gimp : Interpolation type = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gimp : Fast gaussian approximation = bool(1)
#@gimp : Number of iterations = int(1,1,10)
#@gimp : Channels processing = choice("RGB","Luminance","Blue & Red chrominances","Blue chrominance","Red chrominance")
#@gimp : Tile subdivisions = int(1,1,10)
#@gimp : note = note{"\n<small><b>Note : </b>This set of anisotropic smoothing parameters has been suggested by PhotoComiX.</small>"}


#@gimp _<b>Rendering</b>
#------------------------


#@gimp 3D elevation [static] : gmic4gimp_elevation, gmic4gimp_elevation_preview
#@gimp : Rendering width = int(512,8,1024)
#@gimp : Rendering height = int(512,8,1024)
#@gimp : Value scale = float(0.05,-0.2,0.2)
#@gimp : Map smoothness = float(1,0,10)
#@gimp : X-angle = float(50,-90,90)
#@gimp : Y-angle = float(0,0,360)
#@gimp : Zoom = float(1,0.1,4)
#@gimp : Rendering type = choice(4,"Points","Lines","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Opacity = float(1,0,1)
#@gimp : Focale = float(500,100,800)
#@gimp : note = note{"<small><b>Note :</b>
#@gimp : Use two input layers to define an elevation map that is different from
#@gimp : the image itself.
#@gimp : </small>"}
gmic4gimp_elevation :
  -if @#==0 -q -endif
  -if @#==1 --norm -else -k[0,1] -reverse -endif
  -to_rgb[0] -norm[1] -blur[1] $4 -*[1] $3 -r $1,$2,1,-100,3 -elevation3d[0] [1] -rm[1]
  -c3d -rot3d 0,0,1,$6 -rot3d 1,0,0,$5 -*3d $7 -r3d $8 -f3d $10
  $1,$2,1,4,-1 -object3d[-1] [0],50%,50%,0,$9 -rm[0]
  -s v -threshold[-1] 0 -*[-1] 255 -a v

gmic4gimp_elevation_preview :
  -if @#==0 -q -endif
  -gmic4gimp_elevation @{-1,w},@{-1,h},$3,$4,$5,$6,$7,$8,$9,$10

#@gimp 3D elevation [animated] : gmic4gimp_elevation_anim, gmic4gimp_elevation_anim_preview
#@gimp : Rendering width = int(512,8,1024)
#@gimp : Rendering height = int(512,8,1024)
#@gimp : Value scale = float(0.05,-0.2,0.2)
#@gimp : Map smoothness = float(1,0,10)
#@gimp : X-angle = float(50,-90,90)
#@gimp : Rotation step = float(5,1,90)
#@gimp : Zoom = float(1,0.1,4)
#@gimp : Rendering type = choice(4,"Points","Lines","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Opacity = float(1,0,1)
#@gimp : Focale = float(500,100,800)
#@gimp : Number of frames = int(10,1,360)
#@gimp : note = note{"<small><b>Note :</b>
#@gimp : Use two input layers to define an elevation map that is different from
#@gimp : the image itself.
#@gimp : </small>"}
gmic4gimp_elevation_anim :
  -if @#==0 -q -endif
  -if @#==1 --norm -else -k[0,1] -reverse -endif
  -to_rgb[0] -norm[1] -blur[1] $4 -*[1] $3 -r $1,$2,1,-100,3 -elevation3d[0] [1] -rm[1]
  -c3d -*3d $7 -r3d $8 -f3d $10
  -repeat $11
    --rot3d[0] 1,0,0,$5
    $1,$2,1,4,-1 -object3d[-1] [-2],50%,50%,0,$9 -rm[-2]
    -s[-1] v -threshold[-1] 0 -*[-1] 255 -a[-4--1] v
    -rot3d[0] 0,0,1,$6
  -done -rm[0]

gmic4gimp_elevation_anim_preview :
  -if @#==0 -q -endif
  -gmic4gimp_elevation_preview @{-1,w},@{-1,h},$3,$4,$5,0,$7,$8,$9,$10

#@gimp 3D image cube : gmic4gimp_imagecube3d, gmic4gimp_imagecube3d
#@gimp : Rendering width = int(512,1,1024)
#@gimp : Rendering height = int(512,1,1024)
#@gimp : Image resolution = int(128,1,512)
#@gimp : Cube size = float(256,0,512)
#@gimp : X-angle = float(57,0,360)
#@gimp : Y-angle = float(41,0,360)
#@gimp : Z-angle = float(21,0,360)
gmic4gimp_imagecube3d :
  -repeat @# -l[@{>,-1}]
    -to_rgb -imagecube3d $3 -*3d $4 -rot3d 0,0,1,$7 -rot3d 0,1,0,$6 -rot3d 1,0,0,$5 -r3d 2 -o3d
    $1,$2,1,4,-1 -object3d[1] [0],50%,50% -k[1]
    -s[-1] v -threshold[-1] 0 -*[-1] 255 -a[-4--1] v
  -endl -done

#@gimp 3D random objects : gmic4gimp_random3d, gmic4gimp_random3d
#@gimp : Type of objects = choice("Cube","Cone","Cylinder","Sphere","Torus")
#@gimp : Number of objects = int(50,1,300)
#@gimp : Object size = float(3,1,20)
#@gimp : Z-range = float(100,0,300)
#@gimp : Rendering type = choice(3,"Points","Lines","Flat","Flat shaded","Gouraud","Phong")
#@gimp : Opacity = float(1,0,1)
_gmic4gimp_random3d0 : -cube3d $1
_gmic4gimp_random3d1 : ($1) -/[-1] 2 -cone3d @-1,$1 -rm[-2]
_gmic4gimp_random3d2 : ($1) -/[-1] 2 -cylinder3d @-1,$1 -rm[-2]
_gmic4gimp_random3d3 : -sphere3d $1,2
_gmic4gimp_random3d4 : ($1) -/[-1] 3 -torus3d $1,@-1 -rm[-2]
gmic4gimp_random3d :
  -repeat @# -l[@{>,-1}]
    -to_rgb (@{-1,w},@{-1,h},@{-1,d},@{-1,c}) -/[-1] 2 -repeat $2
    (@{1,0}) -+[-1] @{1,1} -*[-1] $3 -/[-1] 100 -p[-1] -_gmic4gimp_random3d$1 @-1 -rm[-2]
    -rot3d[-1] 1,1,0,@{?,0,360}
    (@{?,-1,1}) -*[-1] @{1,0} (@{?,-1,1}) -*[-1] @{1,1}
    -+3d[-3] @-2,@-1,@{?,-$4,$4} -rm[-2,-1]
    -col3d[-1] @{?,255},@{?,255},@{?,255} -done -+3d[2--1] -r3d $5 -o3d -object3d[0] [-1],50%,50%,0,$6
    -k[0]
  -endl -done

#@gimp Mandelbrot / Julia sets : gmic4gimp_mandelbrot, gmic4gimp_mandelbrot
#@gimp : X-origin = float(0,-2,2)
#@gimp : Y-origin = float(0,-2,2)
#@gimp : Zoom = float(-2,-2,0)
#@gimp : Number of iterations = int(128,1,512)
#@gimp : Fractal set = choice(Mandelbrot, Julia)
#@gimp : X-seed = float(0,-2,2)
#@gimp : Y-seed = float(0,-2,2)
#@gimp : Palette = choice(1,Grayscale,Blue,Hot,Clusters)
gmic4gimp_mandelbrot :
  -repeat @#
    ($1) -+[-1] $3 ($2) -+[-1] $3 ($1) --[-1] $3 ($2) --[-1] $3 -a[-4--1] x
    -channels[-2] 0 -mandelbrot[-2] @-1,$4,$5,$6,$7 -rm[-1]
    -if $8 ($8) --[-1] 1 -map[-2] @-1 -rm[-1] -else -norm[-1] -n[-1] 0,255 -endif
  -mv[-1] 0 -done

#@gimp _<b>Various</b>
#----------------------

#@gimp Fourier analysis : display_fft, display_fft

#@gimp Import data : gmic4gimp_import_image, gmic4gimp_import_image
#@gimp : Filename = file()
#@gimp : Image normalization = bool(1)
#@gimp : note = note{"\n<small><b>Note : </b>
#@gimp : This filter can import any image data read by the <b>G'MIC</b> language interpreter.
#@gimp : It includes exotic formats as : <i>Pandore, CImg, Inrimage, AVI/MPEG [requires FFMPEG installed], ...</i>
#@gimp : </small>"}
gmic4gimp_import_image :
  -rm -i $1 -s z -if $2 -n 0,255 -else -cut 0,255 -endif

#@gimp Custom G'MIC command : gmic4gimp_custom, gmic4gimp_custom
#@gimp : Command = text(-to_rgb --deform 20 -compose_edges 3)
#@gimp : note = note{"\n<small><b>Note : </b>
#@gimp : This filter can execute any set of instructions understood by the <b>G'MIC</b> language interpreter.
#@gimp : Here, you can then test some commands before creating your own G'MIC macro functions and GIMP menu entries.\n\n
#@gimp : Please look at the documentation reference web page :</small>"}
#@gimp : note = link("http://gmic.sourceforge.net/documentation.shtml")
#@gimp : note = note{"<small>
#@gimp : to learn more about available <b>G'MIC</b> commands.
#@gimp : </small>"}
gmic4gimp_custom :
  -nop

#@gimp <b>Animated</b>
#----------------------


#@gimp Edges : gmic4gimp_edges_anim, gmic4gimp_edges_anim_preview
#@gimp : Number of frames = int(10,2,100)
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Edge threshold = float(30,0,150)
#@gimp : Smoothness = float(0,0,10)
#@gimp : note = note{"<b>Ending parameters :</b>"}
#@gimp : Edge threshold = float(60,0,150)
#@gimp : Smoothness = float(0,0,10)
gmic4gimp_edges_anim_preview :
  -s[-1] y,2 -gmic4gimp_edges[-2] $2,$3,0 -gmic4gimp_edges[-1] $4,$5,0 -a[-2,-1] y -n 0,255

gmic4gimp_edges_anim :
  -i[0] ($2,$3;$4,$5) -r[0] 100%,$1,1,1,3
  -repeat $1 --gmic4gimp_edges[1] @{0,0-1} -translate[0] 0,-1 -done -rm[0,1]

#@gimp Cartoon : gmic4gimp_cartoon_anim, gmic4gimp_cartoon_anim_preview
#@gimp : Number of frames = int(10,2,100)
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Edge threshold = float(30,0,150)
#@gimp : note = note{"<b>Ending parameters :</b>"}
#@gimp : Edge threshold = float(60,0,150)
gmic4gimp_cartoon_anim_preview :
  -s[-1] y,2 -cartoon[-2] $2 -cartoon[-1] $3 -a[-2,-1] y

gmic4gimp_cartoon_anim :
  -i[0] ($2;$3) -r[0] 100%,$1,1,1,3
  -repeat $1 --cartoon[1] @{0,0} -translate[0] 0,-1 -done -rm[0,1]

#@gimp Cubism : gmic4gimp_cubism_anim, gmic4gimp_cubism_anim_preview
#@gimp : Number of frames = int(10,2,100)
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Iterations = int(400,1,3000)
#@gimp : Bloc size = float(3,0,10)
#@gimp : Maximum angle = float(90,0,360)
#@gimp : Opacity = float(0.7,0.01,1)
#@gimp : Smoothness = float(0,0,5)
#@gimp : note = note{"<b>Ending parameters :</b>"}
#@gimp : Iterations = int(400,1,3000)
#@gimp : Bloc size = float(3,0,10)
#@gimp : Maximum angle = float(20,0,360)
#@gimp : Opacity = float(0.7,0.01,1)
#@gimp : Smoothness = float(2,0,5)
gmic4gimp_cubism_anim_preview :
  -s[-1] y,2 -gmic4gimp_cubism[-2] $2,$3,$4,$5,$6 -gmic4gimp_cubism[-1] $7,$8,$9,$10,$11 -a[-2,-1] y

gmic4gimp_cubism_anim :
  -i[0] ($2,$3,$4,$5,$6;$7,$8,$9,$10) -r[0] 100%,$1,1,1,3 -repeat $1 --gmic4gimp_cubism[1] @{0,0-4} -translate[0] 0,-1 -done -rm[0,1]

#@gimp B&amp;W stencil : gmic4gimp_stencilbw_anim, gmic4gimp_stencilbw_anim_preview
#@gimp : Number of frames = int(10,2,100)
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Edge threshold = float(30,0,150)
#@gimp : Smoothness = float(10,0,30)
#@gimp : note = note{"<b>Ending parameters :</b>"}
#@gimp : Edge threshold = float(30,0,150)
#@gimp : Smoothness = float(15,0,30)
gmic4gimp_stencilbw_anim_preview :
  -s[-1] y,2 -stencilbw[-2] $2,$3 -stencilbw[-1] $4,$5 -a[-2,-1] y

gmic4gimp_stencilbw_anim :
  -i[0] ($2,$3;$4,$5) -r[0] 100%,$1,1,1,3
  -repeat $1 --stencilbw[1] @{0,0},@{0,1} -translate[0] 0,-1 -done -rm[0,1]

#@gimp B&amp;W pencil : gmic4gimp_pencilbw_anim, gmic4gimp_pencilbw_anim_preview
#@gimp : Number of frames = int(10,2,100)
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Pencil type = float(2.3,0,5)
#@gimp : Amplitude = float(100,0,200)
#@gimp : note = note{"<b>Ending parameters :</b>"}
#@gimp : Pencil type = float(0.3,0,5)
#@gimp : Amplitude = float(60,0,200)
gmic4gimp_pencilbw_anim_preview :
  -s[-1] y,2 -pencilbw[-2] $2,$3 -pencilbw[-1] $4,$5 -a[-2,-1] y

gmic4gimp_pencilbw_anim :
  -i[0] ($2,$3;$4,$5) -r[0] 100%,$1,1,1,3
  -repeat $1 --pencilbw[1] @{0,0},@{0,1} -translate[0] 0,-1 -done -rm[0,1]

#@gimp Soft glow : gmic4gimp_glow_anim, gmic4gimp_glow_anim_preview
#@gimp : Number of frames = int(10,2,100)
#@gimp : note = note{"\n<b>Starting parameters :</b>"}
#@gimp : Amplitude = float(0,0,5)
#@gimp : note = note{"<b>Ending parameters :</b>"}
#@gimp : Amplitude = float(3,0,5)
gmic4gimp_glow_anim_preview :
  -s[-1] y,2 -glow[-2] -$2 -glow[-1] -$3 -a[-2,-1] y

gmic4gimp_glow_anim :
  -i[0] (-$2;-$3) -r[0] 100%,$1,1,1,3
  -repeat $1 --glow[1] @{0,0} -translate[0] 0,-1 -done -rm[0,1]


#@gimp _<i>Initial G'MIC filters</i>
#-----------------------------------


#@gimp About this section : nop, gmic4gimp_logo_en
#@gimp : note = note{"
#@gimp : This section contains all the <i>initial</i> definitions of the filters from the G'MIC plug-in,
#@gimp : <i>i.e.</i> the ones defined at the latest release date. They are kept, so that in case of problems
#@gimp : with the update files, the original filters are still accessible.
#@gimp : If no filters appear below, then you did probably not update your filters definitions yet."}




# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC macro file)
