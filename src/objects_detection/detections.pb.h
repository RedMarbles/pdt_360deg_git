// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: detections.proto

#ifndef PROTOBUF_detections_2eproto__INCLUDED
#define PROTOBUF_detections_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace doppia_protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_detections_2eproto();
void protobuf_AssignDesc_detections_2eproto();
void protobuf_ShutdownFile_detections_2eproto();

class Point2d;
class Box;
class Detection;
class Detections;

enum Detection_ObjectClasses {
  Detection_ObjectClasses_Car = 2,
  Detection_ObjectClasses_Pedestrian = 3,
  Detection_ObjectClasses_Bike = 5,
  Detection_ObjectClasses_Motorbike = 6,
  Detection_ObjectClasses_Bus = 7,
  Detection_ObjectClasses_Tram = 8,
  Detection_ObjectClasses_StaticObject = 4,
  Detection_ObjectClasses_Unknown = 0
};
bool Detection_ObjectClasses_IsValid(int value);
const Detection_ObjectClasses Detection_ObjectClasses_ObjectClasses_MIN = Detection_ObjectClasses_Unknown;
const Detection_ObjectClasses Detection_ObjectClasses_ObjectClasses_MAX = Detection_ObjectClasses_Tram;
const int Detection_ObjectClasses_ObjectClasses_ARRAYSIZE = Detection_ObjectClasses_ObjectClasses_MAX + 1;

const ::google::protobuf::EnumDescriptor* Detection_ObjectClasses_descriptor();
inline const ::std::string& Detection_ObjectClasses_Name(Detection_ObjectClasses value) {
  return ::google::protobuf::internal::NameOfEnum(
    Detection_ObjectClasses_descriptor(), value);
}
inline bool Detection_ObjectClasses_Parse(
    const ::std::string& name, Detection_ObjectClasses* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Detection_ObjectClasses>(
    Detection_ObjectClasses_descriptor(), name, value);
}
// ===================================================================

class Point2d : public ::google::protobuf::Message {
 public:
  Point2d();
  virtual ~Point2d();

  Point2d(const Point2d& from);

  inline Point2d& operator=(const Point2d& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point2d& default_instance();

  void Swap(Point2d* other);

  // implements Message ----------------------------------------------

  Point2d* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point2d& from);
  void MergeFrom(const Point2d& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.Point2d)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_detections_2eproto();
  friend void protobuf_AssignDesc_detections_2eproto();
  friend void protobuf_ShutdownFile_detections_2eproto();

  void InitAsDefaultInstance();
  static Point2d* default_instance_;
};
// -------------------------------------------------------------------

class Box : public ::google::protobuf::Message {
 public:
  Box();
  virtual ~Box();

  Box(const Box& from);

  inline Box& operator=(const Box& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Box& default_instance();

  void Swap(Box* other);

  // implements Message ----------------------------------------------

  Box* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Box& from);
  void MergeFrom(const Box& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .doppia_protobuf.Point2d min_corner = 1;
  inline bool has_min_corner() const;
  inline void clear_min_corner();
  static const int kMinCornerFieldNumber = 1;
  inline const ::doppia_protobuf::Point2d& min_corner() const;
  inline ::doppia_protobuf::Point2d* mutable_min_corner();
  inline ::doppia_protobuf::Point2d* release_min_corner();
  inline void set_allocated_min_corner(::doppia_protobuf::Point2d* min_corner);

  // required .doppia_protobuf.Point2d max_corner = 2;
  inline bool has_max_corner() const;
  inline void clear_max_corner();
  static const int kMaxCornerFieldNumber = 2;
  inline const ::doppia_protobuf::Point2d& max_corner() const;
  inline ::doppia_protobuf::Point2d* mutable_max_corner();
  inline ::doppia_protobuf::Point2d* release_max_corner();
  inline void set_allocated_max_corner(::doppia_protobuf::Point2d* max_corner);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.Box)
 private:
  inline void set_has_min_corner();
  inline void clear_has_min_corner();
  inline void set_has_max_corner();
  inline void clear_has_max_corner();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::doppia_protobuf::Point2d* min_corner_;
  ::doppia_protobuf::Point2d* max_corner_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_detections_2eproto();
  friend void protobuf_AssignDesc_detections_2eproto();
  friend void protobuf_ShutdownFile_detections_2eproto();

  void InitAsDefaultInstance();
  static Box* default_instance_;
};
// -------------------------------------------------------------------

class Detection : public ::google::protobuf::Message {
 public:
  Detection();
  virtual ~Detection();

  Detection(const Detection& from);

  inline Detection& operator=(const Detection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Detection& default_instance();

  void Swap(Detection* other);

  // implements Message ----------------------------------------------

  Detection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Detection& from);
  void MergeFrom(const Detection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Detection_ObjectClasses ObjectClasses;
  static const ObjectClasses Car = Detection_ObjectClasses_Car;
  static const ObjectClasses Pedestrian = Detection_ObjectClasses_Pedestrian;
  static const ObjectClasses Bike = Detection_ObjectClasses_Bike;
  static const ObjectClasses Motorbike = Detection_ObjectClasses_Motorbike;
  static const ObjectClasses Bus = Detection_ObjectClasses_Bus;
  static const ObjectClasses Tram = Detection_ObjectClasses_Tram;
  static const ObjectClasses StaticObject = Detection_ObjectClasses_StaticObject;
  static const ObjectClasses Unknown = Detection_ObjectClasses_Unknown;
  static inline bool ObjectClasses_IsValid(int value) {
    return Detection_ObjectClasses_IsValid(value);
  }
  static const ObjectClasses ObjectClasses_MIN =
    Detection_ObjectClasses_ObjectClasses_MIN;
  static const ObjectClasses ObjectClasses_MAX =
    Detection_ObjectClasses_ObjectClasses_MAX;
  static const int ObjectClasses_ARRAYSIZE =
    Detection_ObjectClasses_ObjectClasses_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ObjectClasses_descriptor() {
    return Detection_ObjectClasses_descriptor();
  }
  static inline const ::std::string& ObjectClasses_Name(ObjectClasses value) {
    return Detection_ObjectClasses_Name(value);
  }
  static inline bool ObjectClasses_Parse(const ::std::string& name,
      ObjectClasses* value) {
    return Detection_ObjectClasses_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .doppia_protobuf.Box bounding_box = 1;
  inline bool has_bounding_box() const;
  inline void clear_bounding_box();
  static const int kBoundingBoxFieldNumber = 1;
  inline const ::doppia_protobuf::Box& bounding_box() const;
  inline ::doppia_protobuf::Box* mutable_bounding_box();
  inline ::doppia_protobuf::Box* release_bounding_box();
  inline void set_allocated_bounding_box(::doppia_protobuf::Box* bounding_box);

  // required .doppia_protobuf.Detection.ObjectClasses object_class = 2;
  inline bool has_object_class() const;
  inline void clear_object_class();
  static const int kObjectClassFieldNumber = 2;
  inline ::doppia_protobuf::Detection_ObjectClasses object_class() const;
  inline void set_object_class(::doppia_protobuf::Detection_ObjectClasses value);

  // optional float score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline float score() const;
  inline void set_score(float value);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.Detection)
 private:
  inline void set_has_bounding_box();
  inline void clear_has_bounding_box();
  inline void set_has_object_class();
  inline void clear_has_object_class();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::doppia_protobuf::Box* bounding_box_;
  int object_class_;
  float score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_detections_2eproto();
  friend void protobuf_AssignDesc_detections_2eproto();
  friend void protobuf_ShutdownFile_detections_2eproto();

  void InitAsDefaultInstance();
  static Detection* default_instance_;
};
// -------------------------------------------------------------------

class Detections : public ::google::protobuf::Message {
 public:
  Detections();
  virtual ~Detections();

  Detections(const Detections& from);

  inline Detections& operator=(const Detections& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Detections& default_instance();

  void Swap(Detections* other);

  // implements Message ----------------------------------------------

  Detections* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Detections& from);
  void MergeFrom(const Detections& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string image_name = 1;
  inline bool has_image_name() const;
  inline void clear_image_name();
  static const int kImageNameFieldNumber = 1;
  inline const ::std::string& image_name() const;
  inline void set_image_name(const ::std::string& value);
  inline void set_image_name(const char* value);
  inline void set_image_name(const char* value, size_t size);
  inline ::std::string* mutable_image_name();
  inline ::std::string* release_image_name();
  inline void set_allocated_image_name(::std::string* image_name);

  // repeated .doppia_protobuf.Detection detections = 2;
  inline int detections_size() const;
  inline void clear_detections();
  static const int kDetectionsFieldNumber = 2;
  inline const ::doppia_protobuf::Detection& detections(int index) const;
  inline ::doppia_protobuf::Detection* mutable_detections(int index);
  inline ::doppia_protobuf::Detection* add_detections();
  inline const ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::Detection >&
      detections() const;
  inline ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::Detection >*
      mutable_detections();

  // @@protoc_insertion_point(class_scope:doppia_protobuf.Detections)
 private:
  inline void set_has_image_name();
  inline void clear_has_image_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* image_name_;
  ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::Detection > detections_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_detections_2eproto();
  friend void protobuf_AssignDesc_detections_2eproto();
  friend void protobuf_ShutdownFile_detections_2eproto();

  void InitAsDefaultInstance();
  static Detections* default_instance_;
};
// ===================================================================


// ===================================================================

// Point2d

// required int32 x = 1;
inline bool Point2d::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point2d::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point2d::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point2d::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Point2d::x() const {
  return x_;
}
inline void Point2d::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool Point2d::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point2d::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point2d::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point2d::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Point2d::y() const {
  return y_;
}
inline void Point2d::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Box

// required .doppia_protobuf.Point2d min_corner = 1;
inline bool Box::has_min_corner() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Box::set_has_min_corner() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Box::clear_has_min_corner() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Box::clear_min_corner() {
  if (min_corner_ != NULL) min_corner_->::doppia_protobuf::Point2d::Clear();
  clear_has_min_corner();
}
inline const ::doppia_protobuf::Point2d& Box::min_corner() const {
  return min_corner_ != NULL ? *min_corner_ : *default_instance_->min_corner_;
}
inline ::doppia_protobuf::Point2d* Box::mutable_min_corner() {
  set_has_min_corner();
  if (min_corner_ == NULL) min_corner_ = new ::doppia_protobuf::Point2d;
  return min_corner_;
}
inline ::doppia_protobuf::Point2d* Box::release_min_corner() {
  clear_has_min_corner();
  ::doppia_protobuf::Point2d* temp = min_corner_;
  min_corner_ = NULL;
  return temp;
}
inline void Box::set_allocated_min_corner(::doppia_protobuf::Point2d* min_corner) {
  delete min_corner_;
  min_corner_ = min_corner;
  if (min_corner) {
    set_has_min_corner();
  } else {
    clear_has_min_corner();
  }
}

// required .doppia_protobuf.Point2d max_corner = 2;
inline bool Box::has_max_corner() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Box::set_has_max_corner() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Box::clear_has_max_corner() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Box::clear_max_corner() {
  if (max_corner_ != NULL) max_corner_->::doppia_protobuf::Point2d::Clear();
  clear_has_max_corner();
}
inline const ::doppia_protobuf::Point2d& Box::max_corner() const {
  return max_corner_ != NULL ? *max_corner_ : *default_instance_->max_corner_;
}
inline ::doppia_protobuf::Point2d* Box::mutable_max_corner() {
  set_has_max_corner();
  if (max_corner_ == NULL) max_corner_ = new ::doppia_protobuf::Point2d;
  return max_corner_;
}
inline ::doppia_protobuf::Point2d* Box::release_max_corner() {
  clear_has_max_corner();
  ::doppia_protobuf::Point2d* temp = max_corner_;
  max_corner_ = NULL;
  return temp;
}
inline void Box::set_allocated_max_corner(::doppia_protobuf::Point2d* max_corner) {
  delete max_corner_;
  max_corner_ = max_corner;
  if (max_corner) {
    set_has_max_corner();
  } else {
    clear_has_max_corner();
  }
}

// -------------------------------------------------------------------

// Detection

// required .doppia_protobuf.Box bounding_box = 1;
inline bool Detection::has_bounding_box() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Detection::set_has_bounding_box() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Detection::clear_has_bounding_box() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Detection::clear_bounding_box() {
  if (bounding_box_ != NULL) bounding_box_->::doppia_protobuf::Box::Clear();
  clear_has_bounding_box();
}
inline const ::doppia_protobuf::Box& Detection::bounding_box() const {
  return bounding_box_ != NULL ? *bounding_box_ : *default_instance_->bounding_box_;
}
inline ::doppia_protobuf::Box* Detection::mutable_bounding_box() {
  set_has_bounding_box();
  if (bounding_box_ == NULL) bounding_box_ = new ::doppia_protobuf::Box;
  return bounding_box_;
}
inline ::doppia_protobuf::Box* Detection::release_bounding_box() {
  clear_has_bounding_box();
  ::doppia_protobuf::Box* temp = bounding_box_;
  bounding_box_ = NULL;
  return temp;
}
inline void Detection::set_allocated_bounding_box(::doppia_protobuf::Box* bounding_box) {
  delete bounding_box_;
  bounding_box_ = bounding_box;
  if (bounding_box) {
    set_has_bounding_box();
  } else {
    clear_has_bounding_box();
  }
}

// required .doppia_protobuf.Detection.ObjectClasses object_class = 2;
inline bool Detection::has_object_class() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Detection::set_has_object_class() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Detection::clear_has_object_class() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Detection::clear_object_class() {
  object_class_ = 2;
  clear_has_object_class();
}
inline ::doppia_protobuf::Detection_ObjectClasses Detection::object_class() const {
  return static_cast< ::doppia_protobuf::Detection_ObjectClasses >(object_class_);
}
inline void Detection::set_object_class(::doppia_protobuf::Detection_ObjectClasses value) {
  assert(::doppia_protobuf::Detection_ObjectClasses_IsValid(value));
  set_has_object_class();
  object_class_ = value;
}

// optional float score = 3;
inline bool Detection::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Detection::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Detection::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Detection::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline float Detection::score() const {
  return score_;
}
inline void Detection::set_score(float value) {
  set_has_score();
  score_ = value;
}

// -------------------------------------------------------------------

// Detections

// optional string image_name = 1;
inline bool Detections::has_image_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Detections::set_has_image_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Detections::clear_has_image_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Detections::clear_image_name() {
  if (image_name_ != &::google::protobuf::internal::kEmptyString) {
    image_name_->clear();
  }
  clear_has_image_name();
}
inline const ::std::string& Detections::image_name() const {
  return *image_name_;
}
inline void Detections::set_image_name(const ::std::string& value) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(value);
}
inline void Detections::set_image_name(const char* value) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(value);
}
inline void Detections::set_image_name(const char* value, size_t size) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Detections::mutable_image_name() {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  return image_name_;
}
inline ::std::string* Detections::release_image_name() {
  clear_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_name_;
    image_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Detections::set_allocated_image_name(::std::string* image_name) {
  if (image_name_ != &::google::protobuf::internal::kEmptyString) {
    delete image_name_;
  }
  if (image_name) {
    set_has_image_name();
    image_name_ = image_name;
  } else {
    clear_has_image_name();
    image_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .doppia_protobuf.Detection detections = 2;
inline int Detections::detections_size() const {
  return detections_.size();
}
inline void Detections::clear_detections() {
  detections_.Clear();
}
inline const ::doppia_protobuf::Detection& Detections::detections(int index) const {
  return detections_.Get(index);
}
inline ::doppia_protobuf::Detection* Detections::mutable_detections(int index) {
  return detections_.Mutable(index);
}
inline ::doppia_protobuf::Detection* Detections::add_detections() {
  return detections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::Detection >&
Detections::detections() const {
  return detections_;
}
inline ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::Detection >*
Detections::mutable_detections() {
  return &detections_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace doppia_protobuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::doppia_protobuf::Detection_ObjectClasses>() {
  return ::doppia_protobuf::Detection_ObjectClasses_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_detections_2eproto__INCLUDED
