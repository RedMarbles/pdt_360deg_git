// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: detector_model.proto

#ifndef PROTOBUF_detector_5fmodel_2eproto__INCLUDED
#define PROTOBUF_detector_5fmodel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "detections.pb.h"
// @@protoc_insertion_point(includes)

namespace doppia_protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_detector_5fmodel_2eproto();
void protobuf_AssignDesc_detector_5fmodel_2eproto();
void protobuf_ShutdownFile_detector_5fmodel_2eproto();

class LinearSvmModel;
class IntegralChannelsFeature;
class IntegralChannelDecisionStump;
class IntegralChannelBinaryDecisionTreeNode;
class IntegralChannelBinaryDecisionTree;
class IntegralChannelStumpSet;
class SoftCascadeOverIntegralChannelsStage;
class SoftCascadeOverIntegralChannelsModel;
class DetectorModel;
class MultiScalesDetectorModel;
class DetectorModelsBundle;

enum SoftCascadeOverIntegralChannelsStage_FeatureTypes {
  SoftCascadeOverIntegralChannelsStage_FeatureTypes_Stumps = 0,
  SoftCascadeOverIntegralChannelsStage_FeatureTypes_Level2DecisionTree = 10,
  SoftCascadeOverIntegralChannelsStage_FeatureTypes_LevelNDecisionTree = 100,
  SoftCascadeOverIntegralChannelsStage_FeatureTypes_StumpSet = 200
};
bool SoftCascadeOverIntegralChannelsStage_FeatureTypes_IsValid(int value);
const SoftCascadeOverIntegralChannelsStage_FeatureTypes SoftCascadeOverIntegralChannelsStage_FeatureTypes_FeatureTypes_MIN = SoftCascadeOverIntegralChannelsStage_FeatureTypes_Stumps;
const SoftCascadeOverIntegralChannelsStage_FeatureTypes SoftCascadeOverIntegralChannelsStage_FeatureTypes_FeatureTypes_MAX = SoftCascadeOverIntegralChannelsStage_FeatureTypes_StumpSet;
const int SoftCascadeOverIntegralChannelsStage_FeatureTypes_FeatureTypes_ARRAYSIZE = SoftCascadeOverIntegralChannelsStage_FeatureTypes_FeatureTypes_MAX + 1;

const ::google::protobuf::EnumDescriptor* SoftCascadeOverIntegralChannelsStage_FeatureTypes_descriptor();
inline const ::std::string& SoftCascadeOverIntegralChannelsStage_FeatureTypes_Name(SoftCascadeOverIntegralChannelsStage_FeatureTypes value) {
  return ::google::protobuf::internal::NameOfEnum(
    SoftCascadeOverIntegralChannelsStage_FeatureTypes_descriptor(), value);
}
inline bool SoftCascadeOverIntegralChannelsStage_FeatureTypes_Parse(
    const ::std::string& name, SoftCascadeOverIntegralChannelsStage_FeatureTypes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SoftCascadeOverIntegralChannelsStage_FeatureTypes>(
    SoftCascadeOverIntegralChannelsStage_FeatureTypes_descriptor(), name, value);
}
enum DetectorModel_DetectorTypes {
  DetectorModel_DetectorTypes_LinearSvm = 0,
  DetectorModel_DetectorTypes_SoftCascadeOverIntegralChannels = 10,
  DetectorModel_DetectorTypes_HoughForest = 20
};
bool DetectorModel_DetectorTypes_IsValid(int value);
const DetectorModel_DetectorTypes DetectorModel_DetectorTypes_DetectorTypes_MIN = DetectorModel_DetectorTypes_LinearSvm;
const DetectorModel_DetectorTypes DetectorModel_DetectorTypes_DetectorTypes_MAX = DetectorModel_DetectorTypes_HoughForest;
const int DetectorModel_DetectorTypes_DetectorTypes_ARRAYSIZE = DetectorModel_DetectorTypes_DetectorTypes_MAX + 1;

const ::google::protobuf::EnumDescriptor* DetectorModel_DetectorTypes_descriptor();
inline const ::std::string& DetectorModel_DetectorTypes_Name(DetectorModel_DetectorTypes value) {
  return ::google::protobuf::internal::NameOfEnum(
    DetectorModel_DetectorTypes_descriptor(), value);
}
inline bool DetectorModel_DetectorTypes_Parse(
    const ::std::string& name, DetectorModel_DetectorTypes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DetectorModel_DetectorTypes>(
    DetectorModel_DetectorTypes_descriptor(), name, value);
}
enum DetectorModel_OcclusionTypes {
  DetectorModel_OcclusionTypes_LeftOcclusion = 10,
  DetectorModel_OcclusionTypes_RightOcclusion = 11,
  DetectorModel_OcclusionTypes_BottomOcclusion = 20,
  DetectorModel_OcclusionTypes_TopOcclusion = 21
};
bool DetectorModel_OcclusionTypes_IsValid(int value);
const DetectorModel_OcclusionTypes DetectorModel_OcclusionTypes_OcclusionTypes_MIN = DetectorModel_OcclusionTypes_LeftOcclusion;
const DetectorModel_OcclusionTypes DetectorModel_OcclusionTypes_OcclusionTypes_MAX = DetectorModel_OcclusionTypes_TopOcclusion;
const int DetectorModel_OcclusionTypes_OcclusionTypes_ARRAYSIZE = DetectorModel_OcclusionTypes_OcclusionTypes_MAX + 1;

const ::google::protobuf::EnumDescriptor* DetectorModel_OcclusionTypes_descriptor();
inline const ::std::string& DetectorModel_OcclusionTypes_Name(DetectorModel_OcclusionTypes value) {
  return ::google::protobuf::internal::NameOfEnum(
    DetectorModel_OcclusionTypes_descriptor(), value);
}
inline bool DetectorModel_OcclusionTypes_Parse(
    const ::std::string& name, DetectorModel_OcclusionTypes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DetectorModel_OcclusionTypes>(
    DetectorModel_OcclusionTypes_descriptor(), name, value);
}
// ===================================================================

class LinearSvmModel : public ::google::protobuf::Message {
 public:
  LinearSvmModel();
  virtual ~LinearSvmModel();

  LinearSvmModel(const LinearSvmModel& from);

  inline LinearSvmModel& operator=(const LinearSvmModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinearSvmModel& default_instance();

  void Swap(LinearSvmModel* other);

  // implements Message ----------------------------------------------

  LinearSvmModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinearSvmModel& from);
  void MergeFrom(const LinearSvmModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string solved_type = 1;
  inline bool has_solved_type() const;
  inline void clear_solved_type();
  static const int kSolvedTypeFieldNumber = 1;
  inline const ::std::string& solved_type() const;
  inline void set_solved_type(const ::std::string& value);
  inline void set_solved_type(const char* value);
  inline void set_solved_type(const char* value, size_t size);
  inline ::std::string* mutable_solved_type();
  inline ::std::string* release_solved_type();
  inline void set_allocated_solved_type(::std::string* solved_type);

  // optional uint32 number_of_classes = 2;
  inline bool has_number_of_classes() const;
  inline void clear_number_of_classes();
  static const int kNumberOfClassesFieldNumber = 2;
  inline ::google::protobuf::uint32 number_of_classes() const;
  inline void set_number_of_classes(::google::protobuf::uint32 value);

  // repeated int32 labels = 3;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 3;
  inline ::google::protobuf::int32 labels(int index) const;
  inline void set_labels(int index, ::google::protobuf::int32 value);
  inline void add_labels(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      labels() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_labels();

  // optional uint32 number_of_features = 4;
  inline bool has_number_of_features() const;
  inline void clear_number_of_features();
  static const int kNumberOfFeaturesFieldNumber = 4;
  inline ::google::protobuf::uint32 number_of_features() const;
  inline void set_number_of_features(::google::protobuf::uint32 value);

  // required float bias = 5;
  inline bool has_bias() const;
  inline void clear_bias();
  static const int kBiasFieldNumber = 5;
  inline float bias() const;
  inline void set_bias(float value);

  // repeated float w = 6;
  inline int w_size() const;
  inline void clear_w();
  static const int kWFieldNumber = 6;
  inline float w(int index) const;
  inline void set_w(int index, float value);
  inline void add_w(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      w() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_w();

  // @@protoc_insertion_point(class_scope:doppia_protobuf.LinearSvmModel)
 private:
  inline void set_has_solved_type();
  inline void clear_has_solved_type();
  inline void set_has_number_of_classes();
  inline void clear_has_number_of_classes();
  inline void set_has_number_of_features();
  inline void clear_has_number_of_features();
  inline void set_has_bias();
  inline void clear_has_bias();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* solved_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > labels_;
  ::google::protobuf::uint32 number_of_classes_;
  ::google::protobuf::uint32 number_of_features_;
  ::google::protobuf::RepeatedField< float > w_;
  float bias_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_detector_5fmodel_2eproto();
  friend void protobuf_AssignDesc_detector_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_detector_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static LinearSvmModel* default_instance_;
};
// -------------------------------------------------------------------

class IntegralChannelsFeature : public ::google::protobuf::Message {
 public:
  IntegralChannelsFeature();
  virtual ~IntegralChannelsFeature();

  IntegralChannelsFeature(const IntegralChannelsFeature& from);

  inline IntegralChannelsFeature& operator=(const IntegralChannelsFeature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntegralChannelsFeature& default_instance();

  void Swap(IntegralChannelsFeature* other);

  // implements Message ----------------------------------------------

  IntegralChannelsFeature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntegralChannelsFeature& from);
  void MergeFrom(const IntegralChannelsFeature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 channel_index = 1;
  inline bool has_channel_index() const;
  inline void clear_channel_index();
  static const int kChannelIndexFieldNumber = 1;
  inline ::google::protobuf::int32 channel_index() const;
  inline void set_channel_index(::google::protobuf::int32 value);

  // required .doppia_protobuf.Box box = 2;
  inline bool has_box() const;
  inline void clear_box();
  static const int kBoxFieldNumber = 2;
  inline const ::doppia_protobuf::Box& box() const;
  inline ::doppia_protobuf::Box* mutable_box();
  inline ::doppia_protobuf::Box* release_box();
  inline void set_allocated_box(::doppia_protobuf::Box* box);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.IntegralChannelsFeature)
 private:
  inline void set_has_channel_index();
  inline void clear_has_channel_index();
  inline void set_has_box();
  inline void clear_has_box();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::doppia_protobuf::Box* box_;
  ::google::protobuf::int32 channel_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_detector_5fmodel_2eproto();
  friend void protobuf_AssignDesc_detector_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_detector_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static IntegralChannelsFeature* default_instance_;
};
// -------------------------------------------------------------------

class IntegralChannelDecisionStump : public ::google::protobuf::Message {
 public:
  IntegralChannelDecisionStump();
  virtual ~IntegralChannelDecisionStump();

  IntegralChannelDecisionStump(const IntegralChannelDecisionStump& from);

  inline IntegralChannelDecisionStump& operator=(const IntegralChannelDecisionStump& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntegralChannelDecisionStump& default_instance();

  void Swap(IntegralChannelDecisionStump* other);

  // implements Message ----------------------------------------------

  IntegralChannelDecisionStump* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntegralChannelDecisionStump& from);
  void MergeFrom(const IntegralChannelDecisionStump& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .doppia_protobuf.IntegralChannelsFeature feature = 1;
  inline bool has_feature() const;
  inline void clear_feature();
  static const int kFeatureFieldNumber = 1;
  inline const ::doppia_protobuf::IntegralChannelsFeature& feature() const;
  inline ::doppia_protobuf::IntegralChannelsFeature* mutable_feature();
  inline ::doppia_protobuf::IntegralChannelsFeature* release_feature();
  inline void set_allocated_feature(::doppia_protobuf::IntegralChannelsFeature* feature);

  // required float feature_threshold = 2;
  inline bool has_feature_threshold() const;
  inline void clear_feature_threshold();
  static const int kFeatureThresholdFieldNumber = 2;
  inline float feature_threshold() const;
  inline void set_feature_threshold(float value);

  // optional bool larger_than_threshold = 3 [default = false];
  inline bool has_larger_than_threshold() const;
  inline void clear_larger_than_threshold();
  static const int kLargerThanThresholdFieldNumber = 3;
  inline bool larger_than_threshold() const;
  inline void set_larger_than_threshold(bool value);

  // optional float true_leaf_weight = 10;
  inline bool has_true_leaf_weight() const;
  inline void clear_true_leaf_weight();
  static const int kTrueLeafWeightFieldNumber = 10;
  inline float true_leaf_weight() const;
  inline void set_true_leaf_weight(float value);

  // optional float false_leaf_weight = 11;
  inline bool has_false_leaf_weight() const;
  inline void clear_false_leaf_weight();
  static const int kFalseLeafWeightFieldNumber = 11;
  inline float false_leaf_weight() const;
  inline void set_false_leaf_weight(float value);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.IntegralChannelDecisionStump)
 private:
  inline void set_has_feature();
  inline void clear_has_feature();
  inline void set_has_feature_threshold();
  inline void clear_has_feature_threshold();
  inline void set_has_larger_than_threshold();
  inline void clear_has_larger_than_threshold();
  inline void set_has_true_leaf_weight();
  inline void clear_has_true_leaf_weight();
  inline void set_has_false_leaf_weight();
  inline void clear_has_false_leaf_weight();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::doppia_protobuf::IntegralChannelsFeature* feature_;
  float feature_threshold_;
  bool larger_than_threshold_;
  float true_leaf_weight_;
  float false_leaf_weight_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_detector_5fmodel_2eproto();
  friend void protobuf_AssignDesc_detector_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_detector_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static IntegralChannelDecisionStump* default_instance_;
};
// -------------------------------------------------------------------

class IntegralChannelBinaryDecisionTreeNode : public ::google::protobuf::Message {
 public:
  IntegralChannelBinaryDecisionTreeNode();
  virtual ~IntegralChannelBinaryDecisionTreeNode();

  IntegralChannelBinaryDecisionTreeNode(const IntegralChannelBinaryDecisionTreeNode& from);

  inline IntegralChannelBinaryDecisionTreeNode& operator=(const IntegralChannelBinaryDecisionTreeNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntegralChannelBinaryDecisionTreeNode& default_instance();

  void Swap(IntegralChannelBinaryDecisionTreeNode* other);

  // implements Message ----------------------------------------------

  IntegralChannelBinaryDecisionTreeNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntegralChannelBinaryDecisionTreeNode& from);
  void MergeFrom(const IntegralChannelBinaryDecisionTreeNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 parent_id = 2;
  inline bool has_parent_id() const;
  inline void clear_parent_id();
  static const int kParentIdFieldNumber = 2;
  inline ::google::protobuf::uint32 parent_id() const;
  inline void set_parent_id(::google::protobuf::uint32 value);

  // optional bool parent_value = 3;
  inline bool has_parent_value() const;
  inline void clear_parent_value();
  static const int kParentValueFieldNumber = 3;
  inline bool parent_value() const;
  inline void set_parent_value(bool value);

  // optional .doppia_protobuf.IntegralChannelDecisionStump decision_stump = 4;
  inline bool has_decision_stump() const;
  inline void clear_decision_stump();
  static const int kDecisionStumpFieldNumber = 4;
  inline const ::doppia_protobuf::IntegralChannelDecisionStump& decision_stump() const;
  inline ::doppia_protobuf::IntegralChannelDecisionStump* mutable_decision_stump();
  inline ::doppia_protobuf::IntegralChannelDecisionStump* release_decision_stump();
  inline void set_allocated_decision_stump(::doppia_protobuf::IntegralChannelDecisionStump* decision_stump);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.IntegralChannelBinaryDecisionTreeNode)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_parent_id();
  inline void clear_has_parent_id();
  inline void set_has_parent_value();
  inline void clear_has_parent_value();
  inline void set_has_decision_stump();
  inline void clear_has_decision_stump();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 parent_id_;
  ::doppia_protobuf::IntegralChannelDecisionStump* decision_stump_;
  bool parent_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_detector_5fmodel_2eproto();
  friend void protobuf_AssignDesc_detector_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_detector_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static IntegralChannelBinaryDecisionTreeNode* default_instance_;
};
// -------------------------------------------------------------------

class IntegralChannelBinaryDecisionTree : public ::google::protobuf::Message {
 public:
  IntegralChannelBinaryDecisionTree();
  virtual ~IntegralChannelBinaryDecisionTree();

  IntegralChannelBinaryDecisionTree(const IntegralChannelBinaryDecisionTree& from);

  inline IntegralChannelBinaryDecisionTree& operator=(const IntegralChannelBinaryDecisionTree& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntegralChannelBinaryDecisionTree& default_instance();

  void Swap(IntegralChannelBinaryDecisionTree* other);

  // implements Message ----------------------------------------------

  IntegralChannelBinaryDecisionTree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntegralChannelBinaryDecisionTree& from);
  void MergeFrom(const IntegralChannelBinaryDecisionTree& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .doppia_protobuf.IntegralChannelBinaryDecisionTreeNode nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::doppia_protobuf::IntegralChannelBinaryDecisionTreeNode& nodes(int index) const;
  inline ::doppia_protobuf::IntegralChannelBinaryDecisionTreeNode* mutable_nodes(int index);
  inline ::doppia_protobuf::IntegralChannelBinaryDecisionTreeNode* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::IntegralChannelBinaryDecisionTreeNode >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::IntegralChannelBinaryDecisionTreeNode >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:doppia_protobuf.IntegralChannelBinaryDecisionTree)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::IntegralChannelBinaryDecisionTreeNode > nodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_detector_5fmodel_2eproto();
  friend void protobuf_AssignDesc_detector_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_detector_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static IntegralChannelBinaryDecisionTree* default_instance_;
};
// -------------------------------------------------------------------

class IntegralChannelStumpSet : public ::google::protobuf::Message {
 public:
  IntegralChannelStumpSet();
  virtual ~IntegralChannelStumpSet();

  IntegralChannelStumpSet(const IntegralChannelStumpSet& from);

  inline IntegralChannelStumpSet& operator=(const IntegralChannelStumpSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntegralChannelStumpSet& default_instance();

  void Swap(IntegralChannelStumpSet* other);

  // implements Message ----------------------------------------------

  IntegralChannelStumpSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntegralChannelStumpSet& from);
  void MergeFrom(const IntegralChannelStumpSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .doppia_protobuf.IntegralChannelDecisionStump nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::doppia_protobuf::IntegralChannelDecisionStump& nodes(int index) const;
  inline ::doppia_protobuf::IntegralChannelDecisionStump* mutable_nodes(int index);
  inline ::doppia_protobuf::IntegralChannelDecisionStump* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::IntegralChannelDecisionStump >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::IntegralChannelDecisionStump >*
      mutable_nodes();

  // repeated float weights = 2;
  inline int weights_size() const;
  inline void clear_weights();
  static const int kWeightsFieldNumber = 2;
  inline float weights(int index) const;
  inline void set_weights(int index, float value);
  inline void add_weights(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      weights() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_weights();

  // @@protoc_insertion_point(class_scope:doppia_protobuf.IntegralChannelStumpSet)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::IntegralChannelDecisionStump > nodes_;
  ::google::protobuf::RepeatedField< float > weights_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_detector_5fmodel_2eproto();
  friend void protobuf_AssignDesc_detector_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_detector_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static IntegralChannelStumpSet* default_instance_;
};
// -------------------------------------------------------------------

class SoftCascadeOverIntegralChannelsStage : public ::google::protobuf::Message {
 public:
  SoftCascadeOverIntegralChannelsStage();
  virtual ~SoftCascadeOverIntegralChannelsStage();

  SoftCascadeOverIntegralChannelsStage(const SoftCascadeOverIntegralChannelsStage& from);

  inline SoftCascadeOverIntegralChannelsStage& operator=(const SoftCascadeOverIntegralChannelsStage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SoftCascadeOverIntegralChannelsStage& default_instance();

  void Swap(SoftCascadeOverIntegralChannelsStage* other);

  // implements Message ----------------------------------------------

  SoftCascadeOverIntegralChannelsStage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SoftCascadeOverIntegralChannelsStage& from);
  void MergeFrom(const SoftCascadeOverIntegralChannelsStage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SoftCascadeOverIntegralChannelsStage_FeatureTypes FeatureTypes;
  static const FeatureTypes Stumps = SoftCascadeOverIntegralChannelsStage_FeatureTypes_Stumps;
  static const FeatureTypes Level2DecisionTree = SoftCascadeOverIntegralChannelsStage_FeatureTypes_Level2DecisionTree;
  static const FeatureTypes LevelNDecisionTree = SoftCascadeOverIntegralChannelsStage_FeatureTypes_LevelNDecisionTree;
  static const FeatureTypes StumpSet = SoftCascadeOverIntegralChannelsStage_FeatureTypes_StumpSet;
  static inline bool FeatureTypes_IsValid(int value) {
    return SoftCascadeOverIntegralChannelsStage_FeatureTypes_IsValid(value);
  }
  static const FeatureTypes FeatureTypes_MIN =
    SoftCascadeOverIntegralChannelsStage_FeatureTypes_FeatureTypes_MIN;
  static const FeatureTypes FeatureTypes_MAX =
    SoftCascadeOverIntegralChannelsStage_FeatureTypes_FeatureTypes_MAX;
  static const int FeatureTypes_ARRAYSIZE =
    SoftCascadeOverIntegralChannelsStage_FeatureTypes_FeatureTypes_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FeatureTypes_descriptor() {
    return SoftCascadeOverIntegralChannelsStage_FeatureTypes_descriptor();
  }
  static inline const ::std::string& FeatureTypes_Name(FeatureTypes value) {
    return SoftCascadeOverIntegralChannelsStage_FeatureTypes_Name(value);
  }
  static inline bool FeatureTypes_Parse(const ::std::string& name,
      FeatureTypes* value) {
    return SoftCascadeOverIntegralChannelsStage_FeatureTypes_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .doppia_protobuf.SoftCascadeOverIntegralChannelsStage.FeatureTypes feature_type = 1;
  inline bool has_feature_type() const;
  inline void clear_feature_type();
  static const int kFeatureTypeFieldNumber = 1;
  inline ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage_FeatureTypes feature_type() const;
  inline void set_feature_type(::doppia_protobuf::SoftCascadeOverIntegralChannelsStage_FeatureTypes value);

  // optional .doppia_protobuf.IntegralChannelDecisionStump decision_stump = 10;
  inline bool has_decision_stump() const;
  inline void clear_decision_stump();
  static const int kDecisionStumpFieldNumber = 10;
  inline const ::doppia_protobuf::IntegralChannelDecisionStump& decision_stump() const;
  inline ::doppia_protobuf::IntegralChannelDecisionStump* mutable_decision_stump();
  inline ::doppia_protobuf::IntegralChannelDecisionStump* release_decision_stump();
  inline void set_allocated_decision_stump(::doppia_protobuf::IntegralChannelDecisionStump* decision_stump);

  // optional .doppia_protobuf.IntegralChannelBinaryDecisionTree level2_decision_tree = 11;
  inline bool has_level2_decision_tree() const;
  inline void clear_level2_decision_tree();
  static const int kLevel2DecisionTreeFieldNumber = 11;
  inline const ::doppia_protobuf::IntegralChannelBinaryDecisionTree& level2_decision_tree() const;
  inline ::doppia_protobuf::IntegralChannelBinaryDecisionTree* mutable_level2_decision_tree();
  inline ::doppia_protobuf::IntegralChannelBinaryDecisionTree* release_level2_decision_tree();
  inline void set_allocated_level2_decision_tree(::doppia_protobuf::IntegralChannelBinaryDecisionTree* level2_decision_tree);

  // optional .doppia_protobuf.IntegralChannelBinaryDecisionTree levelN_decision_tree = 12;
  inline bool has_leveln_decision_tree() const;
  inline void clear_leveln_decision_tree();
  static const int kLevelNDecisionTreeFieldNumber = 12;
  inline const ::doppia_protobuf::IntegralChannelBinaryDecisionTree& leveln_decision_tree() const;
  inline ::doppia_protobuf::IntegralChannelBinaryDecisionTree* mutable_leveln_decision_tree();
  inline ::doppia_protobuf::IntegralChannelBinaryDecisionTree* release_leveln_decision_tree();
  inline void set_allocated_leveln_decision_tree(::doppia_protobuf::IntegralChannelBinaryDecisionTree* leveln_decision_tree);

  // optional .doppia_protobuf.IntegralChannelStumpSet stump_set = 13;
  inline bool has_stump_set() const;
  inline void clear_stump_set();
  static const int kStumpSetFieldNumber = 13;
  inline const ::doppia_protobuf::IntegralChannelStumpSet& stump_set() const;
  inline ::doppia_protobuf::IntegralChannelStumpSet* mutable_stump_set();
  inline ::doppia_protobuf::IntegralChannelStumpSet* release_stump_set();
  inline void set_allocated_stump_set(::doppia_protobuf::IntegralChannelStumpSet* stump_set);

  // required float weight = 2;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 2;
  inline float weight() const;
  inline void set_weight(float value);

  // required float cascade_threshold = 3;
  inline bool has_cascade_threshold() const;
  inline void clear_cascade_threshold();
  static const int kCascadeThresholdFieldNumber = 3;
  inline float cascade_threshold() const;
  inline void set_cascade_threshold(float value);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.SoftCascadeOverIntegralChannelsStage)
 private:
  inline void set_has_feature_type();
  inline void clear_has_feature_type();
  inline void set_has_decision_stump();
  inline void clear_has_decision_stump();
  inline void set_has_level2_decision_tree();
  inline void clear_has_level2_decision_tree();
  inline void set_has_leveln_decision_tree();
  inline void clear_has_leveln_decision_tree();
  inline void set_has_stump_set();
  inline void clear_has_stump_set();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_cascade_threshold();
  inline void clear_has_cascade_threshold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::doppia_protobuf::IntegralChannelDecisionStump* decision_stump_;
  ::doppia_protobuf::IntegralChannelBinaryDecisionTree* level2_decision_tree_;
  int feature_type_;
  float weight_;
  ::doppia_protobuf::IntegralChannelBinaryDecisionTree* leveln_decision_tree_;
  ::doppia_protobuf::IntegralChannelStumpSet* stump_set_;
  float cascade_threshold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_detector_5fmodel_2eproto();
  friend void protobuf_AssignDesc_detector_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_detector_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static SoftCascadeOverIntegralChannelsStage* default_instance_;
};
// -------------------------------------------------------------------

class SoftCascadeOverIntegralChannelsModel : public ::google::protobuf::Message {
 public:
  SoftCascadeOverIntegralChannelsModel();
  virtual ~SoftCascadeOverIntegralChannelsModel();

  SoftCascadeOverIntegralChannelsModel(const SoftCascadeOverIntegralChannelsModel& from);

  inline SoftCascadeOverIntegralChannelsModel& operator=(const SoftCascadeOverIntegralChannelsModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SoftCascadeOverIntegralChannelsModel& default_instance();

  void Swap(SoftCascadeOverIntegralChannelsModel* other);

  // implements Message ----------------------------------------------

  SoftCascadeOverIntegralChannelsModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SoftCascadeOverIntegralChannelsModel& from);
  void MergeFrom(const SoftCascadeOverIntegralChannelsModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .doppia_protobuf.SoftCascadeOverIntegralChannelsStage stages = 1;
  inline int stages_size() const;
  inline void clear_stages();
  static const int kStagesFieldNumber = 1;
  inline const ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage& stages(int index) const;
  inline ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage* mutable_stages(int index);
  inline ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage* add_stages();
  inline const ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage >&
      stages() const;
  inline ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage >*
      mutable_stages();

  // optional string channels_description = 2 [default = "hog6_luv"];
  inline bool has_channels_description() const;
  inline void clear_channels_description();
  static const int kChannelsDescriptionFieldNumber = 2;
  inline const ::std::string& channels_description() const;
  inline void set_channels_description(const ::std::string& value);
  inline void set_channels_description(const char* value);
  inline void set_channels_description(const char* value, size_t size);
  inline ::std::string* mutable_channels_description();
  inline ::std::string* release_channels_description();
  inline void set_allocated_channels_description(::std::string* channels_description);

  // optional uint32 shrinking_factor = 3 [default = 4];
  inline bool has_shrinking_factor() const;
  inline void clear_shrinking_factor();
  static const int kShrinkingFactorFieldNumber = 3;
  inline ::google::protobuf::uint32 shrinking_factor() const;
  inline void set_shrinking_factor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.SoftCascadeOverIntegralChannelsModel)
 private:
  inline void set_has_channels_description();
  inline void clear_has_channels_description();
  inline void set_has_shrinking_factor();
  inline void clear_has_shrinking_factor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage > stages_;
  ::std::string* channels_description_;
  static ::std::string* _default_channels_description_;
  ::google::protobuf::uint32 shrinking_factor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_detector_5fmodel_2eproto();
  friend void protobuf_AssignDesc_detector_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_detector_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static SoftCascadeOverIntegralChannelsModel* default_instance_;
};
// -------------------------------------------------------------------

class DetectorModel : public ::google::protobuf::Message {
 public:
  DetectorModel();
  virtual ~DetectorModel();

  DetectorModel(const DetectorModel& from);

  inline DetectorModel& operator=(const DetectorModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectorModel& default_instance();

  void Swap(DetectorModel* other);

  // implements Message ----------------------------------------------

  DetectorModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DetectorModel& from);
  void MergeFrom(const DetectorModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DetectorModel_DetectorTypes DetectorTypes;
  static const DetectorTypes LinearSvm = DetectorModel_DetectorTypes_LinearSvm;
  static const DetectorTypes SoftCascadeOverIntegralChannels = DetectorModel_DetectorTypes_SoftCascadeOverIntegralChannels;
  static const DetectorTypes HoughForest = DetectorModel_DetectorTypes_HoughForest;
  static inline bool DetectorTypes_IsValid(int value) {
    return DetectorModel_DetectorTypes_IsValid(value);
  }
  static const DetectorTypes DetectorTypes_MIN =
    DetectorModel_DetectorTypes_DetectorTypes_MIN;
  static const DetectorTypes DetectorTypes_MAX =
    DetectorModel_DetectorTypes_DetectorTypes_MAX;
  static const int DetectorTypes_ARRAYSIZE =
    DetectorModel_DetectorTypes_DetectorTypes_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DetectorTypes_descriptor() {
    return DetectorModel_DetectorTypes_descriptor();
  }
  static inline const ::std::string& DetectorTypes_Name(DetectorTypes value) {
    return DetectorModel_DetectorTypes_Name(value);
  }
  static inline bool DetectorTypes_Parse(const ::std::string& name,
      DetectorTypes* value) {
    return DetectorModel_DetectorTypes_Parse(name, value);
  }

  typedef DetectorModel_OcclusionTypes OcclusionTypes;
  static const OcclusionTypes LeftOcclusion = DetectorModel_OcclusionTypes_LeftOcclusion;
  static const OcclusionTypes RightOcclusion = DetectorModel_OcclusionTypes_RightOcclusion;
  static const OcclusionTypes BottomOcclusion = DetectorModel_OcclusionTypes_BottomOcclusion;
  static const OcclusionTypes TopOcclusion = DetectorModel_OcclusionTypes_TopOcclusion;
  static inline bool OcclusionTypes_IsValid(int value) {
    return DetectorModel_OcclusionTypes_IsValid(value);
  }
  static const OcclusionTypes OcclusionTypes_MIN =
    DetectorModel_OcclusionTypes_OcclusionTypes_MIN;
  static const OcclusionTypes OcclusionTypes_MAX =
    DetectorModel_OcclusionTypes_OcclusionTypes_MAX;
  static const int OcclusionTypes_ARRAYSIZE =
    DetectorModel_OcclusionTypes_OcclusionTypes_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OcclusionTypes_descriptor() {
    return DetectorModel_OcclusionTypes_descriptor();
  }
  static inline const ::std::string& OcclusionTypes_Name(OcclusionTypes value) {
    return DetectorModel_OcclusionTypes_Name(value);
  }
  static inline bool OcclusionTypes_Parse(const ::std::string& name,
      OcclusionTypes* value) {
    return DetectorModel_OcclusionTypes_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string detector_name = 1;
  inline bool has_detector_name() const;
  inline void clear_detector_name();
  static const int kDetectorNameFieldNumber = 1;
  inline const ::std::string& detector_name() const;
  inline void set_detector_name(const ::std::string& value);
  inline void set_detector_name(const char* value);
  inline void set_detector_name(const char* value, size_t size);
  inline ::std::string* mutable_detector_name();
  inline ::std::string* release_detector_name();
  inline void set_allocated_detector_name(::std::string* detector_name);

  // required string training_dataset_name = 2;
  inline bool has_training_dataset_name() const;
  inline void clear_training_dataset_name();
  static const int kTrainingDatasetNameFieldNumber = 2;
  inline const ::std::string& training_dataset_name() const;
  inline void set_training_dataset_name(const ::std::string& value);
  inline void set_training_dataset_name(const char* value);
  inline void set_training_dataset_name(const char* value, size_t size);
  inline ::std::string* mutable_training_dataset_name();
  inline ::std::string* release_training_dataset_name();
  inline void set_allocated_training_dataset_name(::std::string* training_dataset_name);

  // optional string semantic_category = 300 [default = "/m/017r8p"];
  inline bool has_semantic_category() const;
  inline void clear_semantic_category();
  static const int kSemanticCategoryFieldNumber = 300;
  inline const ::std::string& semantic_category() const;
  inline void set_semantic_category(const ::std::string& value);
  inline void set_semantic_category(const char* value);
  inline void set_semantic_category(const char* value, size_t size);
  inline ::std::string* mutable_semantic_category();
  inline ::std::string* release_semantic_category();
  inline void set_allocated_semantic_category(::std::string* semantic_category);

  // optional .doppia_protobuf.Point2d model_window_size = 10;
  inline bool has_model_window_size() const;
  inline void clear_model_window_size();
  static const int kModelWindowSizeFieldNumber = 10;
  inline const ::doppia_protobuf::Point2d& model_window_size() const;
  inline ::doppia_protobuf::Point2d* mutable_model_window_size();
  inline ::doppia_protobuf::Point2d* release_model_window_size();
  inline void set_allocated_model_window_size(::doppia_protobuf::Point2d* model_window_size);

  // optional .doppia_protobuf.Box object_window = 11;
  inline bool has_object_window() const;
  inline void clear_object_window();
  static const int kObjectWindowFieldNumber = 11;
  inline const ::doppia_protobuf::Box& object_window() const;
  inline ::doppia_protobuf::Box* mutable_object_window();
  inline ::doppia_protobuf::Box* release_object_window();
  inline void set_allocated_object_window(::doppia_protobuf::Box* object_window);

  // required .doppia_protobuf.DetectorModel.DetectorTypes detector_type = 3;
  inline bool has_detector_type() const;
  inline void clear_detector_type();
  static const int kDetectorTypeFieldNumber = 3;
  inline ::doppia_protobuf::DetectorModel_DetectorTypes detector_type() const;
  inline void set_detector_type(::doppia_protobuf::DetectorModel_DetectorTypes value);

  // optional .doppia_protobuf.LinearSvmModel linear_svm_model = 100;
  inline bool has_linear_svm_model() const;
  inline void clear_linear_svm_model();
  static const int kLinearSvmModelFieldNumber = 100;
  inline const ::doppia_protobuf::LinearSvmModel& linear_svm_model() const;
  inline ::doppia_protobuf::LinearSvmModel* mutable_linear_svm_model();
  inline ::doppia_protobuf::LinearSvmModel* release_linear_svm_model();
  inline void set_allocated_linear_svm_model(::doppia_protobuf::LinearSvmModel* linear_svm_model);

  // optional .doppia_protobuf.SoftCascadeOverIntegralChannelsModel soft_cascade_model = 102;
  inline bool has_soft_cascade_model() const;
  inline void clear_soft_cascade_model();
  static const int kSoftCascadeModelFieldNumber = 102;
  inline const ::doppia_protobuf::SoftCascadeOverIntegralChannelsModel& soft_cascade_model() const;
  inline ::doppia_protobuf::SoftCascadeOverIntegralChannelsModel* mutable_soft_cascade_model();
  inline ::doppia_protobuf::SoftCascadeOverIntegralChannelsModel* release_soft_cascade_model();
  inline void set_allocated_soft_cascade_model(::doppia_protobuf::SoftCascadeOverIntegralChannelsModel* soft_cascade_model);

  // optional float scale = 200 [default = 1];
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 200;
  inline float scale() const;
  inline void set_scale(float value);

  // optional float occlusion_level = 210 [default = 0];
  inline bool has_occlusion_level() const;
  inline void clear_occlusion_level();
  static const int kOcclusionLevelFieldNumber = 210;
  inline float occlusion_level() const;
  inline void set_occlusion_level(float value);

  // optional .doppia_protobuf.DetectorModel.OcclusionTypes occlusion_type = 211 [default = BottomOcclusion];
  inline bool has_occlusion_type() const;
  inline void clear_occlusion_type();
  static const int kOcclusionTypeFieldNumber = 211;
  inline ::doppia_protobuf::DetectorModel_OcclusionTypes occlusion_type() const;
  inline void set_occlusion_type(::doppia_protobuf::DetectorModel_OcclusionTypes value);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.DetectorModel)
 private:
  inline void set_has_detector_name();
  inline void clear_has_detector_name();
  inline void set_has_training_dataset_name();
  inline void clear_has_training_dataset_name();
  inline void set_has_semantic_category();
  inline void clear_has_semantic_category();
  inline void set_has_model_window_size();
  inline void clear_has_model_window_size();
  inline void set_has_object_window();
  inline void clear_has_object_window();
  inline void set_has_detector_type();
  inline void clear_has_detector_type();
  inline void set_has_linear_svm_model();
  inline void clear_has_linear_svm_model();
  inline void set_has_soft_cascade_model();
  inline void clear_has_soft_cascade_model();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_occlusion_level();
  inline void clear_has_occlusion_level();
  inline void set_has_occlusion_type();
  inline void clear_has_occlusion_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* detector_name_;
  ::std::string* training_dataset_name_;
  ::std::string* semantic_category_;
  static ::std::string* _default_semantic_category_;
  ::doppia_protobuf::Point2d* model_window_size_;
  ::doppia_protobuf::Box* object_window_;
  ::doppia_protobuf::LinearSvmModel* linear_svm_model_;
  int detector_type_;
  float scale_;
  ::doppia_protobuf::SoftCascadeOverIntegralChannelsModel* soft_cascade_model_;
  float occlusion_level_;
  int occlusion_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_detector_5fmodel_2eproto();
  friend void protobuf_AssignDesc_detector_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_detector_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static DetectorModel* default_instance_;
};
// -------------------------------------------------------------------

class MultiScalesDetectorModel : public ::google::protobuf::Message {
 public:
  MultiScalesDetectorModel();
  virtual ~MultiScalesDetectorModel();

  MultiScalesDetectorModel(const MultiScalesDetectorModel& from);

  inline MultiScalesDetectorModel& operator=(const MultiScalesDetectorModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiScalesDetectorModel& default_instance();

  void Swap(MultiScalesDetectorModel* other);

  // implements Message ----------------------------------------------

  MultiScalesDetectorModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultiScalesDetectorModel& from);
  void MergeFrom(const MultiScalesDetectorModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string detector_name = 1;
  inline bool has_detector_name() const;
  inline void clear_detector_name();
  static const int kDetectorNameFieldNumber = 1;
  inline const ::std::string& detector_name() const;
  inline void set_detector_name(const ::std::string& value);
  inline void set_detector_name(const char* value);
  inline void set_detector_name(const char* value, size_t size);
  inline ::std::string* mutable_detector_name();
  inline ::std::string* release_detector_name();
  inline void set_allocated_detector_name(::std::string* detector_name);

  // required string training_dataset_name = 2;
  inline bool has_training_dataset_name() const;
  inline void clear_training_dataset_name();
  static const int kTrainingDatasetNameFieldNumber = 2;
  inline const ::std::string& training_dataset_name() const;
  inline void set_training_dataset_name(const ::std::string& value);
  inline void set_training_dataset_name(const char* value);
  inline void set_training_dataset_name(const char* value, size_t size);
  inline ::std::string* mutable_training_dataset_name();
  inline ::std::string* release_training_dataset_name();
  inline void set_allocated_training_dataset_name(::std::string* training_dataset_name);

  // repeated .doppia_protobuf.DetectorModel detectors = 3;
  inline int detectors_size() const;
  inline void clear_detectors();
  static const int kDetectorsFieldNumber = 3;
  inline const ::doppia_protobuf::DetectorModel& detectors(int index) const;
  inline ::doppia_protobuf::DetectorModel* mutable_detectors(int index);
  inline ::doppia_protobuf::DetectorModel* add_detectors();
  inline const ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::DetectorModel >&
      detectors() const;
  inline ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::DetectorModel >*
      mutable_detectors();

  // @@protoc_insertion_point(class_scope:doppia_protobuf.MultiScalesDetectorModel)
 private:
  inline void set_has_detector_name();
  inline void clear_has_detector_name();
  inline void set_has_training_dataset_name();
  inline void clear_has_training_dataset_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* detector_name_;
  ::std::string* training_dataset_name_;
  ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::DetectorModel > detectors_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_detector_5fmodel_2eproto();
  friend void protobuf_AssignDesc_detector_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_detector_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static MultiScalesDetectorModel* default_instance_;
};
// -------------------------------------------------------------------

class DetectorModelsBundle : public ::google::protobuf::Message {
 public:
  DetectorModelsBundle();
  virtual ~DetectorModelsBundle();

  DetectorModelsBundle(const DetectorModelsBundle& from);

  inline DetectorModelsBundle& operator=(const DetectorModelsBundle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectorModelsBundle& default_instance();

  void Swap(DetectorModelsBundle* other);

  // implements Message ----------------------------------------------

  DetectorModelsBundle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DetectorModelsBundle& from);
  void MergeFrom(const DetectorModelsBundle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string bundle_name = 1;
  inline bool has_bundle_name() const;
  inline void clear_bundle_name();
  static const int kBundleNameFieldNumber = 1;
  inline const ::std::string& bundle_name() const;
  inline void set_bundle_name(const ::std::string& value);
  inline void set_bundle_name(const char* value);
  inline void set_bundle_name(const char* value, size_t size);
  inline ::std::string* mutable_bundle_name();
  inline ::std::string* release_bundle_name();
  inline void set_allocated_bundle_name(::std::string* bundle_name);

  // required string training_dataset_name = 2;
  inline bool has_training_dataset_name() const;
  inline void clear_training_dataset_name();
  static const int kTrainingDatasetNameFieldNumber = 2;
  inline const ::std::string& training_dataset_name() const;
  inline void set_training_dataset_name(const ::std::string& value);
  inline void set_training_dataset_name(const char* value);
  inline void set_training_dataset_name(const char* value, size_t size);
  inline ::std::string* mutable_training_dataset_name();
  inline ::std::string* release_training_dataset_name();
  inline void set_allocated_training_dataset_name(::std::string* training_dataset_name);

  // repeated .doppia_protobuf.DetectorModel detectors = 3;
  inline int detectors_size() const;
  inline void clear_detectors();
  static const int kDetectorsFieldNumber = 3;
  inline const ::doppia_protobuf::DetectorModel& detectors(int index) const;
  inline ::doppia_protobuf::DetectorModel* mutable_detectors(int index);
  inline ::doppia_protobuf::DetectorModel* add_detectors();
  inline const ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::DetectorModel >&
      detectors() const;
  inline ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::DetectorModel >*
      mutable_detectors();

  // @@protoc_insertion_point(class_scope:doppia_protobuf.DetectorModelsBundle)
 private:
  inline void set_has_bundle_name();
  inline void clear_has_bundle_name();
  inline void set_has_training_dataset_name();
  inline void clear_has_training_dataset_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bundle_name_;
  ::std::string* training_dataset_name_;
  ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::DetectorModel > detectors_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_detector_5fmodel_2eproto();
  friend void protobuf_AssignDesc_detector_5fmodel_2eproto();
  friend void protobuf_ShutdownFile_detector_5fmodel_2eproto();

  void InitAsDefaultInstance();
  static DetectorModelsBundle* default_instance_;
};
// ===================================================================


// ===================================================================

// LinearSvmModel

// optional string solved_type = 1;
inline bool LinearSvmModel::has_solved_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinearSvmModel::set_has_solved_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinearSvmModel::clear_has_solved_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinearSvmModel::clear_solved_type() {
  if (solved_type_ != &::google::protobuf::internal::kEmptyString) {
    solved_type_->clear();
  }
  clear_has_solved_type();
}
inline const ::std::string& LinearSvmModel::solved_type() const {
  return *solved_type_;
}
inline void LinearSvmModel::set_solved_type(const ::std::string& value) {
  set_has_solved_type();
  if (solved_type_ == &::google::protobuf::internal::kEmptyString) {
    solved_type_ = new ::std::string;
  }
  solved_type_->assign(value);
}
inline void LinearSvmModel::set_solved_type(const char* value) {
  set_has_solved_type();
  if (solved_type_ == &::google::protobuf::internal::kEmptyString) {
    solved_type_ = new ::std::string;
  }
  solved_type_->assign(value);
}
inline void LinearSvmModel::set_solved_type(const char* value, size_t size) {
  set_has_solved_type();
  if (solved_type_ == &::google::protobuf::internal::kEmptyString) {
    solved_type_ = new ::std::string;
  }
  solved_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LinearSvmModel::mutable_solved_type() {
  set_has_solved_type();
  if (solved_type_ == &::google::protobuf::internal::kEmptyString) {
    solved_type_ = new ::std::string;
  }
  return solved_type_;
}
inline ::std::string* LinearSvmModel::release_solved_type() {
  clear_has_solved_type();
  if (solved_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = solved_type_;
    solved_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LinearSvmModel::set_allocated_solved_type(::std::string* solved_type) {
  if (solved_type_ != &::google::protobuf::internal::kEmptyString) {
    delete solved_type_;
  }
  if (solved_type) {
    set_has_solved_type();
    solved_type_ = solved_type;
  } else {
    clear_has_solved_type();
    solved_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 number_of_classes = 2;
inline bool LinearSvmModel::has_number_of_classes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LinearSvmModel::set_has_number_of_classes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LinearSvmModel::clear_has_number_of_classes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LinearSvmModel::clear_number_of_classes() {
  number_of_classes_ = 0u;
  clear_has_number_of_classes();
}
inline ::google::protobuf::uint32 LinearSvmModel::number_of_classes() const {
  return number_of_classes_;
}
inline void LinearSvmModel::set_number_of_classes(::google::protobuf::uint32 value) {
  set_has_number_of_classes();
  number_of_classes_ = value;
}

// repeated int32 labels = 3;
inline int LinearSvmModel::labels_size() const {
  return labels_.size();
}
inline void LinearSvmModel::clear_labels() {
  labels_.Clear();
}
inline ::google::protobuf::int32 LinearSvmModel::labels(int index) const {
  return labels_.Get(index);
}
inline void LinearSvmModel::set_labels(int index, ::google::protobuf::int32 value) {
  labels_.Set(index, value);
}
inline void LinearSvmModel::add_labels(::google::protobuf::int32 value) {
  labels_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LinearSvmModel::labels() const {
  return labels_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LinearSvmModel::mutable_labels() {
  return &labels_;
}

// optional uint32 number_of_features = 4;
inline bool LinearSvmModel::has_number_of_features() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LinearSvmModel::set_has_number_of_features() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LinearSvmModel::clear_has_number_of_features() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LinearSvmModel::clear_number_of_features() {
  number_of_features_ = 0u;
  clear_has_number_of_features();
}
inline ::google::protobuf::uint32 LinearSvmModel::number_of_features() const {
  return number_of_features_;
}
inline void LinearSvmModel::set_number_of_features(::google::protobuf::uint32 value) {
  set_has_number_of_features();
  number_of_features_ = value;
}

// required float bias = 5;
inline bool LinearSvmModel::has_bias() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LinearSvmModel::set_has_bias() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LinearSvmModel::clear_has_bias() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LinearSvmModel::clear_bias() {
  bias_ = 0;
  clear_has_bias();
}
inline float LinearSvmModel::bias() const {
  return bias_;
}
inline void LinearSvmModel::set_bias(float value) {
  set_has_bias();
  bias_ = value;
}

// repeated float w = 6;
inline int LinearSvmModel::w_size() const {
  return w_.size();
}
inline void LinearSvmModel::clear_w() {
  w_.Clear();
}
inline float LinearSvmModel::w(int index) const {
  return w_.Get(index);
}
inline void LinearSvmModel::set_w(int index, float value) {
  w_.Set(index, value);
}
inline void LinearSvmModel::add_w(float value) {
  w_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
LinearSvmModel::w() const {
  return w_;
}
inline ::google::protobuf::RepeatedField< float >*
LinearSvmModel::mutable_w() {
  return &w_;
}

// -------------------------------------------------------------------

// IntegralChannelsFeature

// required int32 channel_index = 1;
inline bool IntegralChannelsFeature::has_channel_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntegralChannelsFeature::set_has_channel_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntegralChannelsFeature::clear_has_channel_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntegralChannelsFeature::clear_channel_index() {
  channel_index_ = 0;
  clear_has_channel_index();
}
inline ::google::protobuf::int32 IntegralChannelsFeature::channel_index() const {
  return channel_index_;
}
inline void IntegralChannelsFeature::set_channel_index(::google::protobuf::int32 value) {
  set_has_channel_index();
  channel_index_ = value;
}

// required .doppia_protobuf.Box box = 2;
inline bool IntegralChannelsFeature::has_box() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IntegralChannelsFeature::set_has_box() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IntegralChannelsFeature::clear_has_box() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IntegralChannelsFeature::clear_box() {
  if (box_ != NULL) box_->::doppia_protobuf::Box::Clear();
  clear_has_box();
}
inline const ::doppia_protobuf::Box& IntegralChannelsFeature::box() const {
  return box_ != NULL ? *box_ : *default_instance_->box_;
}
inline ::doppia_protobuf::Box* IntegralChannelsFeature::mutable_box() {
  set_has_box();
  if (box_ == NULL) box_ = new ::doppia_protobuf::Box;
  return box_;
}
inline ::doppia_protobuf::Box* IntegralChannelsFeature::release_box() {
  clear_has_box();
  ::doppia_protobuf::Box* temp = box_;
  box_ = NULL;
  return temp;
}
inline void IntegralChannelsFeature::set_allocated_box(::doppia_protobuf::Box* box) {
  delete box_;
  box_ = box;
  if (box) {
    set_has_box();
  } else {
    clear_has_box();
  }
}

// -------------------------------------------------------------------

// IntegralChannelDecisionStump

// required .doppia_protobuf.IntegralChannelsFeature feature = 1;
inline bool IntegralChannelDecisionStump::has_feature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntegralChannelDecisionStump::set_has_feature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntegralChannelDecisionStump::clear_has_feature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntegralChannelDecisionStump::clear_feature() {
  if (feature_ != NULL) feature_->::doppia_protobuf::IntegralChannelsFeature::Clear();
  clear_has_feature();
}
inline const ::doppia_protobuf::IntegralChannelsFeature& IntegralChannelDecisionStump::feature() const {
  return feature_ != NULL ? *feature_ : *default_instance_->feature_;
}
inline ::doppia_protobuf::IntegralChannelsFeature* IntegralChannelDecisionStump::mutable_feature() {
  set_has_feature();
  if (feature_ == NULL) feature_ = new ::doppia_protobuf::IntegralChannelsFeature;
  return feature_;
}
inline ::doppia_protobuf::IntegralChannelsFeature* IntegralChannelDecisionStump::release_feature() {
  clear_has_feature();
  ::doppia_protobuf::IntegralChannelsFeature* temp = feature_;
  feature_ = NULL;
  return temp;
}
inline void IntegralChannelDecisionStump::set_allocated_feature(::doppia_protobuf::IntegralChannelsFeature* feature) {
  delete feature_;
  feature_ = feature;
  if (feature) {
    set_has_feature();
  } else {
    clear_has_feature();
  }
}

// required float feature_threshold = 2;
inline bool IntegralChannelDecisionStump::has_feature_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IntegralChannelDecisionStump::set_has_feature_threshold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IntegralChannelDecisionStump::clear_has_feature_threshold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IntegralChannelDecisionStump::clear_feature_threshold() {
  feature_threshold_ = 0;
  clear_has_feature_threshold();
}
inline float IntegralChannelDecisionStump::feature_threshold() const {
  return feature_threshold_;
}
inline void IntegralChannelDecisionStump::set_feature_threshold(float value) {
  set_has_feature_threshold();
  feature_threshold_ = value;
}

// optional bool larger_than_threshold = 3 [default = false];
inline bool IntegralChannelDecisionStump::has_larger_than_threshold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IntegralChannelDecisionStump::set_has_larger_than_threshold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IntegralChannelDecisionStump::clear_has_larger_than_threshold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IntegralChannelDecisionStump::clear_larger_than_threshold() {
  larger_than_threshold_ = false;
  clear_has_larger_than_threshold();
}
inline bool IntegralChannelDecisionStump::larger_than_threshold() const {
  return larger_than_threshold_;
}
inline void IntegralChannelDecisionStump::set_larger_than_threshold(bool value) {
  set_has_larger_than_threshold();
  larger_than_threshold_ = value;
}

// optional float true_leaf_weight = 10;
inline bool IntegralChannelDecisionStump::has_true_leaf_weight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IntegralChannelDecisionStump::set_has_true_leaf_weight() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IntegralChannelDecisionStump::clear_has_true_leaf_weight() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IntegralChannelDecisionStump::clear_true_leaf_weight() {
  true_leaf_weight_ = 0;
  clear_has_true_leaf_weight();
}
inline float IntegralChannelDecisionStump::true_leaf_weight() const {
  return true_leaf_weight_;
}
inline void IntegralChannelDecisionStump::set_true_leaf_weight(float value) {
  set_has_true_leaf_weight();
  true_leaf_weight_ = value;
}

// optional float false_leaf_weight = 11;
inline bool IntegralChannelDecisionStump::has_false_leaf_weight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IntegralChannelDecisionStump::set_has_false_leaf_weight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IntegralChannelDecisionStump::clear_has_false_leaf_weight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IntegralChannelDecisionStump::clear_false_leaf_weight() {
  false_leaf_weight_ = 0;
  clear_has_false_leaf_weight();
}
inline float IntegralChannelDecisionStump::false_leaf_weight() const {
  return false_leaf_weight_;
}
inline void IntegralChannelDecisionStump::set_false_leaf_weight(float value) {
  set_has_false_leaf_weight();
  false_leaf_weight_ = value;
}

// -------------------------------------------------------------------

// IntegralChannelBinaryDecisionTreeNode

// required uint32 id = 1;
inline bool IntegralChannelBinaryDecisionTreeNode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntegralChannelBinaryDecisionTreeNode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntegralChannelBinaryDecisionTreeNode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntegralChannelBinaryDecisionTreeNode::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 IntegralChannelBinaryDecisionTreeNode::id() const {
  return id_;
}
inline void IntegralChannelBinaryDecisionTreeNode::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 parent_id = 2;
inline bool IntegralChannelBinaryDecisionTreeNode::has_parent_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IntegralChannelBinaryDecisionTreeNode::set_has_parent_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IntegralChannelBinaryDecisionTreeNode::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IntegralChannelBinaryDecisionTreeNode::clear_parent_id() {
  parent_id_ = 0u;
  clear_has_parent_id();
}
inline ::google::protobuf::uint32 IntegralChannelBinaryDecisionTreeNode::parent_id() const {
  return parent_id_;
}
inline void IntegralChannelBinaryDecisionTreeNode::set_parent_id(::google::protobuf::uint32 value) {
  set_has_parent_id();
  parent_id_ = value;
}

// optional bool parent_value = 3;
inline bool IntegralChannelBinaryDecisionTreeNode::has_parent_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IntegralChannelBinaryDecisionTreeNode::set_has_parent_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IntegralChannelBinaryDecisionTreeNode::clear_has_parent_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IntegralChannelBinaryDecisionTreeNode::clear_parent_value() {
  parent_value_ = false;
  clear_has_parent_value();
}
inline bool IntegralChannelBinaryDecisionTreeNode::parent_value() const {
  return parent_value_;
}
inline void IntegralChannelBinaryDecisionTreeNode::set_parent_value(bool value) {
  set_has_parent_value();
  parent_value_ = value;
}

// optional .doppia_protobuf.IntegralChannelDecisionStump decision_stump = 4;
inline bool IntegralChannelBinaryDecisionTreeNode::has_decision_stump() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IntegralChannelBinaryDecisionTreeNode::set_has_decision_stump() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IntegralChannelBinaryDecisionTreeNode::clear_has_decision_stump() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IntegralChannelBinaryDecisionTreeNode::clear_decision_stump() {
  if (decision_stump_ != NULL) decision_stump_->::doppia_protobuf::IntegralChannelDecisionStump::Clear();
  clear_has_decision_stump();
}
inline const ::doppia_protobuf::IntegralChannelDecisionStump& IntegralChannelBinaryDecisionTreeNode::decision_stump() const {
  return decision_stump_ != NULL ? *decision_stump_ : *default_instance_->decision_stump_;
}
inline ::doppia_protobuf::IntegralChannelDecisionStump* IntegralChannelBinaryDecisionTreeNode::mutable_decision_stump() {
  set_has_decision_stump();
  if (decision_stump_ == NULL) decision_stump_ = new ::doppia_protobuf::IntegralChannelDecisionStump;
  return decision_stump_;
}
inline ::doppia_protobuf::IntegralChannelDecisionStump* IntegralChannelBinaryDecisionTreeNode::release_decision_stump() {
  clear_has_decision_stump();
  ::doppia_protobuf::IntegralChannelDecisionStump* temp = decision_stump_;
  decision_stump_ = NULL;
  return temp;
}
inline void IntegralChannelBinaryDecisionTreeNode::set_allocated_decision_stump(::doppia_protobuf::IntegralChannelDecisionStump* decision_stump) {
  delete decision_stump_;
  decision_stump_ = decision_stump;
  if (decision_stump) {
    set_has_decision_stump();
  } else {
    clear_has_decision_stump();
  }
}

// -------------------------------------------------------------------

// IntegralChannelBinaryDecisionTree

// repeated .doppia_protobuf.IntegralChannelBinaryDecisionTreeNode nodes = 1;
inline int IntegralChannelBinaryDecisionTree::nodes_size() const {
  return nodes_.size();
}
inline void IntegralChannelBinaryDecisionTree::clear_nodes() {
  nodes_.Clear();
}
inline const ::doppia_protobuf::IntegralChannelBinaryDecisionTreeNode& IntegralChannelBinaryDecisionTree::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::doppia_protobuf::IntegralChannelBinaryDecisionTreeNode* IntegralChannelBinaryDecisionTree::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::doppia_protobuf::IntegralChannelBinaryDecisionTreeNode* IntegralChannelBinaryDecisionTree::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::IntegralChannelBinaryDecisionTreeNode >&
IntegralChannelBinaryDecisionTree::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::IntegralChannelBinaryDecisionTreeNode >*
IntegralChannelBinaryDecisionTree::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// IntegralChannelStumpSet

// repeated .doppia_protobuf.IntegralChannelDecisionStump nodes = 1;
inline int IntegralChannelStumpSet::nodes_size() const {
  return nodes_.size();
}
inline void IntegralChannelStumpSet::clear_nodes() {
  nodes_.Clear();
}
inline const ::doppia_protobuf::IntegralChannelDecisionStump& IntegralChannelStumpSet::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::doppia_protobuf::IntegralChannelDecisionStump* IntegralChannelStumpSet::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::doppia_protobuf::IntegralChannelDecisionStump* IntegralChannelStumpSet::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::IntegralChannelDecisionStump >&
IntegralChannelStumpSet::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::IntegralChannelDecisionStump >*
IntegralChannelStumpSet::mutable_nodes() {
  return &nodes_;
}

// repeated float weights = 2;
inline int IntegralChannelStumpSet::weights_size() const {
  return weights_.size();
}
inline void IntegralChannelStumpSet::clear_weights() {
  weights_.Clear();
}
inline float IntegralChannelStumpSet::weights(int index) const {
  return weights_.Get(index);
}
inline void IntegralChannelStumpSet::set_weights(int index, float value) {
  weights_.Set(index, value);
}
inline void IntegralChannelStumpSet::add_weights(float value) {
  weights_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
IntegralChannelStumpSet::weights() const {
  return weights_;
}
inline ::google::protobuf::RepeatedField< float >*
IntegralChannelStumpSet::mutable_weights() {
  return &weights_;
}

// -------------------------------------------------------------------

// SoftCascadeOverIntegralChannelsStage

// required .doppia_protobuf.SoftCascadeOverIntegralChannelsStage.FeatureTypes feature_type = 1;
inline bool SoftCascadeOverIntegralChannelsStage::has_feature_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SoftCascadeOverIntegralChannelsStage::set_has_feature_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SoftCascadeOverIntegralChannelsStage::clear_has_feature_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SoftCascadeOverIntegralChannelsStage::clear_feature_type() {
  feature_type_ = 0;
  clear_has_feature_type();
}
inline ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage_FeatureTypes SoftCascadeOverIntegralChannelsStage::feature_type() const {
  return static_cast< ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage_FeatureTypes >(feature_type_);
}
inline void SoftCascadeOverIntegralChannelsStage::set_feature_type(::doppia_protobuf::SoftCascadeOverIntegralChannelsStage_FeatureTypes value) {
  assert(::doppia_protobuf::SoftCascadeOverIntegralChannelsStage_FeatureTypes_IsValid(value));
  set_has_feature_type();
  feature_type_ = value;
}

// optional .doppia_protobuf.IntegralChannelDecisionStump decision_stump = 10;
inline bool SoftCascadeOverIntegralChannelsStage::has_decision_stump() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SoftCascadeOverIntegralChannelsStage::set_has_decision_stump() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SoftCascadeOverIntegralChannelsStage::clear_has_decision_stump() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SoftCascadeOverIntegralChannelsStage::clear_decision_stump() {
  if (decision_stump_ != NULL) decision_stump_->::doppia_protobuf::IntegralChannelDecisionStump::Clear();
  clear_has_decision_stump();
}
inline const ::doppia_protobuf::IntegralChannelDecisionStump& SoftCascadeOverIntegralChannelsStage::decision_stump() const {
  return decision_stump_ != NULL ? *decision_stump_ : *default_instance_->decision_stump_;
}
inline ::doppia_protobuf::IntegralChannelDecisionStump* SoftCascadeOverIntegralChannelsStage::mutable_decision_stump() {
  set_has_decision_stump();
  if (decision_stump_ == NULL) decision_stump_ = new ::doppia_protobuf::IntegralChannelDecisionStump;
  return decision_stump_;
}
inline ::doppia_protobuf::IntegralChannelDecisionStump* SoftCascadeOverIntegralChannelsStage::release_decision_stump() {
  clear_has_decision_stump();
  ::doppia_protobuf::IntegralChannelDecisionStump* temp = decision_stump_;
  decision_stump_ = NULL;
  return temp;
}
inline void SoftCascadeOverIntegralChannelsStage::set_allocated_decision_stump(::doppia_protobuf::IntegralChannelDecisionStump* decision_stump) {
  delete decision_stump_;
  decision_stump_ = decision_stump;
  if (decision_stump) {
    set_has_decision_stump();
  } else {
    clear_has_decision_stump();
  }
}

// optional .doppia_protobuf.IntegralChannelBinaryDecisionTree level2_decision_tree = 11;
inline bool SoftCascadeOverIntegralChannelsStage::has_level2_decision_tree() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SoftCascadeOverIntegralChannelsStage::set_has_level2_decision_tree() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SoftCascadeOverIntegralChannelsStage::clear_has_level2_decision_tree() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SoftCascadeOverIntegralChannelsStage::clear_level2_decision_tree() {
  if (level2_decision_tree_ != NULL) level2_decision_tree_->::doppia_protobuf::IntegralChannelBinaryDecisionTree::Clear();
  clear_has_level2_decision_tree();
}
inline const ::doppia_protobuf::IntegralChannelBinaryDecisionTree& SoftCascadeOverIntegralChannelsStage::level2_decision_tree() const {
  return level2_decision_tree_ != NULL ? *level2_decision_tree_ : *default_instance_->level2_decision_tree_;
}
inline ::doppia_protobuf::IntegralChannelBinaryDecisionTree* SoftCascadeOverIntegralChannelsStage::mutable_level2_decision_tree() {
  set_has_level2_decision_tree();
  if (level2_decision_tree_ == NULL) level2_decision_tree_ = new ::doppia_protobuf::IntegralChannelBinaryDecisionTree;
  return level2_decision_tree_;
}
inline ::doppia_protobuf::IntegralChannelBinaryDecisionTree* SoftCascadeOverIntegralChannelsStage::release_level2_decision_tree() {
  clear_has_level2_decision_tree();
  ::doppia_protobuf::IntegralChannelBinaryDecisionTree* temp = level2_decision_tree_;
  level2_decision_tree_ = NULL;
  return temp;
}
inline void SoftCascadeOverIntegralChannelsStage::set_allocated_level2_decision_tree(::doppia_protobuf::IntegralChannelBinaryDecisionTree* level2_decision_tree) {
  delete level2_decision_tree_;
  level2_decision_tree_ = level2_decision_tree;
  if (level2_decision_tree) {
    set_has_level2_decision_tree();
  } else {
    clear_has_level2_decision_tree();
  }
}

// optional .doppia_protobuf.IntegralChannelBinaryDecisionTree levelN_decision_tree = 12;
inline bool SoftCascadeOverIntegralChannelsStage::has_leveln_decision_tree() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SoftCascadeOverIntegralChannelsStage::set_has_leveln_decision_tree() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SoftCascadeOverIntegralChannelsStage::clear_has_leveln_decision_tree() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SoftCascadeOverIntegralChannelsStage::clear_leveln_decision_tree() {
  if (leveln_decision_tree_ != NULL) leveln_decision_tree_->::doppia_protobuf::IntegralChannelBinaryDecisionTree::Clear();
  clear_has_leveln_decision_tree();
}
inline const ::doppia_protobuf::IntegralChannelBinaryDecisionTree& SoftCascadeOverIntegralChannelsStage::leveln_decision_tree() const {
  return leveln_decision_tree_ != NULL ? *leveln_decision_tree_ : *default_instance_->leveln_decision_tree_;
}
inline ::doppia_protobuf::IntegralChannelBinaryDecisionTree* SoftCascadeOverIntegralChannelsStage::mutable_leveln_decision_tree() {
  set_has_leveln_decision_tree();
  if (leveln_decision_tree_ == NULL) leveln_decision_tree_ = new ::doppia_protobuf::IntegralChannelBinaryDecisionTree;
  return leveln_decision_tree_;
}
inline ::doppia_protobuf::IntegralChannelBinaryDecisionTree* SoftCascadeOverIntegralChannelsStage::release_leveln_decision_tree() {
  clear_has_leveln_decision_tree();
  ::doppia_protobuf::IntegralChannelBinaryDecisionTree* temp = leveln_decision_tree_;
  leveln_decision_tree_ = NULL;
  return temp;
}
inline void SoftCascadeOverIntegralChannelsStage::set_allocated_leveln_decision_tree(::doppia_protobuf::IntegralChannelBinaryDecisionTree* leveln_decision_tree) {
  delete leveln_decision_tree_;
  leveln_decision_tree_ = leveln_decision_tree;
  if (leveln_decision_tree) {
    set_has_leveln_decision_tree();
  } else {
    clear_has_leveln_decision_tree();
  }
}

// optional .doppia_protobuf.IntegralChannelStumpSet stump_set = 13;
inline bool SoftCascadeOverIntegralChannelsStage::has_stump_set() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SoftCascadeOverIntegralChannelsStage::set_has_stump_set() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SoftCascadeOverIntegralChannelsStage::clear_has_stump_set() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SoftCascadeOverIntegralChannelsStage::clear_stump_set() {
  if (stump_set_ != NULL) stump_set_->::doppia_protobuf::IntegralChannelStumpSet::Clear();
  clear_has_stump_set();
}
inline const ::doppia_protobuf::IntegralChannelStumpSet& SoftCascadeOverIntegralChannelsStage::stump_set() const {
  return stump_set_ != NULL ? *stump_set_ : *default_instance_->stump_set_;
}
inline ::doppia_protobuf::IntegralChannelStumpSet* SoftCascadeOverIntegralChannelsStage::mutable_stump_set() {
  set_has_stump_set();
  if (stump_set_ == NULL) stump_set_ = new ::doppia_protobuf::IntegralChannelStumpSet;
  return stump_set_;
}
inline ::doppia_protobuf::IntegralChannelStumpSet* SoftCascadeOverIntegralChannelsStage::release_stump_set() {
  clear_has_stump_set();
  ::doppia_protobuf::IntegralChannelStumpSet* temp = stump_set_;
  stump_set_ = NULL;
  return temp;
}
inline void SoftCascadeOverIntegralChannelsStage::set_allocated_stump_set(::doppia_protobuf::IntegralChannelStumpSet* stump_set) {
  delete stump_set_;
  stump_set_ = stump_set;
  if (stump_set) {
    set_has_stump_set();
  } else {
    clear_has_stump_set();
  }
}

// required float weight = 2;
inline bool SoftCascadeOverIntegralChannelsStage::has_weight() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SoftCascadeOverIntegralChannelsStage::set_has_weight() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SoftCascadeOverIntegralChannelsStage::clear_has_weight() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SoftCascadeOverIntegralChannelsStage::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline float SoftCascadeOverIntegralChannelsStage::weight() const {
  return weight_;
}
inline void SoftCascadeOverIntegralChannelsStage::set_weight(float value) {
  set_has_weight();
  weight_ = value;
}

// required float cascade_threshold = 3;
inline bool SoftCascadeOverIntegralChannelsStage::has_cascade_threshold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SoftCascadeOverIntegralChannelsStage::set_has_cascade_threshold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SoftCascadeOverIntegralChannelsStage::clear_has_cascade_threshold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SoftCascadeOverIntegralChannelsStage::clear_cascade_threshold() {
  cascade_threshold_ = 0;
  clear_has_cascade_threshold();
}
inline float SoftCascadeOverIntegralChannelsStage::cascade_threshold() const {
  return cascade_threshold_;
}
inline void SoftCascadeOverIntegralChannelsStage::set_cascade_threshold(float value) {
  set_has_cascade_threshold();
  cascade_threshold_ = value;
}

// -------------------------------------------------------------------

// SoftCascadeOverIntegralChannelsModel

// repeated .doppia_protobuf.SoftCascadeOverIntegralChannelsStage stages = 1;
inline int SoftCascadeOverIntegralChannelsModel::stages_size() const {
  return stages_.size();
}
inline void SoftCascadeOverIntegralChannelsModel::clear_stages() {
  stages_.Clear();
}
inline const ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage& SoftCascadeOverIntegralChannelsModel::stages(int index) const {
  return stages_.Get(index);
}
inline ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage* SoftCascadeOverIntegralChannelsModel::mutable_stages(int index) {
  return stages_.Mutable(index);
}
inline ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage* SoftCascadeOverIntegralChannelsModel::add_stages() {
  return stages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage >&
SoftCascadeOverIntegralChannelsModel::stages() const {
  return stages_;
}
inline ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage >*
SoftCascadeOverIntegralChannelsModel::mutable_stages() {
  return &stages_;
}

// optional string channels_description = 2 [default = "hog6_luv"];
inline bool SoftCascadeOverIntegralChannelsModel::has_channels_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SoftCascadeOverIntegralChannelsModel::set_has_channels_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SoftCascadeOverIntegralChannelsModel::clear_has_channels_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SoftCascadeOverIntegralChannelsModel::clear_channels_description() {
  if (channels_description_ != _default_channels_description_) {
    channels_description_->assign(*_default_channels_description_);
  }
  clear_has_channels_description();
}
inline const ::std::string& SoftCascadeOverIntegralChannelsModel::channels_description() const {
  return *channels_description_;
}
inline void SoftCascadeOverIntegralChannelsModel::set_channels_description(const ::std::string& value) {
  set_has_channels_description();
  if (channels_description_ == _default_channels_description_) {
    channels_description_ = new ::std::string;
  }
  channels_description_->assign(value);
}
inline void SoftCascadeOverIntegralChannelsModel::set_channels_description(const char* value) {
  set_has_channels_description();
  if (channels_description_ == _default_channels_description_) {
    channels_description_ = new ::std::string;
  }
  channels_description_->assign(value);
}
inline void SoftCascadeOverIntegralChannelsModel::set_channels_description(const char* value, size_t size) {
  set_has_channels_description();
  if (channels_description_ == _default_channels_description_) {
    channels_description_ = new ::std::string;
  }
  channels_description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SoftCascadeOverIntegralChannelsModel::mutable_channels_description() {
  set_has_channels_description();
  if (channels_description_ == _default_channels_description_) {
    channels_description_ = new ::std::string(*_default_channels_description_);
  }
  return channels_description_;
}
inline ::std::string* SoftCascadeOverIntegralChannelsModel::release_channels_description() {
  clear_has_channels_description();
  if (channels_description_ == _default_channels_description_) {
    return NULL;
  } else {
    ::std::string* temp = channels_description_;
    channels_description_ = const_cast< ::std::string*>(_default_channels_description_);
    return temp;
  }
}
inline void SoftCascadeOverIntegralChannelsModel::set_allocated_channels_description(::std::string* channels_description) {
  if (channels_description_ != _default_channels_description_) {
    delete channels_description_;
  }
  if (channels_description) {
    set_has_channels_description();
    channels_description_ = channels_description;
  } else {
    clear_has_channels_description();
    channels_description_ = const_cast< ::std::string*>(_default_channels_description_);
  }
}

// optional uint32 shrinking_factor = 3 [default = 4];
inline bool SoftCascadeOverIntegralChannelsModel::has_shrinking_factor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SoftCascadeOverIntegralChannelsModel::set_has_shrinking_factor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SoftCascadeOverIntegralChannelsModel::clear_has_shrinking_factor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SoftCascadeOverIntegralChannelsModel::clear_shrinking_factor() {
  shrinking_factor_ = 4u;
  clear_has_shrinking_factor();
}
inline ::google::protobuf::uint32 SoftCascadeOverIntegralChannelsModel::shrinking_factor() const {
  return shrinking_factor_;
}
inline void SoftCascadeOverIntegralChannelsModel::set_shrinking_factor(::google::protobuf::uint32 value) {
  set_has_shrinking_factor();
  shrinking_factor_ = value;
}

// -------------------------------------------------------------------

// DetectorModel

// optional string detector_name = 1;
inline bool DetectorModel::has_detector_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetectorModel::set_has_detector_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetectorModel::clear_has_detector_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetectorModel::clear_detector_name() {
  if (detector_name_ != &::google::protobuf::internal::kEmptyString) {
    detector_name_->clear();
  }
  clear_has_detector_name();
}
inline const ::std::string& DetectorModel::detector_name() const {
  return *detector_name_;
}
inline void DetectorModel::set_detector_name(const ::std::string& value) {
  set_has_detector_name();
  if (detector_name_ == &::google::protobuf::internal::kEmptyString) {
    detector_name_ = new ::std::string;
  }
  detector_name_->assign(value);
}
inline void DetectorModel::set_detector_name(const char* value) {
  set_has_detector_name();
  if (detector_name_ == &::google::protobuf::internal::kEmptyString) {
    detector_name_ = new ::std::string;
  }
  detector_name_->assign(value);
}
inline void DetectorModel::set_detector_name(const char* value, size_t size) {
  set_has_detector_name();
  if (detector_name_ == &::google::protobuf::internal::kEmptyString) {
    detector_name_ = new ::std::string;
  }
  detector_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DetectorModel::mutable_detector_name() {
  set_has_detector_name();
  if (detector_name_ == &::google::protobuf::internal::kEmptyString) {
    detector_name_ = new ::std::string;
  }
  return detector_name_;
}
inline ::std::string* DetectorModel::release_detector_name() {
  clear_has_detector_name();
  if (detector_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = detector_name_;
    detector_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DetectorModel::set_allocated_detector_name(::std::string* detector_name) {
  if (detector_name_ != &::google::protobuf::internal::kEmptyString) {
    delete detector_name_;
  }
  if (detector_name) {
    set_has_detector_name();
    detector_name_ = detector_name;
  } else {
    clear_has_detector_name();
    detector_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string training_dataset_name = 2;
inline bool DetectorModel::has_training_dataset_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DetectorModel::set_has_training_dataset_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DetectorModel::clear_has_training_dataset_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DetectorModel::clear_training_dataset_name() {
  if (training_dataset_name_ != &::google::protobuf::internal::kEmptyString) {
    training_dataset_name_->clear();
  }
  clear_has_training_dataset_name();
}
inline const ::std::string& DetectorModel::training_dataset_name() const {
  return *training_dataset_name_;
}
inline void DetectorModel::set_training_dataset_name(const ::std::string& value) {
  set_has_training_dataset_name();
  if (training_dataset_name_ == &::google::protobuf::internal::kEmptyString) {
    training_dataset_name_ = new ::std::string;
  }
  training_dataset_name_->assign(value);
}
inline void DetectorModel::set_training_dataset_name(const char* value) {
  set_has_training_dataset_name();
  if (training_dataset_name_ == &::google::protobuf::internal::kEmptyString) {
    training_dataset_name_ = new ::std::string;
  }
  training_dataset_name_->assign(value);
}
inline void DetectorModel::set_training_dataset_name(const char* value, size_t size) {
  set_has_training_dataset_name();
  if (training_dataset_name_ == &::google::protobuf::internal::kEmptyString) {
    training_dataset_name_ = new ::std::string;
  }
  training_dataset_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DetectorModel::mutable_training_dataset_name() {
  set_has_training_dataset_name();
  if (training_dataset_name_ == &::google::protobuf::internal::kEmptyString) {
    training_dataset_name_ = new ::std::string;
  }
  return training_dataset_name_;
}
inline ::std::string* DetectorModel::release_training_dataset_name() {
  clear_has_training_dataset_name();
  if (training_dataset_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = training_dataset_name_;
    training_dataset_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DetectorModel::set_allocated_training_dataset_name(::std::string* training_dataset_name) {
  if (training_dataset_name_ != &::google::protobuf::internal::kEmptyString) {
    delete training_dataset_name_;
  }
  if (training_dataset_name) {
    set_has_training_dataset_name();
    training_dataset_name_ = training_dataset_name;
  } else {
    clear_has_training_dataset_name();
    training_dataset_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string semantic_category = 300 [default = "/m/017r8p"];
inline bool DetectorModel::has_semantic_category() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DetectorModel::set_has_semantic_category() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DetectorModel::clear_has_semantic_category() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DetectorModel::clear_semantic_category() {
  if (semantic_category_ != _default_semantic_category_) {
    semantic_category_->assign(*_default_semantic_category_);
  }
  clear_has_semantic_category();
}
inline const ::std::string& DetectorModel::semantic_category() const {
  return *semantic_category_;
}
inline void DetectorModel::set_semantic_category(const ::std::string& value) {
  set_has_semantic_category();
  if (semantic_category_ == _default_semantic_category_) {
    semantic_category_ = new ::std::string;
  }
  semantic_category_->assign(value);
}
inline void DetectorModel::set_semantic_category(const char* value) {
  set_has_semantic_category();
  if (semantic_category_ == _default_semantic_category_) {
    semantic_category_ = new ::std::string;
  }
  semantic_category_->assign(value);
}
inline void DetectorModel::set_semantic_category(const char* value, size_t size) {
  set_has_semantic_category();
  if (semantic_category_ == _default_semantic_category_) {
    semantic_category_ = new ::std::string;
  }
  semantic_category_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DetectorModel::mutable_semantic_category() {
  set_has_semantic_category();
  if (semantic_category_ == _default_semantic_category_) {
    semantic_category_ = new ::std::string(*_default_semantic_category_);
  }
  return semantic_category_;
}
inline ::std::string* DetectorModel::release_semantic_category() {
  clear_has_semantic_category();
  if (semantic_category_ == _default_semantic_category_) {
    return NULL;
  } else {
    ::std::string* temp = semantic_category_;
    semantic_category_ = const_cast< ::std::string*>(_default_semantic_category_);
    return temp;
  }
}
inline void DetectorModel::set_allocated_semantic_category(::std::string* semantic_category) {
  if (semantic_category_ != _default_semantic_category_) {
    delete semantic_category_;
  }
  if (semantic_category) {
    set_has_semantic_category();
    semantic_category_ = semantic_category;
  } else {
    clear_has_semantic_category();
    semantic_category_ = const_cast< ::std::string*>(_default_semantic_category_);
  }
}

// optional .doppia_protobuf.Point2d model_window_size = 10;
inline bool DetectorModel::has_model_window_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DetectorModel::set_has_model_window_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DetectorModel::clear_has_model_window_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DetectorModel::clear_model_window_size() {
  if (model_window_size_ != NULL) model_window_size_->::doppia_protobuf::Point2d::Clear();
  clear_has_model_window_size();
}
inline const ::doppia_protobuf::Point2d& DetectorModel::model_window_size() const {
  return model_window_size_ != NULL ? *model_window_size_ : *default_instance_->model_window_size_;
}
inline ::doppia_protobuf::Point2d* DetectorModel::mutable_model_window_size() {
  set_has_model_window_size();
  if (model_window_size_ == NULL) model_window_size_ = new ::doppia_protobuf::Point2d;
  return model_window_size_;
}
inline ::doppia_protobuf::Point2d* DetectorModel::release_model_window_size() {
  clear_has_model_window_size();
  ::doppia_protobuf::Point2d* temp = model_window_size_;
  model_window_size_ = NULL;
  return temp;
}
inline void DetectorModel::set_allocated_model_window_size(::doppia_protobuf::Point2d* model_window_size) {
  delete model_window_size_;
  model_window_size_ = model_window_size;
  if (model_window_size) {
    set_has_model_window_size();
  } else {
    clear_has_model_window_size();
  }
}

// optional .doppia_protobuf.Box object_window = 11;
inline bool DetectorModel::has_object_window() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DetectorModel::set_has_object_window() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DetectorModel::clear_has_object_window() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DetectorModel::clear_object_window() {
  if (object_window_ != NULL) object_window_->::doppia_protobuf::Box::Clear();
  clear_has_object_window();
}
inline const ::doppia_protobuf::Box& DetectorModel::object_window() const {
  return object_window_ != NULL ? *object_window_ : *default_instance_->object_window_;
}
inline ::doppia_protobuf::Box* DetectorModel::mutable_object_window() {
  set_has_object_window();
  if (object_window_ == NULL) object_window_ = new ::doppia_protobuf::Box;
  return object_window_;
}
inline ::doppia_protobuf::Box* DetectorModel::release_object_window() {
  clear_has_object_window();
  ::doppia_protobuf::Box* temp = object_window_;
  object_window_ = NULL;
  return temp;
}
inline void DetectorModel::set_allocated_object_window(::doppia_protobuf::Box* object_window) {
  delete object_window_;
  object_window_ = object_window;
  if (object_window) {
    set_has_object_window();
  } else {
    clear_has_object_window();
  }
}

// required .doppia_protobuf.DetectorModel.DetectorTypes detector_type = 3;
inline bool DetectorModel::has_detector_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DetectorModel::set_has_detector_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DetectorModel::clear_has_detector_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DetectorModel::clear_detector_type() {
  detector_type_ = 0;
  clear_has_detector_type();
}
inline ::doppia_protobuf::DetectorModel_DetectorTypes DetectorModel::detector_type() const {
  return static_cast< ::doppia_protobuf::DetectorModel_DetectorTypes >(detector_type_);
}
inline void DetectorModel::set_detector_type(::doppia_protobuf::DetectorModel_DetectorTypes value) {
  assert(::doppia_protobuf::DetectorModel_DetectorTypes_IsValid(value));
  set_has_detector_type();
  detector_type_ = value;
}

// optional .doppia_protobuf.LinearSvmModel linear_svm_model = 100;
inline bool DetectorModel::has_linear_svm_model() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DetectorModel::set_has_linear_svm_model() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DetectorModel::clear_has_linear_svm_model() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DetectorModel::clear_linear_svm_model() {
  if (linear_svm_model_ != NULL) linear_svm_model_->::doppia_protobuf::LinearSvmModel::Clear();
  clear_has_linear_svm_model();
}
inline const ::doppia_protobuf::LinearSvmModel& DetectorModel::linear_svm_model() const {
  return linear_svm_model_ != NULL ? *linear_svm_model_ : *default_instance_->linear_svm_model_;
}
inline ::doppia_protobuf::LinearSvmModel* DetectorModel::mutable_linear_svm_model() {
  set_has_linear_svm_model();
  if (linear_svm_model_ == NULL) linear_svm_model_ = new ::doppia_protobuf::LinearSvmModel;
  return linear_svm_model_;
}
inline ::doppia_protobuf::LinearSvmModel* DetectorModel::release_linear_svm_model() {
  clear_has_linear_svm_model();
  ::doppia_protobuf::LinearSvmModel* temp = linear_svm_model_;
  linear_svm_model_ = NULL;
  return temp;
}
inline void DetectorModel::set_allocated_linear_svm_model(::doppia_protobuf::LinearSvmModel* linear_svm_model) {
  delete linear_svm_model_;
  linear_svm_model_ = linear_svm_model;
  if (linear_svm_model) {
    set_has_linear_svm_model();
  } else {
    clear_has_linear_svm_model();
  }
}

// optional .doppia_protobuf.SoftCascadeOverIntegralChannelsModel soft_cascade_model = 102;
inline bool DetectorModel::has_soft_cascade_model() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DetectorModel::set_has_soft_cascade_model() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DetectorModel::clear_has_soft_cascade_model() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DetectorModel::clear_soft_cascade_model() {
  if (soft_cascade_model_ != NULL) soft_cascade_model_->::doppia_protobuf::SoftCascadeOverIntegralChannelsModel::Clear();
  clear_has_soft_cascade_model();
}
inline const ::doppia_protobuf::SoftCascadeOverIntegralChannelsModel& DetectorModel::soft_cascade_model() const {
  return soft_cascade_model_ != NULL ? *soft_cascade_model_ : *default_instance_->soft_cascade_model_;
}
inline ::doppia_protobuf::SoftCascadeOverIntegralChannelsModel* DetectorModel::mutable_soft_cascade_model() {
  set_has_soft_cascade_model();
  if (soft_cascade_model_ == NULL) soft_cascade_model_ = new ::doppia_protobuf::SoftCascadeOverIntegralChannelsModel;
  return soft_cascade_model_;
}
inline ::doppia_protobuf::SoftCascadeOverIntegralChannelsModel* DetectorModel::release_soft_cascade_model() {
  clear_has_soft_cascade_model();
  ::doppia_protobuf::SoftCascadeOverIntegralChannelsModel* temp = soft_cascade_model_;
  soft_cascade_model_ = NULL;
  return temp;
}
inline void DetectorModel::set_allocated_soft_cascade_model(::doppia_protobuf::SoftCascadeOverIntegralChannelsModel* soft_cascade_model) {
  delete soft_cascade_model_;
  soft_cascade_model_ = soft_cascade_model;
  if (soft_cascade_model) {
    set_has_soft_cascade_model();
  } else {
    clear_has_soft_cascade_model();
  }
}

// optional float scale = 200 [default = 1];
inline bool DetectorModel::has_scale() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DetectorModel::set_has_scale() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DetectorModel::clear_has_scale() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DetectorModel::clear_scale() {
  scale_ = 1;
  clear_has_scale();
}
inline float DetectorModel::scale() const {
  return scale_;
}
inline void DetectorModel::set_scale(float value) {
  set_has_scale();
  scale_ = value;
}

// optional float occlusion_level = 210 [default = 0];
inline bool DetectorModel::has_occlusion_level() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DetectorModel::set_has_occlusion_level() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DetectorModel::clear_has_occlusion_level() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DetectorModel::clear_occlusion_level() {
  occlusion_level_ = 0;
  clear_has_occlusion_level();
}
inline float DetectorModel::occlusion_level() const {
  return occlusion_level_;
}
inline void DetectorModel::set_occlusion_level(float value) {
  set_has_occlusion_level();
  occlusion_level_ = value;
}

// optional .doppia_protobuf.DetectorModel.OcclusionTypes occlusion_type = 211 [default = BottomOcclusion];
inline bool DetectorModel::has_occlusion_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DetectorModel::set_has_occlusion_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DetectorModel::clear_has_occlusion_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DetectorModel::clear_occlusion_type() {
  occlusion_type_ = 20;
  clear_has_occlusion_type();
}
inline ::doppia_protobuf::DetectorModel_OcclusionTypes DetectorModel::occlusion_type() const {
  return static_cast< ::doppia_protobuf::DetectorModel_OcclusionTypes >(occlusion_type_);
}
inline void DetectorModel::set_occlusion_type(::doppia_protobuf::DetectorModel_OcclusionTypes value) {
  assert(::doppia_protobuf::DetectorModel_OcclusionTypes_IsValid(value));
  set_has_occlusion_type();
  occlusion_type_ = value;
}

// -------------------------------------------------------------------

// MultiScalesDetectorModel

// optional string detector_name = 1;
inline bool MultiScalesDetectorModel::has_detector_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiScalesDetectorModel::set_has_detector_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiScalesDetectorModel::clear_has_detector_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiScalesDetectorModel::clear_detector_name() {
  if (detector_name_ != &::google::protobuf::internal::kEmptyString) {
    detector_name_->clear();
  }
  clear_has_detector_name();
}
inline const ::std::string& MultiScalesDetectorModel::detector_name() const {
  return *detector_name_;
}
inline void MultiScalesDetectorModel::set_detector_name(const ::std::string& value) {
  set_has_detector_name();
  if (detector_name_ == &::google::protobuf::internal::kEmptyString) {
    detector_name_ = new ::std::string;
  }
  detector_name_->assign(value);
}
inline void MultiScalesDetectorModel::set_detector_name(const char* value) {
  set_has_detector_name();
  if (detector_name_ == &::google::protobuf::internal::kEmptyString) {
    detector_name_ = new ::std::string;
  }
  detector_name_->assign(value);
}
inline void MultiScalesDetectorModel::set_detector_name(const char* value, size_t size) {
  set_has_detector_name();
  if (detector_name_ == &::google::protobuf::internal::kEmptyString) {
    detector_name_ = new ::std::string;
  }
  detector_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MultiScalesDetectorModel::mutable_detector_name() {
  set_has_detector_name();
  if (detector_name_ == &::google::protobuf::internal::kEmptyString) {
    detector_name_ = new ::std::string;
  }
  return detector_name_;
}
inline ::std::string* MultiScalesDetectorModel::release_detector_name() {
  clear_has_detector_name();
  if (detector_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = detector_name_;
    detector_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MultiScalesDetectorModel::set_allocated_detector_name(::std::string* detector_name) {
  if (detector_name_ != &::google::protobuf::internal::kEmptyString) {
    delete detector_name_;
  }
  if (detector_name) {
    set_has_detector_name();
    detector_name_ = detector_name;
  } else {
    clear_has_detector_name();
    detector_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string training_dataset_name = 2;
inline bool MultiScalesDetectorModel::has_training_dataset_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiScalesDetectorModel::set_has_training_dataset_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiScalesDetectorModel::clear_has_training_dataset_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiScalesDetectorModel::clear_training_dataset_name() {
  if (training_dataset_name_ != &::google::protobuf::internal::kEmptyString) {
    training_dataset_name_->clear();
  }
  clear_has_training_dataset_name();
}
inline const ::std::string& MultiScalesDetectorModel::training_dataset_name() const {
  return *training_dataset_name_;
}
inline void MultiScalesDetectorModel::set_training_dataset_name(const ::std::string& value) {
  set_has_training_dataset_name();
  if (training_dataset_name_ == &::google::protobuf::internal::kEmptyString) {
    training_dataset_name_ = new ::std::string;
  }
  training_dataset_name_->assign(value);
}
inline void MultiScalesDetectorModel::set_training_dataset_name(const char* value) {
  set_has_training_dataset_name();
  if (training_dataset_name_ == &::google::protobuf::internal::kEmptyString) {
    training_dataset_name_ = new ::std::string;
  }
  training_dataset_name_->assign(value);
}
inline void MultiScalesDetectorModel::set_training_dataset_name(const char* value, size_t size) {
  set_has_training_dataset_name();
  if (training_dataset_name_ == &::google::protobuf::internal::kEmptyString) {
    training_dataset_name_ = new ::std::string;
  }
  training_dataset_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MultiScalesDetectorModel::mutable_training_dataset_name() {
  set_has_training_dataset_name();
  if (training_dataset_name_ == &::google::protobuf::internal::kEmptyString) {
    training_dataset_name_ = new ::std::string;
  }
  return training_dataset_name_;
}
inline ::std::string* MultiScalesDetectorModel::release_training_dataset_name() {
  clear_has_training_dataset_name();
  if (training_dataset_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = training_dataset_name_;
    training_dataset_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MultiScalesDetectorModel::set_allocated_training_dataset_name(::std::string* training_dataset_name) {
  if (training_dataset_name_ != &::google::protobuf::internal::kEmptyString) {
    delete training_dataset_name_;
  }
  if (training_dataset_name) {
    set_has_training_dataset_name();
    training_dataset_name_ = training_dataset_name;
  } else {
    clear_has_training_dataset_name();
    training_dataset_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .doppia_protobuf.DetectorModel detectors = 3;
inline int MultiScalesDetectorModel::detectors_size() const {
  return detectors_.size();
}
inline void MultiScalesDetectorModel::clear_detectors() {
  detectors_.Clear();
}
inline const ::doppia_protobuf::DetectorModel& MultiScalesDetectorModel::detectors(int index) const {
  return detectors_.Get(index);
}
inline ::doppia_protobuf::DetectorModel* MultiScalesDetectorModel::mutable_detectors(int index) {
  return detectors_.Mutable(index);
}
inline ::doppia_protobuf::DetectorModel* MultiScalesDetectorModel::add_detectors() {
  return detectors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::DetectorModel >&
MultiScalesDetectorModel::detectors() const {
  return detectors_;
}
inline ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::DetectorModel >*
MultiScalesDetectorModel::mutable_detectors() {
  return &detectors_;
}

// -------------------------------------------------------------------

// DetectorModelsBundle

// optional string bundle_name = 1;
inline bool DetectorModelsBundle::has_bundle_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetectorModelsBundle::set_has_bundle_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetectorModelsBundle::clear_has_bundle_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetectorModelsBundle::clear_bundle_name() {
  if (bundle_name_ != &::google::protobuf::internal::kEmptyString) {
    bundle_name_->clear();
  }
  clear_has_bundle_name();
}
inline const ::std::string& DetectorModelsBundle::bundle_name() const {
  return *bundle_name_;
}
inline void DetectorModelsBundle::set_bundle_name(const ::std::string& value) {
  set_has_bundle_name();
  if (bundle_name_ == &::google::protobuf::internal::kEmptyString) {
    bundle_name_ = new ::std::string;
  }
  bundle_name_->assign(value);
}
inline void DetectorModelsBundle::set_bundle_name(const char* value) {
  set_has_bundle_name();
  if (bundle_name_ == &::google::protobuf::internal::kEmptyString) {
    bundle_name_ = new ::std::string;
  }
  bundle_name_->assign(value);
}
inline void DetectorModelsBundle::set_bundle_name(const char* value, size_t size) {
  set_has_bundle_name();
  if (bundle_name_ == &::google::protobuf::internal::kEmptyString) {
    bundle_name_ = new ::std::string;
  }
  bundle_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DetectorModelsBundle::mutable_bundle_name() {
  set_has_bundle_name();
  if (bundle_name_ == &::google::protobuf::internal::kEmptyString) {
    bundle_name_ = new ::std::string;
  }
  return bundle_name_;
}
inline ::std::string* DetectorModelsBundle::release_bundle_name() {
  clear_has_bundle_name();
  if (bundle_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bundle_name_;
    bundle_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DetectorModelsBundle::set_allocated_bundle_name(::std::string* bundle_name) {
  if (bundle_name_ != &::google::protobuf::internal::kEmptyString) {
    delete bundle_name_;
  }
  if (bundle_name) {
    set_has_bundle_name();
    bundle_name_ = bundle_name;
  } else {
    clear_has_bundle_name();
    bundle_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string training_dataset_name = 2;
inline bool DetectorModelsBundle::has_training_dataset_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DetectorModelsBundle::set_has_training_dataset_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DetectorModelsBundle::clear_has_training_dataset_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DetectorModelsBundle::clear_training_dataset_name() {
  if (training_dataset_name_ != &::google::protobuf::internal::kEmptyString) {
    training_dataset_name_->clear();
  }
  clear_has_training_dataset_name();
}
inline const ::std::string& DetectorModelsBundle::training_dataset_name() const {
  return *training_dataset_name_;
}
inline void DetectorModelsBundle::set_training_dataset_name(const ::std::string& value) {
  set_has_training_dataset_name();
  if (training_dataset_name_ == &::google::protobuf::internal::kEmptyString) {
    training_dataset_name_ = new ::std::string;
  }
  training_dataset_name_->assign(value);
}
inline void DetectorModelsBundle::set_training_dataset_name(const char* value) {
  set_has_training_dataset_name();
  if (training_dataset_name_ == &::google::protobuf::internal::kEmptyString) {
    training_dataset_name_ = new ::std::string;
  }
  training_dataset_name_->assign(value);
}
inline void DetectorModelsBundle::set_training_dataset_name(const char* value, size_t size) {
  set_has_training_dataset_name();
  if (training_dataset_name_ == &::google::protobuf::internal::kEmptyString) {
    training_dataset_name_ = new ::std::string;
  }
  training_dataset_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DetectorModelsBundle::mutable_training_dataset_name() {
  set_has_training_dataset_name();
  if (training_dataset_name_ == &::google::protobuf::internal::kEmptyString) {
    training_dataset_name_ = new ::std::string;
  }
  return training_dataset_name_;
}
inline ::std::string* DetectorModelsBundle::release_training_dataset_name() {
  clear_has_training_dataset_name();
  if (training_dataset_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = training_dataset_name_;
    training_dataset_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DetectorModelsBundle::set_allocated_training_dataset_name(::std::string* training_dataset_name) {
  if (training_dataset_name_ != &::google::protobuf::internal::kEmptyString) {
    delete training_dataset_name_;
  }
  if (training_dataset_name) {
    set_has_training_dataset_name();
    training_dataset_name_ = training_dataset_name;
  } else {
    clear_has_training_dataset_name();
    training_dataset_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .doppia_protobuf.DetectorModel detectors = 3;
inline int DetectorModelsBundle::detectors_size() const {
  return detectors_.size();
}
inline void DetectorModelsBundle::clear_detectors() {
  detectors_.Clear();
}
inline const ::doppia_protobuf::DetectorModel& DetectorModelsBundle::detectors(int index) const {
  return detectors_.Get(index);
}
inline ::doppia_protobuf::DetectorModel* DetectorModelsBundle::mutable_detectors(int index) {
  return detectors_.Mutable(index);
}
inline ::doppia_protobuf::DetectorModel* DetectorModelsBundle::add_detectors() {
  return detectors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::DetectorModel >&
DetectorModelsBundle::detectors() const {
  return detectors_;
}
inline ::google::protobuf::RepeatedPtrField< ::doppia_protobuf::DetectorModel >*
DetectorModelsBundle::mutable_detectors() {
  return &detectors_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace doppia_protobuf

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage_FeatureTypes>() {
  return ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage_FeatureTypes_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::doppia_protobuf::DetectorModel_DetectorTypes>() {
  return ::doppia_protobuf::DetectorModel_DetectorTypes_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::doppia_protobuf::DetectorModel_OcclusionTypes>() {
  return ::doppia_protobuf::DetectorModel_OcclusionTypes_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_detector_5fmodel_2eproto__INCLUDED
