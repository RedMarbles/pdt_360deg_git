// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: detector_model.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "detector_model.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace doppia_protobuf {

namespace {

const ::google::protobuf::Descriptor* LinearSvmModel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LinearSvmModel_reflection_ = NULL;
const ::google::protobuf::Descriptor* IntegralChannelsFeature_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IntegralChannelsFeature_reflection_ = NULL;
const ::google::protobuf::Descriptor* IntegralChannelDecisionStump_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IntegralChannelDecisionStump_reflection_ = NULL;
const ::google::protobuf::Descriptor* IntegralChannelBinaryDecisionTreeNode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IntegralChannelBinaryDecisionTreeNode_reflection_ = NULL;
const ::google::protobuf::Descriptor* IntegralChannelBinaryDecisionTree_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IntegralChannelBinaryDecisionTree_reflection_ = NULL;
const ::google::protobuf::Descriptor* IntegralChannelStumpSet_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IntegralChannelStumpSet_reflection_ = NULL;
const ::google::protobuf::Descriptor* SoftCascadeOverIntegralChannelsStage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SoftCascadeOverIntegralChannelsStage_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SoftCascadeOverIntegralChannelsStage_FeatureTypes_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SoftCascadeOverIntegralChannelsModel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SoftCascadeOverIntegralChannelsModel_reflection_ = NULL;
const ::google::protobuf::Descriptor* DetectorModel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DetectorModel_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* DetectorModel_DetectorTypes_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* DetectorModel_OcclusionTypes_descriptor_ = NULL;
const ::google::protobuf::Descriptor* MultiScalesDetectorModel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MultiScalesDetectorModel_reflection_ = NULL;
const ::google::protobuf::Descriptor* DetectorModelsBundle_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DetectorModelsBundle_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_detector_5fmodel_2eproto() {
  protobuf_AddDesc_detector_5fmodel_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "detector_model.proto");
  GOOGLE_CHECK(file != NULL);
  LinearSvmModel_descriptor_ = file->message_type(0);
  static const int LinearSvmModel_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinearSvmModel, solved_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinearSvmModel, number_of_classes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinearSvmModel, labels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinearSvmModel, number_of_features_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinearSvmModel, bias_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinearSvmModel, w_),
  };
  LinearSvmModel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LinearSvmModel_descriptor_,
      LinearSvmModel::default_instance_,
      LinearSvmModel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinearSvmModel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinearSvmModel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LinearSvmModel));
  IntegralChannelsFeature_descriptor_ = file->message_type(1);
  static const int IntegralChannelsFeature_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelsFeature, channel_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelsFeature, box_),
  };
  IntegralChannelsFeature_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IntegralChannelsFeature_descriptor_,
      IntegralChannelsFeature::default_instance_,
      IntegralChannelsFeature_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelsFeature, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelsFeature, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IntegralChannelsFeature));
  IntegralChannelDecisionStump_descriptor_ = file->message_type(2);
  static const int IntegralChannelDecisionStump_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelDecisionStump, feature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelDecisionStump, feature_threshold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelDecisionStump, larger_than_threshold_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelDecisionStump, true_leaf_weight_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelDecisionStump, false_leaf_weight_),
  };
  IntegralChannelDecisionStump_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IntegralChannelDecisionStump_descriptor_,
      IntegralChannelDecisionStump::default_instance_,
      IntegralChannelDecisionStump_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelDecisionStump, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelDecisionStump, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IntegralChannelDecisionStump));
  IntegralChannelBinaryDecisionTreeNode_descriptor_ = file->message_type(3);
  static const int IntegralChannelBinaryDecisionTreeNode_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelBinaryDecisionTreeNode, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelBinaryDecisionTreeNode, parent_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelBinaryDecisionTreeNode, parent_value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelBinaryDecisionTreeNode, decision_stump_),
  };
  IntegralChannelBinaryDecisionTreeNode_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IntegralChannelBinaryDecisionTreeNode_descriptor_,
      IntegralChannelBinaryDecisionTreeNode::default_instance_,
      IntegralChannelBinaryDecisionTreeNode_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelBinaryDecisionTreeNode, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelBinaryDecisionTreeNode, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IntegralChannelBinaryDecisionTreeNode));
  IntegralChannelBinaryDecisionTree_descriptor_ = file->message_type(4);
  static const int IntegralChannelBinaryDecisionTree_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelBinaryDecisionTree, nodes_),
  };
  IntegralChannelBinaryDecisionTree_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IntegralChannelBinaryDecisionTree_descriptor_,
      IntegralChannelBinaryDecisionTree::default_instance_,
      IntegralChannelBinaryDecisionTree_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelBinaryDecisionTree, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelBinaryDecisionTree, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IntegralChannelBinaryDecisionTree));
  IntegralChannelStumpSet_descriptor_ = file->message_type(5);
  static const int IntegralChannelStumpSet_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelStumpSet, nodes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelStumpSet, weights_),
  };
  IntegralChannelStumpSet_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IntegralChannelStumpSet_descriptor_,
      IntegralChannelStumpSet::default_instance_,
      IntegralChannelStumpSet_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelStumpSet, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IntegralChannelStumpSet, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IntegralChannelStumpSet));
  SoftCascadeOverIntegralChannelsStage_descriptor_ = file->message_type(6);
  static const int SoftCascadeOverIntegralChannelsStage_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftCascadeOverIntegralChannelsStage, feature_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftCascadeOverIntegralChannelsStage, decision_stump_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftCascadeOverIntegralChannelsStage, level2_decision_tree_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftCascadeOverIntegralChannelsStage, leveln_decision_tree_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftCascadeOverIntegralChannelsStage, stump_set_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftCascadeOverIntegralChannelsStage, weight_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftCascadeOverIntegralChannelsStage, cascade_threshold_),
  };
  SoftCascadeOverIntegralChannelsStage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SoftCascadeOverIntegralChannelsStage_descriptor_,
      SoftCascadeOverIntegralChannelsStage::default_instance_,
      SoftCascadeOverIntegralChannelsStage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftCascadeOverIntegralChannelsStage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftCascadeOverIntegralChannelsStage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SoftCascadeOverIntegralChannelsStage));
  SoftCascadeOverIntegralChannelsStage_FeatureTypes_descriptor_ = SoftCascadeOverIntegralChannelsStage_descriptor_->enum_type(0);
  SoftCascadeOverIntegralChannelsModel_descriptor_ = file->message_type(7);
  static const int SoftCascadeOverIntegralChannelsModel_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftCascadeOverIntegralChannelsModel, stages_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftCascadeOverIntegralChannelsModel, channels_description_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftCascadeOverIntegralChannelsModel, shrinking_factor_),
  };
  SoftCascadeOverIntegralChannelsModel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SoftCascadeOverIntegralChannelsModel_descriptor_,
      SoftCascadeOverIntegralChannelsModel::default_instance_,
      SoftCascadeOverIntegralChannelsModel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftCascadeOverIntegralChannelsModel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftCascadeOverIntegralChannelsModel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SoftCascadeOverIntegralChannelsModel));
  DetectorModel_descriptor_ = file->message_type(8);
  static const int DetectorModel_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModel, detector_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModel, training_dataset_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModel, semantic_category_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModel, model_window_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModel, object_window_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModel, detector_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModel, linear_svm_model_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModel, soft_cascade_model_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModel, scale_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModel, occlusion_level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModel, occlusion_type_),
  };
  DetectorModel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DetectorModel_descriptor_,
      DetectorModel::default_instance_,
      DetectorModel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DetectorModel));
  DetectorModel_DetectorTypes_descriptor_ = DetectorModel_descriptor_->enum_type(0);
  DetectorModel_OcclusionTypes_descriptor_ = DetectorModel_descriptor_->enum_type(1);
  MultiScalesDetectorModel_descriptor_ = file->message_type(9);
  static const int MultiScalesDetectorModel_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiScalesDetectorModel, detector_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiScalesDetectorModel, training_dataset_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiScalesDetectorModel, detectors_),
  };
  MultiScalesDetectorModel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MultiScalesDetectorModel_descriptor_,
      MultiScalesDetectorModel::default_instance_,
      MultiScalesDetectorModel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiScalesDetectorModel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultiScalesDetectorModel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MultiScalesDetectorModel));
  DetectorModelsBundle_descriptor_ = file->message_type(10);
  static const int DetectorModelsBundle_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModelsBundle, bundle_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModelsBundle, training_dataset_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModelsBundle, detectors_),
  };
  DetectorModelsBundle_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DetectorModelsBundle_descriptor_,
      DetectorModelsBundle::default_instance_,
      DetectorModelsBundle_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModelsBundle, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DetectorModelsBundle, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DetectorModelsBundle));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_detector_5fmodel_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LinearSvmModel_descriptor_, &LinearSvmModel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IntegralChannelsFeature_descriptor_, &IntegralChannelsFeature::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IntegralChannelDecisionStump_descriptor_, &IntegralChannelDecisionStump::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IntegralChannelBinaryDecisionTreeNode_descriptor_, &IntegralChannelBinaryDecisionTreeNode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IntegralChannelBinaryDecisionTree_descriptor_, &IntegralChannelBinaryDecisionTree::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IntegralChannelStumpSet_descriptor_, &IntegralChannelStumpSet::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SoftCascadeOverIntegralChannelsStage_descriptor_, &SoftCascadeOverIntegralChannelsStage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SoftCascadeOverIntegralChannelsModel_descriptor_, &SoftCascadeOverIntegralChannelsModel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DetectorModel_descriptor_, &DetectorModel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MultiScalesDetectorModel_descriptor_, &MultiScalesDetectorModel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DetectorModelsBundle_descriptor_, &DetectorModelsBundle::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_detector_5fmodel_2eproto() {
  delete LinearSvmModel::default_instance_;
  delete LinearSvmModel_reflection_;
  delete IntegralChannelsFeature::default_instance_;
  delete IntegralChannelsFeature_reflection_;
  delete IntegralChannelDecisionStump::default_instance_;
  delete IntegralChannelDecisionStump_reflection_;
  delete IntegralChannelBinaryDecisionTreeNode::default_instance_;
  delete IntegralChannelBinaryDecisionTreeNode_reflection_;
  delete IntegralChannelBinaryDecisionTree::default_instance_;
  delete IntegralChannelBinaryDecisionTree_reflection_;
  delete IntegralChannelStumpSet::default_instance_;
  delete IntegralChannelStumpSet_reflection_;
  delete SoftCascadeOverIntegralChannelsStage::default_instance_;
  delete SoftCascadeOverIntegralChannelsStage_reflection_;
  delete SoftCascadeOverIntegralChannelsModel::default_instance_;
  delete SoftCascadeOverIntegralChannelsModel_reflection_;
  delete SoftCascadeOverIntegralChannelsModel::_default_channels_description_;
  delete DetectorModel::default_instance_;
  delete DetectorModel_reflection_;
  delete DetectorModel::_default_semantic_category_;
  delete MultiScalesDetectorModel::default_instance_;
  delete MultiScalesDetectorModel_reflection_;
  delete DetectorModelsBundle::default_instance_;
  delete DetectorModelsBundle_reflection_;
}

void protobuf_AddDesc_detector_5fmodel_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::doppia_protobuf::protobuf_AddDesc_detections_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\024detector_model.proto\022\017doppia_protobuf\032"
    "\020detections.proto\"\205\001\n\016LinearSvmModel\022\023\n\013"
    "solved_type\030\001 \001(\t\022\031\n\021number_of_classes\030\002"
    " \001(\r\022\016\n\006labels\030\003 \003(\005\022\032\n\022number_of_featur"
    "es\030\004 \001(\r\022\014\n\004bias\030\005 \002(\002\022\t\n\001w\030\006 \003(\002\"S\n\027Int"
    "egralChannelsFeature\022\025\n\rchannel_index\030\001 "
    "\002(\005\022!\n\003box\030\002 \002(\0132\024.doppia_protobuf.Box\"\317"
    "\001\n\034IntegralChannelDecisionStump\0229\n\007featu"
    "re\030\001 \002(\0132(.doppia_protobuf.IntegralChann"
    "elsFeature\022\031\n\021feature_threshold\030\002 \002(\002\022$\n"
    "\025larger_than_threshold\030\003 \001(\010:\005false\022\030\n\020t"
    "rue_leaf_weight\030\n \001(\002\022\031\n\021false_leaf_weig"
    "ht\030\013 \001(\002\"\243\001\n%IntegralChannelBinaryDecisi"
    "onTreeNode\022\n\n\002id\030\001 \002(\r\022\021\n\tparent_id\030\002 \002("
    "\r\022\024\n\014parent_value\030\003 \001(\010\022E\n\016decision_stum"
    "p\030\004 \001(\0132-.doppia_protobuf.IntegralChanne"
    "lDecisionStump\"j\n!IntegralChannelBinaryD"
    "ecisionTree\022E\n\005nodes\030\001 \003(\01326.doppia_prot"
    "obuf.IntegralChannelBinaryDecisionTreeNo"
    "de\"h\n\027IntegralChannelStumpSet\022<\n\005nodes\030\001"
    " \003(\0132-.doppia_protobuf.IntegralChannelDe"
    "cisionStump\022\017\n\007weights\030\002 \003(\002\"\256\004\n$SoftCas"
    "cadeOverIntegralChannelsStage\022X\n\014feature"
    "_type\030\001 \002(\0162B.doppia_protobuf.SoftCascad"
    "eOverIntegralChannelsStage.FeatureTypes\022"
    "E\n\016decision_stump\030\n \001(\0132-.doppia_protobu"
    "f.IntegralChannelDecisionStump\022P\n\024level2"
    "_decision_tree\030\013 \001(\01322.doppia_protobuf.I"
    "ntegralChannelBinaryDecisionTree\022P\n\024leve"
    "lN_decision_tree\030\014 \001(\01322.doppia_protobuf"
    ".IntegralChannelBinaryDecisionTree\022;\n\tst"
    "ump_set\030\r \001(\0132(.doppia_protobuf.Integral"
    "ChannelStumpSet\022\016\n\006weight\030\002 \002(\002\022\031\n\021casca"
    "de_threshold\030\003 \002(\002\"Y\n\014FeatureTypes\022\n\n\006St"
    "umps\020\000\022\026\n\022Level2DecisionTree\020\n\022\026\n\022LevelN"
    "DecisionTree\020d\022\r\n\010StumpSet\020\310\001\"\262\001\n$SoftCa"
    "scadeOverIntegralChannelsModel\022E\n\006stages"
    "\030\001 \003(\01325.doppia_protobuf.SoftCascadeOver"
    "IntegralChannelsStage\022&\n\024channels_descri"
    "ption\030\002 \001(\t:\010hog6_luv\022\033\n\020shrinking_facto"
    "r\030\003 \001(\r:\0014\"\340\005\n\rDetectorModel\022\025\n\rdetector"
    "_name\030\001 \001(\t\022\035\n\025training_dataset_name\030\002 \002"
    "(\t\022%\n\021semantic_category\030\254\002 \001(\t:\t/m/017r8"
    "p\0223\n\021model_window_size\030\n \001(\0132\030.doppia_pr"
    "otobuf.Point2d\022+\n\robject_window\030\013 \001(\0132\024."
    "doppia_protobuf.Box\022C\n\rdetector_type\030\003 \002"
    "(\0162,.doppia_protobuf.DetectorModel.Detec"
    "torTypes\0229\n\020linear_svm_model\030d \001(\0132\037.dop"
    "pia_protobuf.LinearSvmModel\022Q\n\022soft_casc"
    "ade_model\030f \001(\01325.doppia_protobuf.SoftCa"
    "scadeOverIntegralChannelsModel\022\021\n\005scale\030"
    "\310\001 \001(\002:\0011\022\033\n\017occlusion_level\030\322\001 \001(\002:\0010\022W"
    "\n\016occlusion_type\030\323\001 \001(\0162-.doppia_protobu"
    "f.DetectorModel.OcclusionTypes:\017BottomOc"
    "clusion\"T\n\rDetectorTypes\022\r\n\tLinearSvm\020\000\022"
    "#\n\037SoftCascadeOverIntegralChannels\020\n\022\017\n\013"
    "HoughForest\020\024\"^\n\016OcclusionTypes\022\021\n\rLeftO"
    "cclusion\020\n\022\022\n\016RightOcclusion\020\013\022\023\n\017Bottom"
    "Occlusion\020\024\022\020\n\014TopOcclusion\020\025\"\203\001\n\030MultiS"
    "calesDetectorModel\022\025\n\rdetector_name\030\001 \001("
    "\t\022\035\n\025training_dataset_name\030\002 \002(\t\0221\n\tdete"
    "ctors\030\003 \003(\0132\036.doppia_protobuf.DetectorMo"
    "del\"}\n\024DetectorModelsBundle\022\023\n\013bundle_na"
    "me\030\001 \001(\t\022\035\n\025training_dataset_name\030\002 \002(\t\022"
    "1\n\tdetectors\030\003 \003(\0132\036.doppia_protobuf.Det"
    "ectorModel", 2610);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "detector_model.proto", &protobuf_RegisterTypes);
  LinearSvmModel::default_instance_ = new LinearSvmModel();
  IntegralChannelsFeature::default_instance_ = new IntegralChannelsFeature();
  IntegralChannelDecisionStump::default_instance_ = new IntegralChannelDecisionStump();
  IntegralChannelBinaryDecisionTreeNode::default_instance_ = new IntegralChannelBinaryDecisionTreeNode();
  IntegralChannelBinaryDecisionTree::default_instance_ = new IntegralChannelBinaryDecisionTree();
  IntegralChannelStumpSet::default_instance_ = new IntegralChannelStumpSet();
  SoftCascadeOverIntegralChannelsStage::default_instance_ = new SoftCascadeOverIntegralChannelsStage();
  SoftCascadeOverIntegralChannelsModel::_default_channels_description_ =
      new ::std::string("hog6_luv", 8);
  SoftCascadeOverIntegralChannelsModel::default_instance_ = new SoftCascadeOverIntegralChannelsModel();
  DetectorModel::_default_semantic_category_ =
      new ::std::string("/m/017r8p", 9);
  DetectorModel::default_instance_ = new DetectorModel();
  MultiScalesDetectorModel::default_instance_ = new MultiScalesDetectorModel();
  DetectorModelsBundle::default_instance_ = new DetectorModelsBundle();
  LinearSvmModel::default_instance_->InitAsDefaultInstance();
  IntegralChannelsFeature::default_instance_->InitAsDefaultInstance();
  IntegralChannelDecisionStump::default_instance_->InitAsDefaultInstance();
  IntegralChannelBinaryDecisionTreeNode::default_instance_->InitAsDefaultInstance();
  IntegralChannelBinaryDecisionTree::default_instance_->InitAsDefaultInstance();
  IntegralChannelStumpSet::default_instance_->InitAsDefaultInstance();
  SoftCascadeOverIntegralChannelsStage::default_instance_->InitAsDefaultInstance();
  SoftCascadeOverIntegralChannelsModel::default_instance_->InitAsDefaultInstance();
  DetectorModel::default_instance_->InitAsDefaultInstance();
  MultiScalesDetectorModel::default_instance_->InitAsDefaultInstance();
  DetectorModelsBundle::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_detector_5fmodel_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_detector_5fmodel_2eproto {
  StaticDescriptorInitializer_detector_5fmodel_2eproto() {
    protobuf_AddDesc_detector_5fmodel_2eproto();
  }
} static_descriptor_initializer_detector_5fmodel_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int LinearSvmModel::kSolvedTypeFieldNumber;
const int LinearSvmModel::kNumberOfClassesFieldNumber;
const int LinearSvmModel::kLabelsFieldNumber;
const int LinearSvmModel::kNumberOfFeaturesFieldNumber;
const int LinearSvmModel::kBiasFieldNumber;
const int LinearSvmModel::kWFieldNumber;
#endif  // !_MSC_VER

LinearSvmModel::LinearSvmModel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LinearSvmModel::InitAsDefaultInstance() {
}

LinearSvmModel::LinearSvmModel(const LinearSvmModel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LinearSvmModel::SharedCtor() {
  _cached_size_ = 0;
  solved_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  number_of_classes_ = 0u;
  number_of_features_ = 0u;
  bias_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LinearSvmModel::~LinearSvmModel() {
  SharedDtor();
}

void LinearSvmModel::SharedDtor() {
  if (solved_type_ != &::google::protobuf::internal::kEmptyString) {
    delete solved_type_;
  }
  if (this != default_instance_) {
  }
}

void LinearSvmModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LinearSvmModel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LinearSvmModel_descriptor_;
}

const LinearSvmModel& LinearSvmModel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_detector_5fmodel_2eproto();
  return *default_instance_;
}

LinearSvmModel* LinearSvmModel::default_instance_ = NULL;

LinearSvmModel* LinearSvmModel::New() const {
  return new LinearSvmModel;
}

void LinearSvmModel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_solved_type()) {
      if (solved_type_ != &::google::protobuf::internal::kEmptyString) {
        solved_type_->clear();
      }
    }
    number_of_classes_ = 0u;
    number_of_features_ = 0u;
    bias_ = 0;
  }
  labels_.Clear();
  w_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LinearSvmModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string solved_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_solved_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->solved_type().data(), this->solved_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_number_of_classes;
        break;
      }

      // optional uint32 number_of_classes = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_number_of_classes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &number_of_classes_)));
          set_has_number_of_classes();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_labels;
        break;
      }

      // repeated int32 labels = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_labels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_labels())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_labels())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_labels;
        if (input->ExpectTag(32)) goto parse_number_of_features;
        break;
      }

      // optional uint32 number_of_features = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_number_of_features:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &number_of_features_)));
          set_has_number_of_features();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_bias;
        break;
      }

      // required float bias = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_bias:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &bias_)));
          set_has_bias();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_w;
        break;
      }

      // repeated float w = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_w:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 53, input, this->mutable_w())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_w())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_w;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LinearSvmModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string solved_type = 1;
  if (has_solved_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->solved_type().data(), this->solved_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->solved_type(), output);
  }

  // optional uint32 number_of_classes = 2;
  if (has_number_of_classes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->number_of_classes(), output);
  }

  // repeated int32 labels = 3;
  for (int i = 0; i < this->labels_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->labels(i), output);
  }

  // optional uint32 number_of_features = 4;
  if (has_number_of_features()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->number_of_features(), output);
  }

  // required float bias = 5;
  if (has_bias()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->bias(), output);
  }

  // repeated float w = 6;
  for (int i = 0; i < this->w_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      6, this->w(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LinearSvmModel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string solved_type = 1;
  if (has_solved_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->solved_type().data(), this->solved_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->solved_type(), target);
  }

  // optional uint32 number_of_classes = 2;
  if (has_number_of_classes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->number_of_classes(), target);
  }

  // repeated int32 labels = 3;
  for (int i = 0; i < this->labels_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(3, this->labels(i), target);
  }

  // optional uint32 number_of_features = 4;
  if (has_number_of_features()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->number_of_features(), target);
  }

  // required float bias = 5;
  if (has_bias()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->bias(), target);
  }

  // repeated float w = 6;
  for (int i = 0; i < this->w_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(6, this->w(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LinearSvmModel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string solved_type = 1;
    if (has_solved_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->solved_type());
    }

    // optional uint32 number_of_classes = 2;
    if (has_number_of_classes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->number_of_classes());
    }

    // optional uint32 number_of_features = 4;
    if (has_number_of_features()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->number_of_features());
    }

    // required float bias = 5;
    if (has_bias()) {
      total_size += 1 + 4;
    }

  }
  // repeated int32 labels = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->labels_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->labels(i));
    }
    total_size += 1 * this->labels_size() + data_size;
  }

  // repeated float w = 6;
  {
    int data_size = 0;
    data_size = 4 * this->w_size();
    total_size += 1 * this->w_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LinearSvmModel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LinearSvmModel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LinearSvmModel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LinearSvmModel::MergeFrom(const LinearSvmModel& from) {
  GOOGLE_CHECK_NE(&from, this);
  labels_.MergeFrom(from.labels_);
  w_.MergeFrom(from.w_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_solved_type()) {
      set_solved_type(from.solved_type());
    }
    if (from.has_number_of_classes()) {
      set_number_of_classes(from.number_of_classes());
    }
    if (from.has_number_of_features()) {
      set_number_of_features(from.number_of_features());
    }
    if (from.has_bias()) {
      set_bias(from.bias());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LinearSvmModel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LinearSvmModel::CopyFrom(const LinearSvmModel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinearSvmModel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000010) != 0x00000010) return false;

  return true;
}

void LinearSvmModel::Swap(LinearSvmModel* other) {
  if (other != this) {
    std::swap(solved_type_, other->solved_type_);
    std::swap(number_of_classes_, other->number_of_classes_);
    labels_.Swap(&other->labels_);
    std::swap(number_of_features_, other->number_of_features_);
    std::swap(bias_, other->bias_);
    w_.Swap(&other->w_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LinearSvmModel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LinearSvmModel_descriptor_;
  metadata.reflection = LinearSvmModel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int IntegralChannelsFeature::kChannelIndexFieldNumber;
const int IntegralChannelsFeature::kBoxFieldNumber;
#endif  // !_MSC_VER

IntegralChannelsFeature::IntegralChannelsFeature()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void IntegralChannelsFeature::InitAsDefaultInstance() {
  box_ = const_cast< ::doppia_protobuf::Box*>(&::doppia_protobuf::Box::default_instance());
}

IntegralChannelsFeature::IntegralChannelsFeature(const IntegralChannelsFeature& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void IntegralChannelsFeature::SharedCtor() {
  _cached_size_ = 0;
  channel_index_ = 0;
  box_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IntegralChannelsFeature::~IntegralChannelsFeature() {
  SharedDtor();
}

void IntegralChannelsFeature::SharedDtor() {
  if (this != default_instance_) {
    delete box_;
  }
}

void IntegralChannelsFeature::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IntegralChannelsFeature::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IntegralChannelsFeature_descriptor_;
}

const IntegralChannelsFeature& IntegralChannelsFeature::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_detector_5fmodel_2eproto();
  return *default_instance_;
}

IntegralChannelsFeature* IntegralChannelsFeature::default_instance_ = NULL;

IntegralChannelsFeature* IntegralChannelsFeature::New() const {
  return new IntegralChannelsFeature;
}

void IntegralChannelsFeature::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    channel_index_ = 0;
    if (has_box()) {
      if (box_ != NULL) box_->::doppia_protobuf::Box::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IntegralChannelsFeature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 channel_index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channel_index_)));
          set_has_channel_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_box;
        break;
      }

      // required .doppia_protobuf.Box box = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_box:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_box()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IntegralChannelsFeature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 channel_index = 1;
  if (has_channel_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->channel_index(), output);
  }

  // required .doppia_protobuf.Box box = 2;
  if (has_box()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->box(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* IntegralChannelsFeature::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 channel_index = 1;
  if (has_channel_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->channel_index(), target);
  }

  // required .doppia_protobuf.Box box = 2;
  if (has_box()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->box(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int IntegralChannelsFeature::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 channel_index = 1;
    if (has_channel_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channel_index());
    }

    // required .doppia_protobuf.Box box = 2;
    if (has_box()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->box());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IntegralChannelsFeature::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IntegralChannelsFeature* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IntegralChannelsFeature*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IntegralChannelsFeature::MergeFrom(const IntegralChannelsFeature& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_channel_index()) {
      set_channel_index(from.channel_index());
    }
    if (from.has_box()) {
      mutable_box()->::doppia_protobuf::Box::MergeFrom(from.box());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IntegralChannelsFeature::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IntegralChannelsFeature::CopyFrom(const IntegralChannelsFeature& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntegralChannelsFeature::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_box()) {
    if (!this->box().IsInitialized()) return false;
  }
  return true;
}

void IntegralChannelsFeature::Swap(IntegralChannelsFeature* other) {
  if (other != this) {
    std::swap(channel_index_, other->channel_index_);
    std::swap(box_, other->box_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IntegralChannelsFeature::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IntegralChannelsFeature_descriptor_;
  metadata.reflection = IntegralChannelsFeature_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int IntegralChannelDecisionStump::kFeatureFieldNumber;
const int IntegralChannelDecisionStump::kFeatureThresholdFieldNumber;
const int IntegralChannelDecisionStump::kLargerThanThresholdFieldNumber;
const int IntegralChannelDecisionStump::kTrueLeafWeightFieldNumber;
const int IntegralChannelDecisionStump::kFalseLeafWeightFieldNumber;
#endif  // !_MSC_VER

IntegralChannelDecisionStump::IntegralChannelDecisionStump()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void IntegralChannelDecisionStump::InitAsDefaultInstance() {
  feature_ = const_cast< ::doppia_protobuf::IntegralChannelsFeature*>(&::doppia_protobuf::IntegralChannelsFeature::default_instance());
}

IntegralChannelDecisionStump::IntegralChannelDecisionStump(const IntegralChannelDecisionStump& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void IntegralChannelDecisionStump::SharedCtor() {
  _cached_size_ = 0;
  feature_ = NULL;
  feature_threshold_ = 0;
  larger_than_threshold_ = false;
  true_leaf_weight_ = 0;
  false_leaf_weight_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IntegralChannelDecisionStump::~IntegralChannelDecisionStump() {
  SharedDtor();
}

void IntegralChannelDecisionStump::SharedDtor() {
  if (this != default_instance_) {
    delete feature_;
  }
}

void IntegralChannelDecisionStump::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IntegralChannelDecisionStump::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IntegralChannelDecisionStump_descriptor_;
}

const IntegralChannelDecisionStump& IntegralChannelDecisionStump::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_detector_5fmodel_2eproto();
  return *default_instance_;
}

IntegralChannelDecisionStump* IntegralChannelDecisionStump::default_instance_ = NULL;

IntegralChannelDecisionStump* IntegralChannelDecisionStump::New() const {
  return new IntegralChannelDecisionStump;
}

void IntegralChannelDecisionStump::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_feature()) {
      if (feature_ != NULL) feature_->::doppia_protobuf::IntegralChannelsFeature::Clear();
    }
    feature_threshold_ = 0;
    larger_than_threshold_ = false;
    true_leaf_weight_ = 0;
    false_leaf_weight_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IntegralChannelDecisionStump::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .doppia_protobuf.IntegralChannelsFeature feature = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_feature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_feature_threshold;
        break;
      }

      // required float feature_threshold = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_feature_threshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &feature_threshold_)));
          set_has_feature_threshold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_larger_than_threshold;
        break;
      }

      // optional bool larger_than_threshold = 3 [default = false];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_larger_than_threshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &larger_than_threshold_)));
          set_has_larger_than_threshold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(85)) goto parse_true_leaf_weight;
        break;
      }

      // optional float true_leaf_weight = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_true_leaf_weight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &true_leaf_weight_)));
          set_has_true_leaf_weight();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(93)) goto parse_false_leaf_weight;
        break;
      }

      // optional float false_leaf_weight = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_false_leaf_weight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &false_leaf_weight_)));
          set_has_false_leaf_weight();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IntegralChannelDecisionStump::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .doppia_protobuf.IntegralChannelsFeature feature = 1;
  if (has_feature()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->feature(), output);
  }

  // required float feature_threshold = 2;
  if (has_feature_threshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->feature_threshold(), output);
  }

  // optional bool larger_than_threshold = 3 [default = false];
  if (has_larger_than_threshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->larger_than_threshold(), output);
  }

  // optional float true_leaf_weight = 10;
  if (has_true_leaf_weight()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->true_leaf_weight(), output);
  }

  // optional float false_leaf_weight = 11;
  if (has_false_leaf_weight()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->false_leaf_weight(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* IntegralChannelDecisionStump::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .doppia_protobuf.IntegralChannelsFeature feature = 1;
  if (has_feature()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->feature(), target);
  }

  // required float feature_threshold = 2;
  if (has_feature_threshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->feature_threshold(), target);
  }

  // optional bool larger_than_threshold = 3 [default = false];
  if (has_larger_than_threshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->larger_than_threshold(), target);
  }

  // optional float true_leaf_weight = 10;
  if (has_true_leaf_weight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->true_leaf_weight(), target);
  }

  // optional float false_leaf_weight = 11;
  if (has_false_leaf_weight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->false_leaf_weight(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int IntegralChannelDecisionStump::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .doppia_protobuf.IntegralChannelsFeature feature = 1;
    if (has_feature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->feature());
    }

    // required float feature_threshold = 2;
    if (has_feature_threshold()) {
      total_size += 1 + 4;
    }

    // optional bool larger_than_threshold = 3 [default = false];
    if (has_larger_than_threshold()) {
      total_size += 1 + 1;
    }

    // optional float true_leaf_weight = 10;
    if (has_true_leaf_weight()) {
      total_size += 1 + 4;
    }

    // optional float false_leaf_weight = 11;
    if (has_false_leaf_weight()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IntegralChannelDecisionStump::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IntegralChannelDecisionStump* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IntegralChannelDecisionStump*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IntegralChannelDecisionStump::MergeFrom(const IntegralChannelDecisionStump& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_feature()) {
      mutable_feature()->::doppia_protobuf::IntegralChannelsFeature::MergeFrom(from.feature());
    }
    if (from.has_feature_threshold()) {
      set_feature_threshold(from.feature_threshold());
    }
    if (from.has_larger_than_threshold()) {
      set_larger_than_threshold(from.larger_than_threshold());
    }
    if (from.has_true_leaf_weight()) {
      set_true_leaf_weight(from.true_leaf_weight());
    }
    if (from.has_false_leaf_weight()) {
      set_false_leaf_weight(from.false_leaf_weight());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IntegralChannelDecisionStump::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IntegralChannelDecisionStump::CopyFrom(const IntegralChannelDecisionStump& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntegralChannelDecisionStump::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_feature()) {
    if (!this->feature().IsInitialized()) return false;
  }
  return true;
}

void IntegralChannelDecisionStump::Swap(IntegralChannelDecisionStump* other) {
  if (other != this) {
    std::swap(feature_, other->feature_);
    std::swap(feature_threshold_, other->feature_threshold_);
    std::swap(larger_than_threshold_, other->larger_than_threshold_);
    std::swap(true_leaf_weight_, other->true_leaf_weight_);
    std::swap(false_leaf_weight_, other->false_leaf_weight_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IntegralChannelDecisionStump::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IntegralChannelDecisionStump_descriptor_;
  metadata.reflection = IntegralChannelDecisionStump_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int IntegralChannelBinaryDecisionTreeNode::kIdFieldNumber;
const int IntegralChannelBinaryDecisionTreeNode::kParentIdFieldNumber;
const int IntegralChannelBinaryDecisionTreeNode::kParentValueFieldNumber;
const int IntegralChannelBinaryDecisionTreeNode::kDecisionStumpFieldNumber;
#endif  // !_MSC_VER

IntegralChannelBinaryDecisionTreeNode::IntegralChannelBinaryDecisionTreeNode()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void IntegralChannelBinaryDecisionTreeNode::InitAsDefaultInstance() {
  decision_stump_ = const_cast< ::doppia_protobuf::IntegralChannelDecisionStump*>(&::doppia_protobuf::IntegralChannelDecisionStump::default_instance());
}

IntegralChannelBinaryDecisionTreeNode::IntegralChannelBinaryDecisionTreeNode(const IntegralChannelBinaryDecisionTreeNode& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void IntegralChannelBinaryDecisionTreeNode::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  parent_id_ = 0u;
  parent_value_ = false;
  decision_stump_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IntegralChannelBinaryDecisionTreeNode::~IntegralChannelBinaryDecisionTreeNode() {
  SharedDtor();
}

void IntegralChannelBinaryDecisionTreeNode::SharedDtor() {
  if (this != default_instance_) {
    delete decision_stump_;
  }
}

void IntegralChannelBinaryDecisionTreeNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IntegralChannelBinaryDecisionTreeNode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IntegralChannelBinaryDecisionTreeNode_descriptor_;
}

const IntegralChannelBinaryDecisionTreeNode& IntegralChannelBinaryDecisionTreeNode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_detector_5fmodel_2eproto();
  return *default_instance_;
}

IntegralChannelBinaryDecisionTreeNode* IntegralChannelBinaryDecisionTreeNode::default_instance_ = NULL;

IntegralChannelBinaryDecisionTreeNode* IntegralChannelBinaryDecisionTreeNode::New() const {
  return new IntegralChannelBinaryDecisionTreeNode;
}

void IntegralChannelBinaryDecisionTreeNode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
    parent_id_ = 0u;
    parent_value_ = false;
    if (has_decision_stump()) {
      if (decision_stump_ != NULL) decision_stump_->::doppia_protobuf::IntegralChannelDecisionStump::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IntegralChannelBinaryDecisionTreeNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_parent_id;
        break;
      }

      // required uint32 parent_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_parent_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &parent_id_)));
          set_has_parent_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_parent_value;
        break;
      }

      // optional bool parent_value = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_parent_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &parent_value_)));
          set_has_parent_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_decision_stump;
        break;
      }

      // optional .doppia_protobuf.IntegralChannelDecisionStump decision_stump = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_decision_stump:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_decision_stump()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IntegralChannelBinaryDecisionTreeNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 parent_id = 2;
  if (has_parent_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->parent_id(), output);
  }

  // optional bool parent_value = 3;
  if (has_parent_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->parent_value(), output);
  }

  // optional .doppia_protobuf.IntegralChannelDecisionStump decision_stump = 4;
  if (has_decision_stump()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->decision_stump(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* IntegralChannelBinaryDecisionTreeNode::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required uint32 parent_id = 2;
  if (has_parent_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->parent_id(), target);
  }

  // optional bool parent_value = 3;
  if (has_parent_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->parent_value(), target);
  }

  // optional .doppia_protobuf.IntegralChannelDecisionStump decision_stump = 4;
  if (has_decision_stump()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->decision_stump(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int IntegralChannelBinaryDecisionTreeNode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 parent_id = 2;
    if (has_parent_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->parent_id());
    }

    // optional bool parent_value = 3;
    if (has_parent_value()) {
      total_size += 1 + 1;
    }

    // optional .doppia_protobuf.IntegralChannelDecisionStump decision_stump = 4;
    if (has_decision_stump()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->decision_stump());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IntegralChannelBinaryDecisionTreeNode::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IntegralChannelBinaryDecisionTreeNode* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IntegralChannelBinaryDecisionTreeNode*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IntegralChannelBinaryDecisionTreeNode::MergeFrom(const IntegralChannelBinaryDecisionTreeNode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_parent_id()) {
      set_parent_id(from.parent_id());
    }
    if (from.has_parent_value()) {
      set_parent_value(from.parent_value());
    }
    if (from.has_decision_stump()) {
      mutable_decision_stump()->::doppia_protobuf::IntegralChannelDecisionStump::MergeFrom(from.decision_stump());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IntegralChannelBinaryDecisionTreeNode::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IntegralChannelBinaryDecisionTreeNode::CopyFrom(const IntegralChannelBinaryDecisionTreeNode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntegralChannelBinaryDecisionTreeNode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_decision_stump()) {
    if (!this->decision_stump().IsInitialized()) return false;
  }
  return true;
}

void IntegralChannelBinaryDecisionTreeNode::Swap(IntegralChannelBinaryDecisionTreeNode* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(parent_id_, other->parent_id_);
    std::swap(parent_value_, other->parent_value_);
    std::swap(decision_stump_, other->decision_stump_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IntegralChannelBinaryDecisionTreeNode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IntegralChannelBinaryDecisionTreeNode_descriptor_;
  metadata.reflection = IntegralChannelBinaryDecisionTreeNode_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int IntegralChannelBinaryDecisionTree::kNodesFieldNumber;
#endif  // !_MSC_VER

IntegralChannelBinaryDecisionTree::IntegralChannelBinaryDecisionTree()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void IntegralChannelBinaryDecisionTree::InitAsDefaultInstance() {
}

IntegralChannelBinaryDecisionTree::IntegralChannelBinaryDecisionTree(const IntegralChannelBinaryDecisionTree& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void IntegralChannelBinaryDecisionTree::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IntegralChannelBinaryDecisionTree::~IntegralChannelBinaryDecisionTree() {
  SharedDtor();
}

void IntegralChannelBinaryDecisionTree::SharedDtor() {
  if (this != default_instance_) {
  }
}

void IntegralChannelBinaryDecisionTree::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IntegralChannelBinaryDecisionTree::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IntegralChannelBinaryDecisionTree_descriptor_;
}

const IntegralChannelBinaryDecisionTree& IntegralChannelBinaryDecisionTree::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_detector_5fmodel_2eproto();
  return *default_instance_;
}

IntegralChannelBinaryDecisionTree* IntegralChannelBinaryDecisionTree::default_instance_ = NULL;

IntegralChannelBinaryDecisionTree* IntegralChannelBinaryDecisionTree::New() const {
  return new IntegralChannelBinaryDecisionTree;
}

void IntegralChannelBinaryDecisionTree::Clear() {
  nodes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IntegralChannelBinaryDecisionTree::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .doppia_protobuf.IntegralChannelBinaryDecisionTreeNode nodes = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nodes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_nodes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_nodes;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IntegralChannelBinaryDecisionTree::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .doppia_protobuf.IntegralChannelBinaryDecisionTreeNode nodes = 1;
  for (int i = 0; i < this->nodes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->nodes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* IntegralChannelBinaryDecisionTree::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .doppia_protobuf.IntegralChannelBinaryDecisionTreeNode nodes = 1;
  for (int i = 0; i < this->nodes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->nodes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int IntegralChannelBinaryDecisionTree::ByteSize() const {
  int total_size = 0;

  // repeated .doppia_protobuf.IntegralChannelBinaryDecisionTreeNode nodes = 1;
  total_size += 1 * this->nodes_size();
  for (int i = 0; i < this->nodes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->nodes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IntegralChannelBinaryDecisionTree::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IntegralChannelBinaryDecisionTree* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IntegralChannelBinaryDecisionTree*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IntegralChannelBinaryDecisionTree::MergeFrom(const IntegralChannelBinaryDecisionTree& from) {
  GOOGLE_CHECK_NE(&from, this);
  nodes_.MergeFrom(from.nodes_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IntegralChannelBinaryDecisionTree::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IntegralChannelBinaryDecisionTree::CopyFrom(const IntegralChannelBinaryDecisionTree& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntegralChannelBinaryDecisionTree::IsInitialized() const {

  for (int i = 0; i < nodes_size(); i++) {
    if (!this->nodes(i).IsInitialized()) return false;
  }
  return true;
}

void IntegralChannelBinaryDecisionTree::Swap(IntegralChannelBinaryDecisionTree* other) {
  if (other != this) {
    nodes_.Swap(&other->nodes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IntegralChannelBinaryDecisionTree::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IntegralChannelBinaryDecisionTree_descriptor_;
  metadata.reflection = IntegralChannelBinaryDecisionTree_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int IntegralChannelStumpSet::kNodesFieldNumber;
const int IntegralChannelStumpSet::kWeightsFieldNumber;
#endif  // !_MSC_VER

IntegralChannelStumpSet::IntegralChannelStumpSet()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void IntegralChannelStumpSet::InitAsDefaultInstance() {
}

IntegralChannelStumpSet::IntegralChannelStumpSet(const IntegralChannelStumpSet& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void IntegralChannelStumpSet::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IntegralChannelStumpSet::~IntegralChannelStumpSet() {
  SharedDtor();
}

void IntegralChannelStumpSet::SharedDtor() {
  if (this != default_instance_) {
  }
}

void IntegralChannelStumpSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IntegralChannelStumpSet::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IntegralChannelStumpSet_descriptor_;
}

const IntegralChannelStumpSet& IntegralChannelStumpSet::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_detector_5fmodel_2eproto();
  return *default_instance_;
}

IntegralChannelStumpSet* IntegralChannelStumpSet::default_instance_ = NULL;

IntegralChannelStumpSet* IntegralChannelStumpSet::New() const {
  return new IntegralChannelStumpSet;
}

void IntegralChannelStumpSet::Clear() {
  nodes_.Clear();
  weights_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IntegralChannelStumpSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .doppia_protobuf.IntegralChannelDecisionStump nodes = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nodes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_nodes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_nodes;
        if (input->ExpectTag(21)) goto parse_weights;
        break;
      }

      // repeated float weights = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_weights:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_weights())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_weights())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_weights;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IntegralChannelStumpSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .doppia_protobuf.IntegralChannelDecisionStump nodes = 1;
  for (int i = 0; i < this->nodes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->nodes(i), output);
  }

  // repeated float weights = 2;
  for (int i = 0; i < this->weights_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->weights(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* IntegralChannelStumpSet::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .doppia_protobuf.IntegralChannelDecisionStump nodes = 1;
  for (int i = 0; i < this->nodes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->nodes(i), target);
  }

  // repeated float weights = 2;
  for (int i = 0; i < this->weights_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(2, this->weights(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int IntegralChannelStumpSet::ByteSize() const {
  int total_size = 0;

  // repeated .doppia_protobuf.IntegralChannelDecisionStump nodes = 1;
  total_size += 1 * this->nodes_size();
  for (int i = 0; i < this->nodes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->nodes(i));
  }

  // repeated float weights = 2;
  {
    int data_size = 0;
    data_size = 4 * this->weights_size();
    total_size += 1 * this->weights_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IntegralChannelStumpSet::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IntegralChannelStumpSet* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IntegralChannelStumpSet*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IntegralChannelStumpSet::MergeFrom(const IntegralChannelStumpSet& from) {
  GOOGLE_CHECK_NE(&from, this);
  nodes_.MergeFrom(from.nodes_);
  weights_.MergeFrom(from.weights_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IntegralChannelStumpSet::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IntegralChannelStumpSet::CopyFrom(const IntegralChannelStumpSet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntegralChannelStumpSet::IsInitialized() const {

  for (int i = 0; i < nodes_size(); i++) {
    if (!this->nodes(i).IsInitialized()) return false;
  }
  return true;
}

void IntegralChannelStumpSet::Swap(IntegralChannelStumpSet* other) {
  if (other != this) {
    nodes_.Swap(&other->nodes_);
    weights_.Swap(&other->weights_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IntegralChannelStumpSet::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IntegralChannelStumpSet_descriptor_;
  metadata.reflection = IntegralChannelStumpSet_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* SoftCascadeOverIntegralChannelsStage_FeatureTypes_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SoftCascadeOverIntegralChannelsStage_FeatureTypes_descriptor_;
}
bool SoftCascadeOverIntegralChannelsStage_FeatureTypes_IsValid(int value) {
  switch(value) {
    case 0:
    case 10:
    case 100:
    case 200:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const SoftCascadeOverIntegralChannelsStage_FeatureTypes SoftCascadeOverIntegralChannelsStage::Stumps;
const SoftCascadeOverIntegralChannelsStage_FeatureTypes SoftCascadeOverIntegralChannelsStage::Level2DecisionTree;
const SoftCascadeOverIntegralChannelsStage_FeatureTypes SoftCascadeOverIntegralChannelsStage::LevelNDecisionTree;
const SoftCascadeOverIntegralChannelsStage_FeatureTypes SoftCascadeOverIntegralChannelsStage::StumpSet;
const SoftCascadeOverIntegralChannelsStage_FeatureTypes SoftCascadeOverIntegralChannelsStage::FeatureTypes_MIN;
const SoftCascadeOverIntegralChannelsStage_FeatureTypes SoftCascadeOverIntegralChannelsStage::FeatureTypes_MAX;
const int SoftCascadeOverIntegralChannelsStage::FeatureTypes_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int SoftCascadeOverIntegralChannelsStage::kFeatureTypeFieldNumber;
const int SoftCascadeOverIntegralChannelsStage::kDecisionStumpFieldNumber;
const int SoftCascadeOverIntegralChannelsStage::kLevel2DecisionTreeFieldNumber;
const int SoftCascadeOverIntegralChannelsStage::kLevelNDecisionTreeFieldNumber;
const int SoftCascadeOverIntegralChannelsStage::kStumpSetFieldNumber;
const int SoftCascadeOverIntegralChannelsStage::kWeightFieldNumber;
const int SoftCascadeOverIntegralChannelsStage::kCascadeThresholdFieldNumber;
#endif  // !_MSC_VER

SoftCascadeOverIntegralChannelsStage::SoftCascadeOverIntegralChannelsStage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SoftCascadeOverIntegralChannelsStage::InitAsDefaultInstance() {
  decision_stump_ = const_cast< ::doppia_protobuf::IntegralChannelDecisionStump*>(&::doppia_protobuf::IntegralChannelDecisionStump::default_instance());
  level2_decision_tree_ = const_cast< ::doppia_protobuf::IntegralChannelBinaryDecisionTree*>(&::doppia_protobuf::IntegralChannelBinaryDecisionTree::default_instance());
  leveln_decision_tree_ = const_cast< ::doppia_protobuf::IntegralChannelBinaryDecisionTree*>(&::doppia_protobuf::IntegralChannelBinaryDecisionTree::default_instance());
  stump_set_ = const_cast< ::doppia_protobuf::IntegralChannelStumpSet*>(&::doppia_protobuf::IntegralChannelStumpSet::default_instance());
}

SoftCascadeOverIntegralChannelsStage::SoftCascadeOverIntegralChannelsStage(const SoftCascadeOverIntegralChannelsStage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SoftCascadeOverIntegralChannelsStage::SharedCtor() {
  _cached_size_ = 0;
  feature_type_ = 0;
  decision_stump_ = NULL;
  level2_decision_tree_ = NULL;
  leveln_decision_tree_ = NULL;
  stump_set_ = NULL;
  weight_ = 0;
  cascade_threshold_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SoftCascadeOverIntegralChannelsStage::~SoftCascadeOverIntegralChannelsStage() {
  SharedDtor();
}

void SoftCascadeOverIntegralChannelsStage::SharedDtor() {
  if (this != default_instance_) {
    delete decision_stump_;
    delete level2_decision_tree_;
    delete leveln_decision_tree_;
    delete stump_set_;
  }
}

void SoftCascadeOverIntegralChannelsStage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SoftCascadeOverIntegralChannelsStage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SoftCascadeOverIntegralChannelsStage_descriptor_;
}

const SoftCascadeOverIntegralChannelsStage& SoftCascadeOverIntegralChannelsStage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_detector_5fmodel_2eproto();
  return *default_instance_;
}

SoftCascadeOverIntegralChannelsStage* SoftCascadeOverIntegralChannelsStage::default_instance_ = NULL;

SoftCascadeOverIntegralChannelsStage* SoftCascadeOverIntegralChannelsStage::New() const {
  return new SoftCascadeOverIntegralChannelsStage;
}

void SoftCascadeOverIntegralChannelsStage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    feature_type_ = 0;
    if (has_decision_stump()) {
      if (decision_stump_ != NULL) decision_stump_->::doppia_protobuf::IntegralChannelDecisionStump::Clear();
    }
    if (has_level2_decision_tree()) {
      if (level2_decision_tree_ != NULL) level2_decision_tree_->::doppia_protobuf::IntegralChannelBinaryDecisionTree::Clear();
    }
    if (has_leveln_decision_tree()) {
      if (leveln_decision_tree_ != NULL) leveln_decision_tree_->::doppia_protobuf::IntegralChannelBinaryDecisionTree::Clear();
    }
    if (has_stump_set()) {
      if (stump_set_ != NULL) stump_set_->::doppia_protobuf::IntegralChannelStumpSet::Clear();
    }
    weight_ = 0;
    cascade_threshold_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SoftCascadeOverIntegralChannelsStage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .doppia_protobuf.SoftCascadeOverIntegralChannelsStage.FeatureTypes feature_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::doppia_protobuf::SoftCascadeOverIntegralChannelsStage_FeatureTypes_IsValid(value)) {
            set_feature_type(static_cast< ::doppia_protobuf::SoftCascadeOverIntegralChannelsStage_FeatureTypes >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_weight;
        break;
      }

      // required float weight = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_weight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &weight_)));
          set_has_weight();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_cascade_threshold;
        break;
      }

      // required float cascade_threshold = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_cascade_threshold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cascade_threshold_)));
          set_has_cascade_threshold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_decision_stump;
        break;
      }

      // optional .doppia_protobuf.IntegralChannelDecisionStump decision_stump = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_decision_stump:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_decision_stump()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_level2_decision_tree;
        break;
      }

      // optional .doppia_protobuf.IntegralChannelBinaryDecisionTree level2_decision_tree = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_level2_decision_tree:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_level2_decision_tree()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_levelN_decision_tree;
        break;
      }

      // optional .doppia_protobuf.IntegralChannelBinaryDecisionTree levelN_decision_tree = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_levelN_decision_tree:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_leveln_decision_tree()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_stump_set;
        break;
      }

      // optional .doppia_protobuf.IntegralChannelStumpSet stump_set = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_stump_set:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stump_set()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SoftCascadeOverIntegralChannelsStage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .doppia_protobuf.SoftCascadeOverIntegralChannelsStage.FeatureTypes feature_type = 1;
  if (has_feature_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->feature_type(), output);
  }

  // required float weight = 2;
  if (has_weight()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->weight(), output);
  }

  // required float cascade_threshold = 3;
  if (has_cascade_threshold()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->cascade_threshold(), output);
  }

  // optional .doppia_protobuf.IntegralChannelDecisionStump decision_stump = 10;
  if (has_decision_stump()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->decision_stump(), output);
  }

  // optional .doppia_protobuf.IntegralChannelBinaryDecisionTree level2_decision_tree = 11;
  if (has_level2_decision_tree()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->level2_decision_tree(), output);
  }

  // optional .doppia_protobuf.IntegralChannelBinaryDecisionTree levelN_decision_tree = 12;
  if (has_leveln_decision_tree()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->leveln_decision_tree(), output);
  }

  // optional .doppia_protobuf.IntegralChannelStumpSet stump_set = 13;
  if (has_stump_set()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->stump_set(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SoftCascadeOverIntegralChannelsStage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .doppia_protobuf.SoftCascadeOverIntegralChannelsStage.FeatureTypes feature_type = 1;
  if (has_feature_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->feature_type(), target);
  }

  // required float weight = 2;
  if (has_weight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->weight(), target);
  }

  // required float cascade_threshold = 3;
  if (has_cascade_threshold()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->cascade_threshold(), target);
  }

  // optional .doppia_protobuf.IntegralChannelDecisionStump decision_stump = 10;
  if (has_decision_stump()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->decision_stump(), target);
  }

  // optional .doppia_protobuf.IntegralChannelBinaryDecisionTree level2_decision_tree = 11;
  if (has_level2_decision_tree()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->level2_decision_tree(), target);
  }

  // optional .doppia_protobuf.IntegralChannelBinaryDecisionTree levelN_decision_tree = 12;
  if (has_leveln_decision_tree()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->leveln_decision_tree(), target);
  }

  // optional .doppia_protobuf.IntegralChannelStumpSet stump_set = 13;
  if (has_stump_set()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->stump_set(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SoftCascadeOverIntegralChannelsStage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .doppia_protobuf.SoftCascadeOverIntegralChannelsStage.FeatureTypes feature_type = 1;
    if (has_feature_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->feature_type());
    }

    // optional .doppia_protobuf.IntegralChannelDecisionStump decision_stump = 10;
    if (has_decision_stump()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->decision_stump());
    }

    // optional .doppia_protobuf.IntegralChannelBinaryDecisionTree level2_decision_tree = 11;
    if (has_level2_decision_tree()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->level2_decision_tree());
    }

    // optional .doppia_protobuf.IntegralChannelBinaryDecisionTree levelN_decision_tree = 12;
    if (has_leveln_decision_tree()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->leveln_decision_tree());
    }

    // optional .doppia_protobuf.IntegralChannelStumpSet stump_set = 13;
    if (has_stump_set()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->stump_set());
    }

    // required float weight = 2;
    if (has_weight()) {
      total_size += 1 + 4;
    }

    // required float cascade_threshold = 3;
    if (has_cascade_threshold()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SoftCascadeOverIntegralChannelsStage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SoftCascadeOverIntegralChannelsStage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SoftCascadeOverIntegralChannelsStage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SoftCascadeOverIntegralChannelsStage::MergeFrom(const SoftCascadeOverIntegralChannelsStage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_feature_type()) {
      set_feature_type(from.feature_type());
    }
    if (from.has_decision_stump()) {
      mutable_decision_stump()->::doppia_protobuf::IntegralChannelDecisionStump::MergeFrom(from.decision_stump());
    }
    if (from.has_level2_decision_tree()) {
      mutable_level2_decision_tree()->::doppia_protobuf::IntegralChannelBinaryDecisionTree::MergeFrom(from.level2_decision_tree());
    }
    if (from.has_leveln_decision_tree()) {
      mutable_leveln_decision_tree()->::doppia_protobuf::IntegralChannelBinaryDecisionTree::MergeFrom(from.leveln_decision_tree());
    }
    if (from.has_stump_set()) {
      mutable_stump_set()->::doppia_protobuf::IntegralChannelStumpSet::MergeFrom(from.stump_set());
    }
    if (from.has_weight()) {
      set_weight(from.weight());
    }
    if (from.has_cascade_threshold()) {
      set_cascade_threshold(from.cascade_threshold());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SoftCascadeOverIntegralChannelsStage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SoftCascadeOverIntegralChannelsStage::CopyFrom(const SoftCascadeOverIntegralChannelsStage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SoftCascadeOverIntegralChannelsStage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000061) != 0x00000061) return false;

  if (has_decision_stump()) {
    if (!this->decision_stump().IsInitialized()) return false;
  }
  if (has_level2_decision_tree()) {
    if (!this->level2_decision_tree().IsInitialized()) return false;
  }
  if (has_leveln_decision_tree()) {
    if (!this->leveln_decision_tree().IsInitialized()) return false;
  }
  if (has_stump_set()) {
    if (!this->stump_set().IsInitialized()) return false;
  }
  return true;
}

void SoftCascadeOverIntegralChannelsStage::Swap(SoftCascadeOverIntegralChannelsStage* other) {
  if (other != this) {
    std::swap(feature_type_, other->feature_type_);
    std::swap(decision_stump_, other->decision_stump_);
    std::swap(level2_decision_tree_, other->level2_decision_tree_);
    std::swap(leveln_decision_tree_, other->leveln_decision_tree_);
    std::swap(stump_set_, other->stump_set_);
    std::swap(weight_, other->weight_);
    std::swap(cascade_threshold_, other->cascade_threshold_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SoftCascadeOverIntegralChannelsStage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SoftCascadeOverIntegralChannelsStage_descriptor_;
  metadata.reflection = SoftCascadeOverIntegralChannelsStage_reflection_;
  return metadata;
}


// ===================================================================

::std::string* SoftCascadeOverIntegralChannelsModel::_default_channels_description_ = NULL;
#ifndef _MSC_VER
const int SoftCascadeOverIntegralChannelsModel::kStagesFieldNumber;
const int SoftCascadeOverIntegralChannelsModel::kChannelsDescriptionFieldNumber;
const int SoftCascadeOverIntegralChannelsModel::kShrinkingFactorFieldNumber;
#endif  // !_MSC_VER

SoftCascadeOverIntegralChannelsModel::SoftCascadeOverIntegralChannelsModel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SoftCascadeOverIntegralChannelsModel::InitAsDefaultInstance() {
}

SoftCascadeOverIntegralChannelsModel::SoftCascadeOverIntegralChannelsModel(const SoftCascadeOverIntegralChannelsModel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SoftCascadeOverIntegralChannelsModel::SharedCtor() {
  _cached_size_ = 0;
  channels_description_ = const_cast< ::std::string*>(_default_channels_description_);
  shrinking_factor_ = 4u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SoftCascadeOverIntegralChannelsModel::~SoftCascadeOverIntegralChannelsModel() {
  SharedDtor();
}

void SoftCascadeOverIntegralChannelsModel::SharedDtor() {
  if (channels_description_ != _default_channels_description_) {
    delete channels_description_;
  }
  if (this != default_instance_) {
  }
}

void SoftCascadeOverIntegralChannelsModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SoftCascadeOverIntegralChannelsModel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SoftCascadeOverIntegralChannelsModel_descriptor_;
}

const SoftCascadeOverIntegralChannelsModel& SoftCascadeOverIntegralChannelsModel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_detector_5fmodel_2eproto();
  return *default_instance_;
}

SoftCascadeOverIntegralChannelsModel* SoftCascadeOverIntegralChannelsModel::default_instance_ = NULL;

SoftCascadeOverIntegralChannelsModel* SoftCascadeOverIntegralChannelsModel::New() const {
  return new SoftCascadeOverIntegralChannelsModel;
}

void SoftCascadeOverIntegralChannelsModel::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_channels_description()) {
      if (channels_description_ != _default_channels_description_) {
        channels_description_->assign(*_default_channels_description_);
      }
    }
    shrinking_factor_ = 4u;
  }
  stages_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SoftCascadeOverIntegralChannelsModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .doppia_protobuf.SoftCascadeOverIntegralChannelsStage stages = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_stages:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_stages()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_stages;
        if (input->ExpectTag(18)) goto parse_channels_description;
        break;
      }

      // optional string channels_description = 2 [default = "hog6_luv"];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_channels_description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_channels_description()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->channels_description().data(), this->channels_description().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_shrinking_factor;
        break;
      }

      // optional uint32 shrinking_factor = 3 [default = 4];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_shrinking_factor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shrinking_factor_)));
          set_has_shrinking_factor();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SoftCascadeOverIntegralChannelsModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .doppia_protobuf.SoftCascadeOverIntegralChannelsStage stages = 1;
  for (int i = 0; i < this->stages_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->stages(i), output);
  }

  // optional string channels_description = 2 [default = "hog6_luv"];
  if (has_channels_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->channels_description().data(), this->channels_description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->channels_description(), output);
  }

  // optional uint32 shrinking_factor = 3 [default = 4];
  if (has_shrinking_factor()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->shrinking_factor(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SoftCascadeOverIntegralChannelsModel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .doppia_protobuf.SoftCascadeOverIntegralChannelsStage stages = 1;
  for (int i = 0; i < this->stages_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->stages(i), target);
  }

  // optional string channels_description = 2 [default = "hog6_luv"];
  if (has_channels_description()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->channels_description().data(), this->channels_description().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->channels_description(), target);
  }

  // optional uint32 shrinking_factor = 3 [default = 4];
  if (has_shrinking_factor()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->shrinking_factor(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SoftCascadeOverIntegralChannelsModel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string channels_description = 2 [default = "hog6_luv"];
    if (has_channels_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->channels_description());
    }

    // optional uint32 shrinking_factor = 3 [default = 4];
    if (has_shrinking_factor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shrinking_factor());
    }

  }
  // repeated .doppia_protobuf.SoftCascadeOverIntegralChannelsStage stages = 1;
  total_size += 1 * this->stages_size();
  for (int i = 0; i < this->stages_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->stages(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SoftCascadeOverIntegralChannelsModel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SoftCascadeOverIntegralChannelsModel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SoftCascadeOverIntegralChannelsModel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SoftCascadeOverIntegralChannelsModel::MergeFrom(const SoftCascadeOverIntegralChannelsModel& from) {
  GOOGLE_CHECK_NE(&from, this);
  stages_.MergeFrom(from.stages_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_channels_description()) {
      set_channels_description(from.channels_description());
    }
    if (from.has_shrinking_factor()) {
      set_shrinking_factor(from.shrinking_factor());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SoftCascadeOverIntegralChannelsModel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SoftCascadeOverIntegralChannelsModel::CopyFrom(const SoftCascadeOverIntegralChannelsModel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SoftCascadeOverIntegralChannelsModel::IsInitialized() const {

  for (int i = 0; i < stages_size(); i++) {
    if (!this->stages(i).IsInitialized()) return false;
  }
  return true;
}

void SoftCascadeOverIntegralChannelsModel::Swap(SoftCascadeOverIntegralChannelsModel* other) {
  if (other != this) {
    stages_.Swap(&other->stages_);
    std::swap(channels_description_, other->channels_description_);
    std::swap(shrinking_factor_, other->shrinking_factor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SoftCascadeOverIntegralChannelsModel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SoftCascadeOverIntegralChannelsModel_descriptor_;
  metadata.reflection = SoftCascadeOverIntegralChannelsModel_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* DetectorModel_DetectorTypes_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DetectorModel_DetectorTypes_descriptor_;
}
bool DetectorModel_DetectorTypes_IsValid(int value) {
  switch(value) {
    case 0:
    case 10:
    case 20:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DetectorModel_DetectorTypes DetectorModel::LinearSvm;
const DetectorModel_DetectorTypes DetectorModel::SoftCascadeOverIntegralChannels;
const DetectorModel_DetectorTypes DetectorModel::HoughForest;
const DetectorModel_DetectorTypes DetectorModel::DetectorTypes_MIN;
const DetectorModel_DetectorTypes DetectorModel::DetectorTypes_MAX;
const int DetectorModel::DetectorTypes_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* DetectorModel_OcclusionTypes_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DetectorModel_OcclusionTypes_descriptor_;
}
bool DetectorModel_OcclusionTypes_IsValid(int value) {
  switch(value) {
    case 10:
    case 11:
    case 20:
    case 21:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const DetectorModel_OcclusionTypes DetectorModel::LeftOcclusion;
const DetectorModel_OcclusionTypes DetectorModel::RightOcclusion;
const DetectorModel_OcclusionTypes DetectorModel::BottomOcclusion;
const DetectorModel_OcclusionTypes DetectorModel::TopOcclusion;
const DetectorModel_OcclusionTypes DetectorModel::OcclusionTypes_MIN;
const DetectorModel_OcclusionTypes DetectorModel::OcclusionTypes_MAX;
const int DetectorModel::OcclusionTypes_ARRAYSIZE;
#endif  // _MSC_VER
::std::string* DetectorModel::_default_semantic_category_ = NULL;
#ifndef _MSC_VER
const int DetectorModel::kDetectorNameFieldNumber;
const int DetectorModel::kTrainingDatasetNameFieldNumber;
const int DetectorModel::kSemanticCategoryFieldNumber;
const int DetectorModel::kModelWindowSizeFieldNumber;
const int DetectorModel::kObjectWindowFieldNumber;
const int DetectorModel::kDetectorTypeFieldNumber;
const int DetectorModel::kLinearSvmModelFieldNumber;
const int DetectorModel::kSoftCascadeModelFieldNumber;
const int DetectorModel::kScaleFieldNumber;
const int DetectorModel::kOcclusionLevelFieldNumber;
const int DetectorModel::kOcclusionTypeFieldNumber;
#endif  // !_MSC_VER

DetectorModel::DetectorModel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DetectorModel::InitAsDefaultInstance() {
  model_window_size_ = const_cast< ::doppia_protobuf::Point2d*>(&::doppia_protobuf::Point2d::default_instance());
  object_window_ = const_cast< ::doppia_protobuf::Box*>(&::doppia_protobuf::Box::default_instance());
  linear_svm_model_ = const_cast< ::doppia_protobuf::LinearSvmModel*>(&::doppia_protobuf::LinearSvmModel::default_instance());
  soft_cascade_model_ = const_cast< ::doppia_protobuf::SoftCascadeOverIntegralChannelsModel*>(&::doppia_protobuf::SoftCascadeOverIntegralChannelsModel::default_instance());
}

DetectorModel::DetectorModel(const DetectorModel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DetectorModel::SharedCtor() {
  _cached_size_ = 0;
  detector_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  training_dataset_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  semantic_category_ = const_cast< ::std::string*>(_default_semantic_category_);
  model_window_size_ = NULL;
  object_window_ = NULL;
  detector_type_ = 0;
  linear_svm_model_ = NULL;
  soft_cascade_model_ = NULL;
  scale_ = 1;
  occlusion_level_ = 0;
  occlusion_type_ = 20;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DetectorModel::~DetectorModel() {
  SharedDtor();
}

void DetectorModel::SharedDtor() {
  if (detector_name_ != &::google::protobuf::internal::kEmptyString) {
    delete detector_name_;
  }
  if (training_dataset_name_ != &::google::protobuf::internal::kEmptyString) {
    delete training_dataset_name_;
  }
  if (semantic_category_ != _default_semantic_category_) {
    delete semantic_category_;
  }
  if (this != default_instance_) {
    delete model_window_size_;
    delete object_window_;
    delete linear_svm_model_;
    delete soft_cascade_model_;
  }
}

void DetectorModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DetectorModel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DetectorModel_descriptor_;
}

const DetectorModel& DetectorModel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_detector_5fmodel_2eproto();
  return *default_instance_;
}

DetectorModel* DetectorModel::default_instance_ = NULL;

DetectorModel* DetectorModel::New() const {
  return new DetectorModel;
}

void DetectorModel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_detector_name()) {
      if (detector_name_ != &::google::protobuf::internal::kEmptyString) {
        detector_name_->clear();
      }
    }
    if (has_training_dataset_name()) {
      if (training_dataset_name_ != &::google::protobuf::internal::kEmptyString) {
        training_dataset_name_->clear();
      }
    }
    if (has_semantic_category()) {
      if (semantic_category_ != _default_semantic_category_) {
        semantic_category_->assign(*_default_semantic_category_);
      }
    }
    if (has_model_window_size()) {
      if (model_window_size_ != NULL) model_window_size_->::doppia_protobuf::Point2d::Clear();
    }
    if (has_object_window()) {
      if (object_window_ != NULL) object_window_->::doppia_protobuf::Box::Clear();
    }
    detector_type_ = 0;
    if (has_linear_svm_model()) {
      if (linear_svm_model_ != NULL) linear_svm_model_->::doppia_protobuf::LinearSvmModel::Clear();
    }
    if (has_soft_cascade_model()) {
      if (soft_cascade_model_ != NULL) soft_cascade_model_->::doppia_protobuf::SoftCascadeOverIntegralChannelsModel::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    scale_ = 1;
    occlusion_level_ = 0;
    occlusion_type_ = 20;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DetectorModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string detector_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_detector_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->detector_name().data(), this->detector_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_training_dataset_name;
        break;
      }

      // required string training_dataset_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_training_dataset_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_training_dataset_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->training_dataset_name().data(), this->training_dataset_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_detector_type;
        break;
      }

      // required .doppia_protobuf.DetectorModel.DetectorTypes detector_type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_detector_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::doppia_protobuf::DetectorModel_DetectorTypes_IsValid(value)) {
            set_detector_type(static_cast< ::doppia_protobuf::DetectorModel_DetectorTypes >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_model_window_size;
        break;
      }

      // optional .doppia_protobuf.Point2d model_window_size = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_model_window_size:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_model_window_size()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_object_window;
        break;
      }

      // optional .doppia_protobuf.Box object_window = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_object_window:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_object_window()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(802)) goto parse_linear_svm_model;
        break;
      }

      // optional .doppia_protobuf.LinearSvmModel linear_svm_model = 100;
      case 100: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_linear_svm_model:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_linear_svm_model()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(818)) goto parse_soft_cascade_model;
        break;
      }

      // optional .doppia_protobuf.SoftCascadeOverIntegralChannelsModel soft_cascade_model = 102;
      case 102: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_soft_cascade_model:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_soft_cascade_model()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(1605)) goto parse_scale;
        break;
      }

      // optional float scale = 200 [default = 1];
      case 200: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
          set_has_scale();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(1685)) goto parse_occlusion_level;
        break;
      }

      // optional float occlusion_level = 210 [default = 0];
      case 210: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_occlusion_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &occlusion_level_)));
          set_has_occlusion_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(1688)) goto parse_occlusion_type;
        break;
      }

      // optional .doppia_protobuf.DetectorModel.OcclusionTypes occlusion_type = 211 [default = BottomOcclusion];
      case 211: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_occlusion_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::doppia_protobuf::DetectorModel_OcclusionTypes_IsValid(value)) {
            set_occlusion_type(static_cast< ::doppia_protobuf::DetectorModel_OcclusionTypes >(value));
          } else {
            mutable_unknown_fields()->AddVarint(211, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(2402)) goto parse_semantic_category;
        break;
      }

      // optional string semantic_category = 300 [default = "/m/017r8p"];
      case 300: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_semantic_category:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_semantic_category()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->semantic_category().data(), this->semantic_category().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DetectorModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string detector_name = 1;
  if (has_detector_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->detector_name().data(), this->detector_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->detector_name(), output);
  }

  // required string training_dataset_name = 2;
  if (has_training_dataset_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->training_dataset_name().data(), this->training_dataset_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->training_dataset_name(), output);
  }

  // required .doppia_protobuf.DetectorModel.DetectorTypes detector_type = 3;
  if (has_detector_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->detector_type(), output);
  }

  // optional .doppia_protobuf.Point2d model_window_size = 10;
  if (has_model_window_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->model_window_size(), output);
  }

  // optional .doppia_protobuf.Box object_window = 11;
  if (has_object_window()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->object_window(), output);
  }

  // optional .doppia_protobuf.LinearSvmModel linear_svm_model = 100;
  if (has_linear_svm_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      100, this->linear_svm_model(), output);
  }

  // optional .doppia_protobuf.SoftCascadeOverIntegralChannelsModel soft_cascade_model = 102;
  if (has_soft_cascade_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      102, this->soft_cascade_model(), output);
  }

  // optional float scale = 200 [default = 1];
  if (has_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(200, this->scale(), output);
  }

  // optional float occlusion_level = 210 [default = 0];
  if (has_occlusion_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(210, this->occlusion_level(), output);
  }

  // optional .doppia_protobuf.DetectorModel.OcclusionTypes occlusion_type = 211 [default = BottomOcclusion];
  if (has_occlusion_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      211, this->occlusion_type(), output);
  }

  // optional string semantic_category = 300 [default = "/m/017r8p"];
  if (has_semantic_category()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->semantic_category().data(), this->semantic_category().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      300, this->semantic_category(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DetectorModel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string detector_name = 1;
  if (has_detector_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->detector_name().data(), this->detector_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->detector_name(), target);
  }

  // required string training_dataset_name = 2;
  if (has_training_dataset_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->training_dataset_name().data(), this->training_dataset_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->training_dataset_name(), target);
  }

  // required .doppia_protobuf.DetectorModel.DetectorTypes detector_type = 3;
  if (has_detector_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->detector_type(), target);
  }

  // optional .doppia_protobuf.Point2d model_window_size = 10;
  if (has_model_window_size()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->model_window_size(), target);
  }

  // optional .doppia_protobuf.Box object_window = 11;
  if (has_object_window()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->object_window(), target);
  }

  // optional .doppia_protobuf.LinearSvmModel linear_svm_model = 100;
  if (has_linear_svm_model()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        100, this->linear_svm_model(), target);
  }

  // optional .doppia_protobuf.SoftCascadeOverIntegralChannelsModel soft_cascade_model = 102;
  if (has_soft_cascade_model()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        102, this->soft_cascade_model(), target);
  }

  // optional float scale = 200 [default = 1];
  if (has_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(200, this->scale(), target);
  }

  // optional float occlusion_level = 210 [default = 0];
  if (has_occlusion_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(210, this->occlusion_level(), target);
  }

  // optional .doppia_protobuf.DetectorModel.OcclusionTypes occlusion_type = 211 [default = BottomOcclusion];
  if (has_occlusion_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      211, this->occlusion_type(), target);
  }

  // optional string semantic_category = 300 [default = "/m/017r8p"];
  if (has_semantic_category()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->semantic_category().data(), this->semantic_category().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        300, this->semantic_category(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DetectorModel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string detector_name = 1;
    if (has_detector_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->detector_name());
    }

    // required string training_dataset_name = 2;
    if (has_training_dataset_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->training_dataset_name());
    }

    // optional string semantic_category = 300 [default = "/m/017r8p"];
    if (has_semantic_category()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->semantic_category());
    }

    // optional .doppia_protobuf.Point2d model_window_size = 10;
    if (has_model_window_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->model_window_size());
    }

    // optional .doppia_protobuf.Box object_window = 11;
    if (has_object_window()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->object_window());
    }

    // required .doppia_protobuf.DetectorModel.DetectorTypes detector_type = 3;
    if (has_detector_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->detector_type());
    }

    // optional .doppia_protobuf.LinearSvmModel linear_svm_model = 100;
    if (has_linear_svm_model()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->linear_svm_model());
    }

    // optional .doppia_protobuf.SoftCascadeOverIntegralChannelsModel soft_cascade_model = 102;
    if (has_soft_cascade_model()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->soft_cascade_model());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float scale = 200 [default = 1];
    if (has_scale()) {
      total_size += 2 + 4;
    }

    // optional float occlusion_level = 210 [default = 0];
    if (has_occlusion_level()) {
      total_size += 2 + 4;
    }

    // optional .doppia_protobuf.DetectorModel.OcclusionTypes occlusion_type = 211 [default = BottomOcclusion];
    if (has_occlusion_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->occlusion_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DetectorModel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DetectorModel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DetectorModel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DetectorModel::MergeFrom(const DetectorModel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_detector_name()) {
      set_detector_name(from.detector_name());
    }
    if (from.has_training_dataset_name()) {
      set_training_dataset_name(from.training_dataset_name());
    }
    if (from.has_semantic_category()) {
      set_semantic_category(from.semantic_category());
    }
    if (from.has_model_window_size()) {
      mutable_model_window_size()->::doppia_protobuf::Point2d::MergeFrom(from.model_window_size());
    }
    if (from.has_object_window()) {
      mutable_object_window()->::doppia_protobuf::Box::MergeFrom(from.object_window());
    }
    if (from.has_detector_type()) {
      set_detector_type(from.detector_type());
    }
    if (from.has_linear_svm_model()) {
      mutable_linear_svm_model()->::doppia_protobuf::LinearSvmModel::MergeFrom(from.linear_svm_model());
    }
    if (from.has_soft_cascade_model()) {
      mutable_soft_cascade_model()->::doppia_protobuf::SoftCascadeOverIntegralChannelsModel::MergeFrom(from.soft_cascade_model());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_scale()) {
      set_scale(from.scale());
    }
    if (from.has_occlusion_level()) {
      set_occlusion_level(from.occlusion_level());
    }
    if (from.has_occlusion_type()) {
      set_occlusion_type(from.occlusion_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DetectorModel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DetectorModel::CopyFrom(const DetectorModel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetectorModel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000022) != 0x00000022) return false;

  if (has_model_window_size()) {
    if (!this->model_window_size().IsInitialized()) return false;
  }
  if (has_object_window()) {
    if (!this->object_window().IsInitialized()) return false;
  }
  if (has_linear_svm_model()) {
    if (!this->linear_svm_model().IsInitialized()) return false;
  }
  if (has_soft_cascade_model()) {
    if (!this->soft_cascade_model().IsInitialized()) return false;
  }
  return true;
}

void DetectorModel::Swap(DetectorModel* other) {
  if (other != this) {
    std::swap(detector_name_, other->detector_name_);
    std::swap(training_dataset_name_, other->training_dataset_name_);
    std::swap(semantic_category_, other->semantic_category_);
    std::swap(model_window_size_, other->model_window_size_);
    std::swap(object_window_, other->object_window_);
    std::swap(detector_type_, other->detector_type_);
    std::swap(linear_svm_model_, other->linear_svm_model_);
    std::swap(soft_cascade_model_, other->soft_cascade_model_);
    std::swap(scale_, other->scale_);
    std::swap(occlusion_level_, other->occlusion_level_);
    std::swap(occlusion_type_, other->occlusion_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DetectorModel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DetectorModel_descriptor_;
  metadata.reflection = DetectorModel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MultiScalesDetectorModel::kDetectorNameFieldNumber;
const int MultiScalesDetectorModel::kTrainingDatasetNameFieldNumber;
const int MultiScalesDetectorModel::kDetectorsFieldNumber;
#endif  // !_MSC_VER

MultiScalesDetectorModel::MultiScalesDetectorModel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MultiScalesDetectorModel::InitAsDefaultInstance() {
}

MultiScalesDetectorModel::MultiScalesDetectorModel(const MultiScalesDetectorModel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MultiScalesDetectorModel::SharedCtor() {
  _cached_size_ = 0;
  detector_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  training_dataset_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MultiScalesDetectorModel::~MultiScalesDetectorModel() {
  SharedDtor();
}

void MultiScalesDetectorModel::SharedDtor() {
  if (detector_name_ != &::google::protobuf::internal::kEmptyString) {
    delete detector_name_;
  }
  if (training_dataset_name_ != &::google::protobuf::internal::kEmptyString) {
    delete training_dataset_name_;
  }
  if (this != default_instance_) {
  }
}

void MultiScalesDetectorModel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MultiScalesDetectorModel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MultiScalesDetectorModel_descriptor_;
}

const MultiScalesDetectorModel& MultiScalesDetectorModel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_detector_5fmodel_2eproto();
  return *default_instance_;
}

MultiScalesDetectorModel* MultiScalesDetectorModel::default_instance_ = NULL;

MultiScalesDetectorModel* MultiScalesDetectorModel::New() const {
  return new MultiScalesDetectorModel;
}

void MultiScalesDetectorModel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_detector_name()) {
      if (detector_name_ != &::google::protobuf::internal::kEmptyString) {
        detector_name_->clear();
      }
    }
    if (has_training_dataset_name()) {
      if (training_dataset_name_ != &::google::protobuf::internal::kEmptyString) {
        training_dataset_name_->clear();
      }
    }
  }
  detectors_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MultiScalesDetectorModel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string detector_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_detector_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->detector_name().data(), this->detector_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_training_dataset_name;
        break;
      }

      // required string training_dataset_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_training_dataset_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_training_dataset_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->training_dataset_name().data(), this->training_dataset_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_detectors;
        break;
      }

      // repeated .doppia_protobuf.DetectorModel detectors = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_detectors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_detectors()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_detectors;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MultiScalesDetectorModel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string detector_name = 1;
  if (has_detector_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->detector_name().data(), this->detector_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->detector_name(), output);
  }

  // required string training_dataset_name = 2;
  if (has_training_dataset_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->training_dataset_name().data(), this->training_dataset_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->training_dataset_name(), output);
  }

  // repeated .doppia_protobuf.DetectorModel detectors = 3;
  for (int i = 0; i < this->detectors_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->detectors(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MultiScalesDetectorModel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string detector_name = 1;
  if (has_detector_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->detector_name().data(), this->detector_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->detector_name(), target);
  }

  // required string training_dataset_name = 2;
  if (has_training_dataset_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->training_dataset_name().data(), this->training_dataset_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->training_dataset_name(), target);
  }

  // repeated .doppia_protobuf.DetectorModel detectors = 3;
  for (int i = 0; i < this->detectors_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->detectors(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MultiScalesDetectorModel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string detector_name = 1;
    if (has_detector_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->detector_name());
    }

    // required string training_dataset_name = 2;
    if (has_training_dataset_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->training_dataset_name());
    }

  }
  // repeated .doppia_protobuf.DetectorModel detectors = 3;
  total_size += 1 * this->detectors_size();
  for (int i = 0; i < this->detectors_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->detectors(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MultiScalesDetectorModel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MultiScalesDetectorModel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MultiScalesDetectorModel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MultiScalesDetectorModel::MergeFrom(const MultiScalesDetectorModel& from) {
  GOOGLE_CHECK_NE(&from, this);
  detectors_.MergeFrom(from.detectors_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_detector_name()) {
      set_detector_name(from.detector_name());
    }
    if (from.has_training_dataset_name()) {
      set_training_dataset_name(from.training_dataset_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MultiScalesDetectorModel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MultiScalesDetectorModel::CopyFrom(const MultiScalesDetectorModel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultiScalesDetectorModel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  for (int i = 0; i < detectors_size(); i++) {
    if (!this->detectors(i).IsInitialized()) return false;
  }
  return true;
}

void MultiScalesDetectorModel::Swap(MultiScalesDetectorModel* other) {
  if (other != this) {
    std::swap(detector_name_, other->detector_name_);
    std::swap(training_dataset_name_, other->training_dataset_name_);
    detectors_.Swap(&other->detectors_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MultiScalesDetectorModel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MultiScalesDetectorModel_descriptor_;
  metadata.reflection = MultiScalesDetectorModel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DetectorModelsBundle::kBundleNameFieldNumber;
const int DetectorModelsBundle::kTrainingDatasetNameFieldNumber;
const int DetectorModelsBundle::kDetectorsFieldNumber;
#endif  // !_MSC_VER

DetectorModelsBundle::DetectorModelsBundle()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DetectorModelsBundle::InitAsDefaultInstance() {
}

DetectorModelsBundle::DetectorModelsBundle(const DetectorModelsBundle& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DetectorModelsBundle::SharedCtor() {
  _cached_size_ = 0;
  bundle_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  training_dataset_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DetectorModelsBundle::~DetectorModelsBundle() {
  SharedDtor();
}

void DetectorModelsBundle::SharedDtor() {
  if (bundle_name_ != &::google::protobuf::internal::kEmptyString) {
    delete bundle_name_;
  }
  if (training_dataset_name_ != &::google::protobuf::internal::kEmptyString) {
    delete training_dataset_name_;
  }
  if (this != default_instance_) {
  }
}

void DetectorModelsBundle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DetectorModelsBundle::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DetectorModelsBundle_descriptor_;
}

const DetectorModelsBundle& DetectorModelsBundle::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_detector_5fmodel_2eproto();
  return *default_instance_;
}

DetectorModelsBundle* DetectorModelsBundle::default_instance_ = NULL;

DetectorModelsBundle* DetectorModelsBundle::New() const {
  return new DetectorModelsBundle;
}

void DetectorModelsBundle::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_bundle_name()) {
      if (bundle_name_ != &::google::protobuf::internal::kEmptyString) {
        bundle_name_->clear();
      }
    }
    if (has_training_dataset_name()) {
      if (training_dataset_name_ != &::google::protobuf::internal::kEmptyString) {
        training_dataset_name_->clear();
      }
    }
  }
  detectors_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DetectorModelsBundle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string bundle_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bundle_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->bundle_name().data(), this->bundle_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_training_dataset_name;
        break;
      }

      // required string training_dataset_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_training_dataset_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_training_dataset_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->training_dataset_name().data(), this->training_dataset_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_detectors;
        break;
      }

      // repeated .doppia_protobuf.DetectorModel detectors = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_detectors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_detectors()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_detectors;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DetectorModelsBundle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string bundle_name = 1;
  if (has_bundle_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bundle_name().data(), this->bundle_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->bundle_name(), output);
  }

  // required string training_dataset_name = 2;
  if (has_training_dataset_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->training_dataset_name().data(), this->training_dataset_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->training_dataset_name(), output);
  }

  // repeated .doppia_protobuf.DetectorModel detectors = 3;
  for (int i = 0; i < this->detectors_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->detectors(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DetectorModelsBundle::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string bundle_name = 1;
  if (has_bundle_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bundle_name().data(), this->bundle_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->bundle_name(), target);
  }

  // required string training_dataset_name = 2;
  if (has_training_dataset_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->training_dataset_name().data(), this->training_dataset_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->training_dataset_name(), target);
  }

  // repeated .doppia_protobuf.DetectorModel detectors = 3;
  for (int i = 0; i < this->detectors_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->detectors(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DetectorModelsBundle::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string bundle_name = 1;
    if (has_bundle_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->bundle_name());
    }

    // required string training_dataset_name = 2;
    if (has_training_dataset_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->training_dataset_name());
    }

  }
  // repeated .doppia_protobuf.DetectorModel detectors = 3;
  total_size += 1 * this->detectors_size();
  for (int i = 0; i < this->detectors_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->detectors(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DetectorModelsBundle::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DetectorModelsBundle* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DetectorModelsBundle*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DetectorModelsBundle::MergeFrom(const DetectorModelsBundle& from) {
  GOOGLE_CHECK_NE(&from, this);
  detectors_.MergeFrom(from.detectors_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_bundle_name()) {
      set_bundle_name(from.bundle_name());
    }
    if (from.has_training_dataset_name()) {
      set_training_dataset_name(from.training_dataset_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DetectorModelsBundle::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DetectorModelsBundle::CopyFrom(const DetectorModelsBundle& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetectorModelsBundle::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  for (int i = 0; i < detectors_size(); i++) {
    if (!this->detectors(i).IsInitialized()) return false;
  }
  return true;
}

void DetectorModelsBundle::Swap(DetectorModelsBundle* other) {
  if (other != this) {
    std::swap(bundle_name_, other->bundle_name_);
    std::swap(training_dataset_name_, other->training_dataset_name_);
    detectors_.Swap(&other->detectors_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DetectorModelsBundle::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DetectorModelsBundle_descriptor_;
  metadata.reflection = DetectorModelsBundle_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace doppia_protobuf

// @@protoc_insertion_point(global_scope)
