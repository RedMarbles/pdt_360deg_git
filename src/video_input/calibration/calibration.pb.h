// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: calibration.proto

#ifndef PROTOBUF_calibration_2eproto__INCLUDED
#define PROTOBUF_calibration_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace doppia_protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_calibration_2eproto();
void protobuf_AssignDesc_calibration_2eproto();
void protobuf_ShutdownFile_calibration_2eproto();

class CameraInternalParameters;
class RadialDistortion;
class TangentialDistortion;
class RotationMatrix;
class TranslationVector;
class Pose;
class CameraCalibration;
class StereoCameraCalibration;

// ===================================================================

class CameraInternalParameters : public ::google::protobuf::Message {
 public:
  CameraInternalParameters();
  virtual ~CameraInternalParameters();

  CameraInternalParameters(const CameraInternalParameters& from);

  inline CameraInternalParameters& operator=(const CameraInternalParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraInternalParameters& default_instance();

  void Swap(CameraInternalParameters* other);

  // implements Message ----------------------------------------------

  CameraInternalParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraInternalParameters& from);
  void MergeFrom(const CameraInternalParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float k11 = 1;
  inline bool has_k11() const;
  inline void clear_k11();
  static const int kK11FieldNumber = 1;
  inline float k11() const;
  inline void set_k11(float value);

  // required float k12 = 2;
  inline bool has_k12() const;
  inline void clear_k12();
  static const int kK12FieldNumber = 2;
  inline float k12() const;
  inline void set_k12(float value);

  // required float k13 = 3;
  inline bool has_k13() const;
  inline void clear_k13();
  static const int kK13FieldNumber = 3;
  inline float k13() const;
  inline void set_k13(float value);

  // required float k21 = 4;
  inline bool has_k21() const;
  inline void clear_k21();
  static const int kK21FieldNumber = 4;
  inline float k21() const;
  inline void set_k21(float value);

  // required float k22 = 5;
  inline bool has_k22() const;
  inline void clear_k22();
  static const int kK22FieldNumber = 5;
  inline float k22() const;
  inline void set_k22(float value);

  // required float k23 = 6;
  inline bool has_k23() const;
  inline void clear_k23();
  static const int kK23FieldNumber = 6;
  inline float k23() const;
  inline void set_k23(float value);

  // required float k31 = 7;
  inline bool has_k31() const;
  inline void clear_k31();
  static const int kK31FieldNumber = 7;
  inline float k31() const;
  inline void set_k31(float value);

  // required float k32 = 8;
  inline bool has_k32() const;
  inline void clear_k32();
  static const int kK32FieldNumber = 8;
  inline float k32() const;
  inline void set_k32(float value);

  // required float k33 = 9;
  inline bool has_k33() const;
  inline void clear_k33();
  static const int kK33FieldNumber = 9;
  inline float k33() const;
  inline void set_k33(float value);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.CameraInternalParameters)
 private:
  inline void set_has_k11();
  inline void clear_has_k11();
  inline void set_has_k12();
  inline void clear_has_k12();
  inline void set_has_k13();
  inline void clear_has_k13();
  inline void set_has_k21();
  inline void clear_has_k21();
  inline void set_has_k22();
  inline void clear_has_k22();
  inline void set_has_k23();
  inline void clear_has_k23();
  inline void set_has_k31();
  inline void clear_has_k31();
  inline void set_has_k32();
  inline void clear_has_k32();
  inline void set_has_k33();
  inline void clear_has_k33();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float k11_;
  float k12_;
  float k13_;
  float k21_;
  float k22_;
  float k23_;
  float k31_;
  float k32_;
  float k33_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_calibration_2eproto();
  friend void protobuf_AssignDesc_calibration_2eproto();
  friend void protobuf_ShutdownFile_calibration_2eproto();

  void InitAsDefaultInstance();
  static CameraInternalParameters* default_instance_;
};
// -------------------------------------------------------------------

class RadialDistortion : public ::google::protobuf::Message {
 public:
  RadialDistortion();
  virtual ~RadialDistortion();

  RadialDistortion(const RadialDistortion& from);

  inline RadialDistortion& operator=(const RadialDistortion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RadialDistortion& default_instance();

  void Swap(RadialDistortion* other);

  // implements Message ----------------------------------------------

  RadialDistortion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RadialDistortion& from);
  void MergeFrom(const RadialDistortion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float k1 = 1;
  inline bool has_k1() const;
  inline void clear_k1();
  static const int kK1FieldNumber = 1;
  inline float k1() const;
  inline void set_k1(float value);

  // optional float k2 = 2;
  inline bool has_k2() const;
  inline void clear_k2();
  static const int kK2FieldNumber = 2;
  inline float k2() const;
  inline void set_k2(float value);

  // optional float k3 = 3;
  inline bool has_k3() const;
  inline void clear_k3();
  static const int kK3FieldNumber = 3;
  inline float k3() const;
  inline void set_k3(float value);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.RadialDistortion)
 private:
  inline void set_has_k1();
  inline void clear_has_k1();
  inline void set_has_k2();
  inline void clear_has_k2();
  inline void set_has_k3();
  inline void clear_has_k3();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float k1_;
  float k2_;
  float k3_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_calibration_2eproto();
  friend void protobuf_AssignDesc_calibration_2eproto();
  friend void protobuf_ShutdownFile_calibration_2eproto();

  void InitAsDefaultInstance();
  static RadialDistortion* default_instance_;
};
// -------------------------------------------------------------------

class TangentialDistortion : public ::google::protobuf::Message {
 public:
  TangentialDistortion();
  virtual ~TangentialDistortion();

  TangentialDistortion(const TangentialDistortion& from);

  inline TangentialDistortion& operator=(const TangentialDistortion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TangentialDistortion& default_instance();

  void Swap(TangentialDistortion* other);

  // implements Message ----------------------------------------------

  TangentialDistortion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TangentialDistortion& from);
  void MergeFrom(const TangentialDistortion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float k1 = 1;
  inline bool has_k1() const;
  inline void clear_k1();
  static const int kK1FieldNumber = 1;
  inline float k1() const;
  inline void set_k1(float value);

  // required float k2 = 2;
  inline bool has_k2() const;
  inline void clear_k2();
  static const int kK2FieldNumber = 2;
  inline float k2() const;
  inline void set_k2(float value);

  // optional float k3 = 3;
  inline bool has_k3() const;
  inline void clear_k3();
  static const int kK3FieldNumber = 3;
  inline float k3() const;
  inline void set_k3(float value);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.TangentialDistortion)
 private:
  inline void set_has_k1();
  inline void clear_has_k1();
  inline void set_has_k2();
  inline void clear_has_k2();
  inline void set_has_k3();
  inline void clear_has_k3();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float k1_;
  float k2_;
  float k3_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_calibration_2eproto();
  friend void protobuf_AssignDesc_calibration_2eproto();
  friend void protobuf_ShutdownFile_calibration_2eproto();

  void InitAsDefaultInstance();
  static TangentialDistortion* default_instance_;
};
// -------------------------------------------------------------------

class RotationMatrix : public ::google::protobuf::Message {
 public:
  RotationMatrix();
  virtual ~RotationMatrix();

  RotationMatrix(const RotationMatrix& from);

  inline RotationMatrix& operator=(const RotationMatrix& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RotationMatrix& default_instance();

  void Swap(RotationMatrix* other);

  // implements Message ----------------------------------------------

  RotationMatrix* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RotationMatrix& from);
  void MergeFrom(const RotationMatrix& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float r11 = 1;
  inline bool has_r11() const;
  inline void clear_r11();
  static const int kR11FieldNumber = 1;
  inline float r11() const;
  inline void set_r11(float value);

  // required float r12 = 2;
  inline bool has_r12() const;
  inline void clear_r12();
  static const int kR12FieldNumber = 2;
  inline float r12() const;
  inline void set_r12(float value);

  // required float r13 = 3;
  inline bool has_r13() const;
  inline void clear_r13();
  static const int kR13FieldNumber = 3;
  inline float r13() const;
  inline void set_r13(float value);

  // required float r21 = 4;
  inline bool has_r21() const;
  inline void clear_r21();
  static const int kR21FieldNumber = 4;
  inline float r21() const;
  inline void set_r21(float value);

  // required float r22 = 5;
  inline bool has_r22() const;
  inline void clear_r22();
  static const int kR22FieldNumber = 5;
  inline float r22() const;
  inline void set_r22(float value);

  // required float r23 = 6;
  inline bool has_r23() const;
  inline void clear_r23();
  static const int kR23FieldNumber = 6;
  inline float r23() const;
  inline void set_r23(float value);

  // required float r31 = 7;
  inline bool has_r31() const;
  inline void clear_r31();
  static const int kR31FieldNumber = 7;
  inline float r31() const;
  inline void set_r31(float value);

  // required float r32 = 8;
  inline bool has_r32() const;
  inline void clear_r32();
  static const int kR32FieldNumber = 8;
  inline float r32() const;
  inline void set_r32(float value);

  // required float r33 = 9;
  inline bool has_r33() const;
  inline void clear_r33();
  static const int kR33FieldNumber = 9;
  inline float r33() const;
  inline void set_r33(float value);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.RotationMatrix)
 private:
  inline void set_has_r11();
  inline void clear_has_r11();
  inline void set_has_r12();
  inline void clear_has_r12();
  inline void set_has_r13();
  inline void clear_has_r13();
  inline void set_has_r21();
  inline void clear_has_r21();
  inline void set_has_r22();
  inline void clear_has_r22();
  inline void set_has_r23();
  inline void clear_has_r23();
  inline void set_has_r31();
  inline void clear_has_r31();
  inline void set_has_r32();
  inline void clear_has_r32();
  inline void set_has_r33();
  inline void clear_has_r33();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float r11_;
  float r12_;
  float r13_;
  float r21_;
  float r22_;
  float r23_;
  float r31_;
  float r32_;
  float r33_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_calibration_2eproto();
  friend void protobuf_AssignDesc_calibration_2eproto();
  friend void protobuf_ShutdownFile_calibration_2eproto();

  void InitAsDefaultInstance();
  static RotationMatrix* default_instance_;
};
// -------------------------------------------------------------------

class TranslationVector : public ::google::protobuf::Message {
 public:
  TranslationVector();
  virtual ~TranslationVector();

  TranslationVector(const TranslationVector& from);

  inline TranslationVector& operator=(const TranslationVector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TranslationVector& default_instance();

  void Swap(TranslationVector* other);

  // implements Message ----------------------------------------------

  TranslationVector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TranslationVector& from);
  void MergeFrom(const TranslationVector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float t1 = 1;
  inline bool has_t1() const;
  inline void clear_t1();
  static const int kT1FieldNumber = 1;
  inline float t1() const;
  inline void set_t1(float value);

  // required float t2 = 2;
  inline bool has_t2() const;
  inline void clear_t2();
  static const int kT2FieldNumber = 2;
  inline float t2() const;
  inline void set_t2(float value);

  // required float t3 = 3;
  inline bool has_t3() const;
  inline void clear_t3();
  static const int kT3FieldNumber = 3;
  inline float t3() const;
  inline void set_t3(float value);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.TranslationVector)
 private:
  inline void set_has_t1();
  inline void clear_has_t1();
  inline void set_has_t2();
  inline void clear_has_t2();
  inline void set_has_t3();
  inline void clear_has_t3();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float t1_;
  float t2_;
  float t3_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_calibration_2eproto();
  friend void protobuf_AssignDesc_calibration_2eproto();
  friend void protobuf_ShutdownFile_calibration_2eproto();

  void InitAsDefaultInstance();
  static TranslationVector* default_instance_;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  void Swap(Pose* other);

  // implements Message ----------------------------------------------

  Pose* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .doppia_protobuf.RotationMatrix rotation = 1;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 1;
  inline const ::doppia_protobuf::RotationMatrix& rotation() const;
  inline ::doppia_protobuf::RotationMatrix* mutable_rotation();
  inline ::doppia_protobuf::RotationMatrix* release_rotation();
  inline void set_allocated_rotation(::doppia_protobuf::RotationMatrix* rotation);

  // required .doppia_protobuf.TranslationVector translation = 2;
  inline bool has_translation() const;
  inline void clear_translation();
  static const int kTranslationFieldNumber = 2;
  inline const ::doppia_protobuf::TranslationVector& translation() const;
  inline ::doppia_protobuf::TranslationVector* mutable_translation();
  inline ::doppia_protobuf::TranslationVector* release_translation();
  inline void set_allocated_translation(::doppia_protobuf::TranslationVector* translation);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.Pose)
 private:
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_translation();
  inline void clear_has_translation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::doppia_protobuf::RotationMatrix* rotation_;
  ::doppia_protobuf::TranslationVector* translation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_calibration_2eproto();
  friend void protobuf_AssignDesc_calibration_2eproto();
  friend void protobuf_ShutdownFile_calibration_2eproto();

  void InitAsDefaultInstance();
  static Pose* default_instance_;
};
// -------------------------------------------------------------------

class CameraCalibration : public ::google::protobuf::Message {
 public:
  CameraCalibration();
  virtual ~CameraCalibration();

  CameraCalibration(const CameraCalibration& from);

  inline CameraCalibration& operator=(const CameraCalibration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraCalibration& default_instance();

  void Swap(CameraCalibration* other);

  // implements Message ----------------------------------------------

  CameraCalibration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraCalibration& from);
  void MergeFrom(const CameraCalibration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .doppia_protobuf.CameraInternalParameters internal_parameters = 2;
  inline bool has_internal_parameters() const;
  inline void clear_internal_parameters();
  static const int kInternalParametersFieldNumber = 2;
  inline const ::doppia_protobuf::CameraInternalParameters& internal_parameters() const;
  inline ::doppia_protobuf::CameraInternalParameters* mutable_internal_parameters();
  inline ::doppia_protobuf::CameraInternalParameters* release_internal_parameters();
  inline void set_allocated_internal_parameters(::doppia_protobuf::CameraInternalParameters* internal_parameters);

  // optional .doppia_protobuf.RadialDistortion radial_distortion = 3;
  inline bool has_radial_distortion() const;
  inline void clear_radial_distortion();
  static const int kRadialDistortionFieldNumber = 3;
  inline const ::doppia_protobuf::RadialDistortion& radial_distortion() const;
  inline ::doppia_protobuf::RadialDistortion* mutable_radial_distortion();
  inline ::doppia_protobuf::RadialDistortion* release_radial_distortion();
  inline void set_allocated_radial_distortion(::doppia_protobuf::RadialDistortion* radial_distortion);

  // optional .doppia_protobuf.TangentialDistortion tangential_distortion = 4;
  inline bool has_tangential_distortion() const;
  inline void clear_tangential_distortion();
  static const int kTangentialDistortionFieldNumber = 4;
  inline const ::doppia_protobuf::TangentialDistortion& tangential_distortion() const;
  inline ::doppia_protobuf::TangentialDistortion* mutable_tangential_distortion();
  inline ::doppia_protobuf::TangentialDistortion* release_tangential_distortion();
  inline void set_allocated_tangential_distortion(::doppia_protobuf::TangentialDistortion* tangential_distortion);

  // optional .doppia_protobuf.Pose pose = 5;
  inline bool has_pose() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 5;
  inline const ::doppia_protobuf::Pose& pose() const;
  inline ::doppia_protobuf::Pose* mutable_pose();
  inline ::doppia_protobuf::Pose* release_pose();
  inline void set_allocated_pose(::doppia_protobuf::Pose* pose);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.CameraCalibration)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_internal_parameters();
  inline void clear_has_internal_parameters();
  inline void set_has_radial_distortion();
  inline void clear_has_radial_distortion();
  inline void set_has_tangential_distortion();
  inline void clear_has_tangential_distortion();
  inline void set_has_pose();
  inline void clear_has_pose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::doppia_protobuf::CameraInternalParameters* internal_parameters_;
  ::doppia_protobuf::RadialDistortion* radial_distortion_;
  ::doppia_protobuf::TangentialDistortion* tangential_distortion_;
  ::doppia_protobuf::Pose* pose_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_calibration_2eproto();
  friend void protobuf_AssignDesc_calibration_2eproto();
  friend void protobuf_ShutdownFile_calibration_2eproto();

  void InitAsDefaultInstance();
  static CameraCalibration* default_instance_;
};
// -------------------------------------------------------------------

class StereoCameraCalibration : public ::google::protobuf::Message {
 public:
  StereoCameraCalibration();
  virtual ~StereoCameraCalibration();

  StereoCameraCalibration(const StereoCameraCalibration& from);

  inline StereoCameraCalibration& operator=(const StereoCameraCalibration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StereoCameraCalibration& default_instance();

  void Swap(StereoCameraCalibration* other);

  // implements Message ----------------------------------------------

  StereoCameraCalibration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StereoCameraCalibration& from);
  void MergeFrom(const StereoCameraCalibration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .doppia_protobuf.CameraCalibration left_camera = 2;
  inline bool has_left_camera() const;
  inline void clear_left_camera();
  static const int kLeftCameraFieldNumber = 2;
  inline const ::doppia_protobuf::CameraCalibration& left_camera() const;
  inline ::doppia_protobuf::CameraCalibration* mutable_left_camera();
  inline ::doppia_protobuf::CameraCalibration* release_left_camera();
  inline void set_allocated_left_camera(::doppia_protobuf::CameraCalibration* left_camera);

  // required .doppia_protobuf.CameraCalibration right_camera = 3;
  inline bool has_right_camera() const;
  inline void clear_right_camera();
  static const int kRightCameraFieldNumber = 3;
  inline const ::doppia_protobuf::CameraCalibration& right_camera() const;
  inline ::doppia_protobuf::CameraCalibration* mutable_right_camera();
  inline ::doppia_protobuf::CameraCalibration* release_right_camera();
  inline void set_allocated_right_camera(::doppia_protobuf::CameraCalibration* right_camera);

  // @@protoc_insertion_point(class_scope:doppia_protobuf.StereoCameraCalibration)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_left_camera();
  inline void clear_has_left_camera();
  inline void set_has_right_camera();
  inline void clear_has_right_camera();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::doppia_protobuf::CameraCalibration* left_camera_;
  ::doppia_protobuf::CameraCalibration* right_camera_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_calibration_2eproto();
  friend void protobuf_AssignDesc_calibration_2eproto();
  friend void protobuf_ShutdownFile_calibration_2eproto();

  void InitAsDefaultInstance();
  static StereoCameraCalibration* default_instance_;
};
// ===================================================================


// ===================================================================

// CameraInternalParameters

// required float k11 = 1;
inline bool CameraInternalParameters::has_k11() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraInternalParameters::set_has_k11() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraInternalParameters::clear_has_k11() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraInternalParameters::clear_k11() {
  k11_ = 0;
  clear_has_k11();
}
inline float CameraInternalParameters::k11() const {
  return k11_;
}
inline void CameraInternalParameters::set_k11(float value) {
  set_has_k11();
  k11_ = value;
}

// required float k12 = 2;
inline bool CameraInternalParameters::has_k12() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraInternalParameters::set_has_k12() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraInternalParameters::clear_has_k12() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraInternalParameters::clear_k12() {
  k12_ = 0;
  clear_has_k12();
}
inline float CameraInternalParameters::k12() const {
  return k12_;
}
inline void CameraInternalParameters::set_k12(float value) {
  set_has_k12();
  k12_ = value;
}

// required float k13 = 3;
inline bool CameraInternalParameters::has_k13() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraInternalParameters::set_has_k13() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraInternalParameters::clear_has_k13() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraInternalParameters::clear_k13() {
  k13_ = 0;
  clear_has_k13();
}
inline float CameraInternalParameters::k13() const {
  return k13_;
}
inline void CameraInternalParameters::set_k13(float value) {
  set_has_k13();
  k13_ = value;
}

// required float k21 = 4;
inline bool CameraInternalParameters::has_k21() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraInternalParameters::set_has_k21() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraInternalParameters::clear_has_k21() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraInternalParameters::clear_k21() {
  k21_ = 0;
  clear_has_k21();
}
inline float CameraInternalParameters::k21() const {
  return k21_;
}
inline void CameraInternalParameters::set_k21(float value) {
  set_has_k21();
  k21_ = value;
}

// required float k22 = 5;
inline bool CameraInternalParameters::has_k22() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CameraInternalParameters::set_has_k22() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CameraInternalParameters::clear_has_k22() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CameraInternalParameters::clear_k22() {
  k22_ = 0;
  clear_has_k22();
}
inline float CameraInternalParameters::k22() const {
  return k22_;
}
inline void CameraInternalParameters::set_k22(float value) {
  set_has_k22();
  k22_ = value;
}

// required float k23 = 6;
inline bool CameraInternalParameters::has_k23() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CameraInternalParameters::set_has_k23() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CameraInternalParameters::clear_has_k23() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CameraInternalParameters::clear_k23() {
  k23_ = 0;
  clear_has_k23();
}
inline float CameraInternalParameters::k23() const {
  return k23_;
}
inline void CameraInternalParameters::set_k23(float value) {
  set_has_k23();
  k23_ = value;
}

// required float k31 = 7;
inline bool CameraInternalParameters::has_k31() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CameraInternalParameters::set_has_k31() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CameraInternalParameters::clear_has_k31() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CameraInternalParameters::clear_k31() {
  k31_ = 0;
  clear_has_k31();
}
inline float CameraInternalParameters::k31() const {
  return k31_;
}
inline void CameraInternalParameters::set_k31(float value) {
  set_has_k31();
  k31_ = value;
}

// required float k32 = 8;
inline bool CameraInternalParameters::has_k32() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CameraInternalParameters::set_has_k32() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CameraInternalParameters::clear_has_k32() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CameraInternalParameters::clear_k32() {
  k32_ = 0;
  clear_has_k32();
}
inline float CameraInternalParameters::k32() const {
  return k32_;
}
inline void CameraInternalParameters::set_k32(float value) {
  set_has_k32();
  k32_ = value;
}

// required float k33 = 9;
inline bool CameraInternalParameters::has_k33() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CameraInternalParameters::set_has_k33() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CameraInternalParameters::clear_has_k33() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CameraInternalParameters::clear_k33() {
  k33_ = 0;
  clear_has_k33();
}
inline float CameraInternalParameters::k33() const {
  return k33_;
}
inline void CameraInternalParameters::set_k33(float value) {
  set_has_k33();
  k33_ = value;
}

// -------------------------------------------------------------------

// RadialDistortion

// required float k1 = 1;
inline bool RadialDistortion::has_k1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RadialDistortion::set_has_k1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RadialDistortion::clear_has_k1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RadialDistortion::clear_k1() {
  k1_ = 0;
  clear_has_k1();
}
inline float RadialDistortion::k1() const {
  return k1_;
}
inline void RadialDistortion::set_k1(float value) {
  set_has_k1();
  k1_ = value;
}

// optional float k2 = 2;
inline bool RadialDistortion::has_k2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RadialDistortion::set_has_k2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RadialDistortion::clear_has_k2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RadialDistortion::clear_k2() {
  k2_ = 0;
  clear_has_k2();
}
inline float RadialDistortion::k2() const {
  return k2_;
}
inline void RadialDistortion::set_k2(float value) {
  set_has_k2();
  k2_ = value;
}

// optional float k3 = 3;
inline bool RadialDistortion::has_k3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RadialDistortion::set_has_k3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RadialDistortion::clear_has_k3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RadialDistortion::clear_k3() {
  k3_ = 0;
  clear_has_k3();
}
inline float RadialDistortion::k3() const {
  return k3_;
}
inline void RadialDistortion::set_k3(float value) {
  set_has_k3();
  k3_ = value;
}

// -------------------------------------------------------------------

// TangentialDistortion

// required float k1 = 1;
inline bool TangentialDistortion::has_k1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TangentialDistortion::set_has_k1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TangentialDistortion::clear_has_k1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TangentialDistortion::clear_k1() {
  k1_ = 0;
  clear_has_k1();
}
inline float TangentialDistortion::k1() const {
  return k1_;
}
inline void TangentialDistortion::set_k1(float value) {
  set_has_k1();
  k1_ = value;
}

// required float k2 = 2;
inline bool TangentialDistortion::has_k2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TangentialDistortion::set_has_k2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TangentialDistortion::clear_has_k2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TangentialDistortion::clear_k2() {
  k2_ = 0;
  clear_has_k2();
}
inline float TangentialDistortion::k2() const {
  return k2_;
}
inline void TangentialDistortion::set_k2(float value) {
  set_has_k2();
  k2_ = value;
}

// optional float k3 = 3;
inline bool TangentialDistortion::has_k3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TangentialDistortion::set_has_k3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TangentialDistortion::clear_has_k3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TangentialDistortion::clear_k3() {
  k3_ = 0;
  clear_has_k3();
}
inline float TangentialDistortion::k3() const {
  return k3_;
}
inline void TangentialDistortion::set_k3(float value) {
  set_has_k3();
  k3_ = value;
}

// -------------------------------------------------------------------

// RotationMatrix

// required float r11 = 1;
inline bool RotationMatrix::has_r11() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RotationMatrix::set_has_r11() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RotationMatrix::clear_has_r11() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RotationMatrix::clear_r11() {
  r11_ = 0;
  clear_has_r11();
}
inline float RotationMatrix::r11() const {
  return r11_;
}
inline void RotationMatrix::set_r11(float value) {
  set_has_r11();
  r11_ = value;
}

// required float r12 = 2;
inline bool RotationMatrix::has_r12() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RotationMatrix::set_has_r12() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RotationMatrix::clear_has_r12() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RotationMatrix::clear_r12() {
  r12_ = 0;
  clear_has_r12();
}
inline float RotationMatrix::r12() const {
  return r12_;
}
inline void RotationMatrix::set_r12(float value) {
  set_has_r12();
  r12_ = value;
}

// required float r13 = 3;
inline bool RotationMatrix::has_r13() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RotationMatrix::set_has_r13() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RotationMatrix::clear_has_r13() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RotationMatrix::clear_r13() {
  r13_ = 0;
  clear_has_r13();
}
inline float RotationMatrix::r13() const {
  return r13_;
}
inline void RotationMatrix::set_r13(float value) {
  set_has_r13();
  r13_ = value;
}

// required float r21 = 4;
inline bool RotationMatrix::has_r21() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RotationMatrix::set_has_r21() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RotationMatrix::clear_has_r21() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RotationMatrix::clear_r21() {
  r21_ = 0;
  clear_has_r21();
}
inline float RotationMatrix::r21() const {
  return r21_;
}
inline void RotationMatrix::set_r21(float value) {
  set_has_r21();
  r21_ = value;
}

// required float r22 = 5;
inline bool RotationMatrix::has_r22() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RotationMatrix::set_has_r22() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RotationMatrix::clear_has_r22() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RotationMatrix::clear_r22() {
  r22_ = 0;
  clear_has_r22();
}
inline float RotationMatrix::r22() const {
  return r22_;
}
inline void RotationMatrix::set_r22(float value) {
  set_has_r22();
  r22_ = value;
}

// required float r23 = 6;
inline bool RotationMatrix::has_r23() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RotationMatrix::set_has_r23() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RotationMatrix::clear_has_r23() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RotationMatrix::clear_r23() {
  r23_ = 0;
  clear_has_r23();
}
inline float RotationMatrix::r23() const {
  return r23_;
}
inline void RotationMatrix::set_r23(float value) {
  set_has_r23();
  r23_ = value;
}

// required float r31 = 7;
inline bool RotationMatrix::has_r31() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RotationMatrix::set_has_r31() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RotationMatrix::clear_has_r31() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RotationMatrix::clear_r31() {
  r31_ = 0;
  clear_has_r31();
}
inline float RotationMatrix::r31() const {
  return r31_;
}
inline void RotationMatrix::set_r31(float value) {
  set_has_r31();
  r31_ = value;
}

// required float r32 = 8;
inline bool RotationMatrix::has_r32() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RotationMatrix::set_has_r32() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RotationMatrix::clear_has_r32() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RotationMatrix::clear_r32() {
  r32_ = 0;
  clear_has_r32();
}
inline float RotationMatrix::r32() const {
  return r32_;
}
inline void RotationMatrix::set_r32(float value) {
  set_has_r32();
  r32_ = value;
}

// required float r33 = 9;
inline bool RotationMatrix::has_r33() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RotationMatrix::set_has_r33() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RotationMatrix::clear_has_r33() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RotationMatrix::clear_r33() {
  r33_ = 0;
  clear_has_r33();
}
inline float RotationMatrix::r33() const {
  return r33_;
}
inline void RotationMatrix::set_r33(float value) {
  set_has_r33();
  r33_ = value;
}

// -------------------------------------------------------------------

// TranslationVector

// required float t1 = 1;
inline bool TranslationVector::has_t1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TranslationVector::set_has_t1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TranslationVector::clear_has_t1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TranslationVector::clear_t1() {
  t1_ = 0;
  clear_has_t1();
}
inline float TranslationVector::t1() const {
  return t1_;
}
inline void TranslationVector::set_t1(float value) {
  set_has_t1();
  t1_ = value;
}

// required float t2 = 2;
inline bool TranslationVector::has_t2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TranslationVector::set_has_t2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TranslationVector::clear_has_t2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TranslationVector::clear_t2() {
  t2_ = 0;
  clear_has_t2();
}
inline float TranslationVector::t2() const {
  return t2_;
}
inline void TranslationVector::set_t2(float value) {
  set_has_t2();
  t2_ = value;
}

// required float t3 = 3;
inline bool TranslationVector::has_t3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TranslationVector::set_has_t3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TranslationVector::clear_has_t3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TranslationVector::clear_t3() {
  t3_ = 0;
  clear_has_t3();
}
inline float TranslationVector::t3() const {
  return t3_;
}
inline void TranslationVector::set_t3(float value) {
  set_has_t3();
  t3_ = value;
}

// -------------------------------------------------------------------

// Pose

// required .doppia_protobuf.RotationMatrix rotation = 1;
inline bool Pose::has_rotation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pose::set_has_rotation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pose::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pose::clear_rotation() {
  if (rotation_ != NULL) rotation_->::doppia_protobuf::RotationMatrix::Clear();
  clear_has_rotation();
}
inline const ::doppia_protobuf::RotationMatrix& Pose::rotation() const {
  return rotation_ != NULL ? *rotation_ : *default_instance_->rotation_;
}
inline ::doppia_protobuf::RotationMatrix* Pose::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) rotation_ = new ::doppia_protobuf::RotationMatrix;
  return rotation_;
}
inline ::doppia_protobuf::RotationMatrix* Pose::release_rotation() {
  clear_has_rotation();
  ::doppia_protobuf::RotationMatrix* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void Pose::set_allocated_rotation(::doppia_protobuf::RotationMatrix* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
}

// required .doppia_protobuf.TranslationVector translation = 2;
inline bool Pose::has_translation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pose::set_has_translation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pose::clear_has_translation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pose::clear_translation() {
  if (translation_ != NULL) translation_->::doppia_protobuf::TranslationVector::Clear();
  clear_has_translation();
}
inline const ::doppia_protobuf::TranslationVector& Pose::translation() const {
  return translation_ != NULL ? *translation_ : *default_instance_->translation_;
}
inline ::doppia_protobuf::TranslationVector* Pose::mutable_translation() {
  set_has_translation();
  if (translation_ == NULL) translation_ = new ::doppia_protobuf::TranslationVector;
  return translation_;
}
inline ::doppia_protobuf::TranslationVector* Pose::release_translation() {
  clear_has_translation();
  ::doppia_protobuf::TranslationVector* temp = translation_;
  translation_ = NULL;
  return temp;
}
inline void Pose::set_allocated_translation(::doppia_protobuf::TranslationVector* translation) {
  delete translation_;
  translation_ = translation;
  if (translation) {
    set_has_translation();
  } else {
    clear_has_translation();
  }
}

// -------------------------------------------------------------------

// CameraCalibration

// optional string name = 1;
inline bool CameraCalibration::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraCalibration::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraCalibration::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraCalibration::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CameraCalibration::name() const {
  return *name_;
}
inline void CameraCalibration::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CameraCalibration::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CameraCalibration::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CameraCalibration::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CameraCalibration::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CameraCalibration::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .doppia_protobuf.CameraInternalParameters internal_parameters = 2;
inline bool CameraCalibration::has_internal_parameters() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraCalibration::set_has_internal_parameters() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraCalibration::clear_has_internal_parameters() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraCalibration::clear_internal_parameters() {
  if (internal_parameters_ != NULL) internal_parameters_->::doppia_protobuf::CameraInternalParameters::Clear();
  clear_has_internal_parameters();
}
inline const ::doppia_protobuf::CameraInternalParameters& CameraCalibration::internal_parameters() const {
  return internal_parameters_ != NULL ? *internal_parameters_ : *default_instance_->internal_parameters_;
}
inline ::doppia_protobuf::CameraInternalParameters* CameraCalibration::mutable_internal_parameters() {
  set_has_internal_parameters();
  if (internal_parameters_ == NULL) internal_parameters_ = new ::doppia_protobuf::CameraInternalParameters;
  return internal_parameters_;
}
inline ::doppia_protobuf::CameraInternalParameters* CameraCalibration::release_internal_parameters() {
  clear_has_internal_parameters();
  ::doppia_protobuf::CameraInternalParameters* temp = internal_parameters_;
  internal_parameters_ = NULL;
  return temp;
}
inline void CameraCalibration::set_allocated_internal_parameters(::doppia_protobuf::CameraInternalParameters* internal_parameters) {
  delete internal_parameters_;
  internal_parameters_ = internal_parameters;
  if (internal_parameters) {
    set_has_internal_parameters();
  } else {
    clear_has_internal_parameters();
  }
}

// optional .doppia_protobuf.RadialDistortion radial_distortion = 3;
inline bool CameraCalibration::has_radial_distortion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraCalibration::set_has_radial_distortion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraCalibration::clear_has_radial_distortion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraCalibration::clear_radial_distortion() {
  if (radial_distortion_ != NULL) radial_distortion_->::doppia_protobuf::RadialDistortion::Clear();
  clear_has_radial_distortion();
}
inline const ::doppia_protobuf::RadialDistortion& CameraCalibration::radial_distortion() const {
  return radial_distortion_ != NULL ? *radial_distortion_ : *default_instance_->radial_distortion_;
}
inline ::doppia_protobuf::RadialDistortion* CameraCalibration::mutable_radial_distortion() {
  set_has_radial_distortion();
  if (radial_distortion_ == NULL) radial_distortion_ = new ::doppia_protobuf::RadialDistortion;
  return radial_distortion_;
}
inline ::doppia_protobuf::RadialDistortion* CameraCalibration::release_radial_distortion() {
  clear_has_radial_distortion();
  ::doppia_protobuf::RadialDistortion* temp = radial_distortion_;
  radial_distortion_ = NULL;
  return temp;
}
inline void CameraCalibration::set_allocated_radial_distortion(::doppia_protobuf::RadialDistortion* radial_distortion) {
  delete radial_distortion_;
  radial_distortion_ = radial_distortion;
  if (radial_distortion) {
    set_has_radial_distortion();
  } else {
    clear_has_radial_distortion();
  }
}

// optional .doppia_protobuf.TangentialDistortion tangential_distortion = 4;
inline bool CameraCalibration::has_tangential_distortion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraCalibration::set_has_tangential_distortion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraCalibration::clear_has_tangential_distortion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraCalibration::clear_tangential_distortion() {
  if (tangential_distortion_ != NULL) tangential_distortion_->::doppia_protobuf::TangentialDistortion::Clear();
  clear_has_tangential_distortion();
}
inline const ::doppia_protobuf::TangentialDistortion& CameraCalibration::tangential_distortion() const {
  return tangential_distortion_ != NULL ? *tangential_distortion_ : *default_instance_->tangential_distortion_;
}
inline ::doppia_protobuf::TangentialDistortion* CameraCalibration::mutable_tangential_distortion() {
  set_has_tangential_distortion();
  if (tangential_distortion_ == NULL) tangential_distortion_ = new ::doppia_protobuf::TangentialDistortion;
  return tangential_distortion_;
}
inline ::doppia_protobuf::TangentialDistortion* CameraCalibration::release_tangential_distortion() {
  clear_has_tangential_distortion();
  ::doppia_protobuf::TangentialDistortion* temp = tangential_distortion_;
  tangential_distortion_ = NULL;
  return temp;
}
inline void CameraCalibration::set_allocated_tangential_distortion(::doppia_protobuf::TangentialDistortion* tangential_distortion) {
  delete tangential_distortion_;
  tangential_distortion_ = tangential_distortion;
  if (tangential_distortion) {
    set_has_tangential_distortion();
  } else {
    clear_has_tangential_distortion();
  }
}

// optional .doppia_protobuf.Pose pose = 5;
inline bool CameraCalibration::has_pose() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CameraCalibration::set_has_pose() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CameraCalibration::clear_has_pose() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CameraCalibration::clear_pose() {
  if (pose_ != NULL) pose_->::doppia_protobuf::Pose::Clear();
  clear_has_pose();
}
inline const ::doppia_protobuf::Pose& CameraCalibration::pose() const {
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::doppia_protobuf::Pose* CameraCalibration::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) pose_ = new ::doppia_protobuf::Pose;
  return pose_;
}
inline ::doppia_protobuf::Pose* CameraCalibration::release_pose() {
  clear_has_pose();
  ::doppia_protobuf::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void CameraCalibration::set_allocated_pose(::doppia_protobuf::Pose* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
}

// -------------------------------------------------------------------

// StereoCameraCalibration

// optional string name = 1;
inline bool StereoCameraCalibration::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StereoCameraCalibration::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StereoCameraCalibration::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StereoCameraCalibration::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StereoCameraCalibration::name() const {
  return *name_;
}
inline void StereoCameraCalibration::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StereoCameraCalibration::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StereoCameraCalibration::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StereoCameraCalibration::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* StereoCameraCalibration::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StereoCameraCalibration::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .doppia_protobuf.CameraCalibration left_camera = 2;
inline bool StereoCameraCalibration::has_left_camera() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StereoCameraCalibration::set_has_left_camera() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StereoCameraCalibration::clear_has_left_camera() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StereoCameraCalibration::clear_left_camera() {
  if (left_camera_ != NULL) left_camera_->::doppia_protobuf::CameraCalibration::Clear();
  clear_has_left_camera();
}
inline const ::doppia_protobuf::CameraCalibration& StereoCameraCalibration::left_camera() const {
  return left_camera_ != NULL ? *left_camera_ : *default_instance_->left_camera_;
}
inline ::doppia_protobuf::CameraCalibration* StereoCameraCalibration::mutable_left_camera() {
  set_has_left_camera();
  if (left_camera_ == NULL) left_camera_ = new ::doppia_protobuf::CameraCalibration;
  return left_camera_;
}
inline ::doppia_protobuf::CameraCalibration* StereoCameraCalibration::release_left_camera() {
  clear_has_left_camera();
  ::doppia_protobuf::CameraCalibration* temp = left_camera_;
  left_camera_ = NULL;
  return temp;
}
inline void StereoCameraCalibration::set_allocated_left_camera(::doppia_protobuf::CameraCalibration* left_camera) {
  delete left_camera_;
  left_camera_ = left_camera;
  if (left_camera) {
    set_has_left_camera();
  } else {
    clear_has_left_camera();
  }
}

// required .doppia_protobuf.CameraCalibration right_camera = 3;
inline bool StereoCameraCalibration::has_right_camera() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StereoCameraCalibration::set_has_right_camera() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StereoCameraCalibration::clear_has_right_camera() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StereoCameraCalibration::clear_right_camera() {
  if (right_camera_ != NULL) right_camera_->::doppia_protobuf::CameraCalibration::Clear();
  clear_has_right_camera();
}
inline const ::doppia_protobuf::CameraCalibration& StereoCameraCalibration::right_camera() const {
  return right_camera_ != NULL ? *right_camera_ : *default_instance_->right_camera_;
}
inline ::doppia_protobuf::CameraCalibration* StereoCameraCalibration::mutable_right_camera() {
  set_has_right_camera();
  if (right_camera_ == NULL) right_camera_ = new ::doppia_protobuf::CameraCalibration;
  return right_camera_;
}
inline ::doppia_protobuf::CameraCalibration* StereoCameraCalibration::release_right_camera() {
  clear_has_right_camera();
  ::doppia_protobuf::CameraCalibration* temp = right_camera_;
  right_camera_ = NULL;
  return temp;
}
inline void StereoCameraCalibration::set_allocated_right_camera(::doppia_protobuf::CameraCalibration* right_camera) {
  delete right_camera_;
  right_camera_ = right_camera;
  if (right_camera) {
    set_has_right_camera();
  } else {
    clear_has_right_camera();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace doppia_protobuf

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_calibration_2eproto__INCLUDED
